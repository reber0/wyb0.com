<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on </title>
    <link>http://wyb0.com/tags/docker/</link>
    <description>Recent content in docker on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Dec 2018 22:51:04 +0800</lastBuildDate>
    
	<atom:link href="http://wyb0.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用docker-compose构造LAMP环境</title>
      <link>http://wyb0.com/posts/2018/docker-compose-build-lamp/</link>
      <pubDate>Sat, 15 Dec 2018 22:51:04 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/docker-compose-build-lamp/</guid>
      <description>0x00 实现功能 使用docker-compose构造LAMP环境，其中mysql数据库、mysql配置文件、网站文件均持久化存储到本机。
apache、php通过Dockerfile构造，Dockerfile拉取ubuntu镜像，然后安装apache2和php。
mysql的话通过docker的links连接mysql:5.5这个镜像当作数据库。
具体文件参见：https://github.com/reber0/docker_env
0x01 文件构造 ➜ tree apache apache ├── Dockerfile ├── conf │ └── my.cnf ├── docker-compose.yml ├── mysql ├── src │ ├── init.sh │ └── sources.list └── web └── index.php 4 directories, 6 files  0x02 docker-compose.yml version: &#39;3&#39; services: apache: image: ubuntu:apache #镜像名为ubuntu，tag为apache container_name: apache #运行后生成的容器名字为apache build: . #使用当前路径下的Dockerfile构造镜像 ports: - &amp;quot;81:80&amp;quot; volumes: - ./www:/var/www/html links: - mymysql environment: #设置环境变量 - TZ=Asia/Shanghai #设定时区 restart: always #容器重启策略：当容器终止退出后，总是重启容器，默认策略。 mymysql: image: mysql:5.</description>
    </item>
    
    <item>
      <title>Docker之Docker Compose</title>
      <link>http://wyb0.com/posts/2018/docker-compose/</link>
      <pubDate>Mon, 19 Nov 2018 20:10:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2018/docker-compose/</guid>
      <description>0x00 关于docker compose 可以把docker-compose当作docker命令的封装，它是一个用来把 docker 自动化的东西，docker-compose可以一次性管理多个容器，通常用于需要多个容器相互配合来完成某项任务的场景。
0x01 安装与卸载 https://docs.docker.com/compose/install
0x02 一些常用命令  构建容器：docker-compose up -d 启动容器：docker-compose start 停止容器：docker-compose stop 重启容器：docker-compose restart kill容器：docker-compose kill 删除容器：docker-compose rm bash连接容器：docker-compose exec [services_name] bash 执行一条命令：docker-compose run [services_name] [command]  0x03 docker-compose简单应用  结构
. ├── Dockerfile ├── docker-compose.yml └── src ├── app.py └── sources.list 1 directory, 4 files  Dockerfile
FROM ubuntu:14.04.4 MAINTAINER reber &amp;lt;1070018473@qq.com&amp;gt; COPY ./src /code #将data挂载到容器的code WORKDIR /code RUN cp sources.list /etc/apt/sources.</description>
    </item>
    
    <item>
      <title>Docker之数据卷</title>
      <link>http://wyb0.com/posts/2017/docker-volume/</link>
      <pubDate>Tue, 19 Sep 2017 10:35:09 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-volume/</guid>
      <description>0x00 为什么使用数据卷 Docker镜像是由多个文件系统(只读层)叠加而成的。 当一个容器启动时Docker会加载只读镜像层并在其上添加一个读写层。 读写层中的修改在镜像重新启动后会全部丢失。 在Docker中，只读层及在顶部的读写层的组合被称为Union File System(联合文件系统)。 如果想要保存数据，则可以使用数据卷来在容器外面保存数据，主要为如下两种方式： * 使用docker run运行容器时指定数据卷 * 在Dockerfile中直接指定数据卷  0x01 通过docker run挂载Volume(使用-v参数)  不指定主机目录  #运行完后容器中的根目录下就会多个data文件夹，这个就是数据卷 $ docker run -itd --name v_test -v /data debian:jessie /bin/bash root@d145e8c6f874:/# ls bin data etc lib media opt root sbin sys usr boot dev home lib64 mnt proc run srv tmp var root@d145e8c6f874:/# exit exit #查看数据卷的对应位置，前者是宿主机的位置，后者是容器中的位置 $ docker inspect -f {{.Mounts}} v_test [{volume 8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068 /var/lib/docker/volumes/8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068/_data /data local true }]   指定主机目录(只能通过-v参数实现，Dockerfile不行)  # 本机的/home/var/docker_data和容器的/data对应 $ docker run -itd -v /home/var/docker_data:/data debian:jessie /bin/bash root@d853c4ca7632:/# exit exit $ docker inspect -f {{.</description>
    </item>
    
    <item>
      <title>Docker之Dockerfile</title>
      <link>http://wyb0.com/posts/2017/docker-dockerfile/</link>
      <pubDate>Fri, 18 Aug 2017 18:05:43 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-dockerfile/</guid>
      <description>操作系统：macOS Sierra 10.12.6
Docker版本：Docker version 18.09.0, build 4d60db4
0x00 Dockerfile Dockerfile里面其实是一条条的指令，Docker会把Dockerfile的指令翻译为linux命令， 每一条指令都会创建一个镜像，下一条指令将在这个镜像的基础上进行修改操作后再生成一个镜像。 让你可以对下载好的镜像进行一些操作(比如安装软件、向镜像复制文件等)，从而构造定制化的镜像。  0x01 Dockerfile基本指令 FROM &amp;lt;image name&amp;gt;：指定新的镜像基于什么创建(可以尝试使用alpine:latest和debian:jessie) MAINTAINER &amp;lt;author name&amp;gt;：设置该镜像的作者 COPY &amp;lt;source&amp;gt; &amp;lt;dest&amp;gt;：复制文件，dest要以 / 结尾 WORKDIR /path/to/workdir：相当于切换目录，对RUN、CMD、和ENTRYPOINT生效 RUN &amp;lt;command&amp;gt;：在shell执行命令 EXPOSE port1 port2：容器运行时监听的端口 CMD：容器默认的执行命令，Dockerfile只允许使用一次CMD命令(使用数组) ENTRYPOINT：类似于CMD，Dockerfile只允许使用一次(使用数组) ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;：设置环境变量 USER &amp;lt;uid&amp;gt;：镜像正在运行时设置一个uid，即设定启动容器的用户，默认为root VOLUME [&#39;/data&#39;]：授权访问从容器内到主机的目录  CMD与ENTRYPOINT的区别：
#docker run ubuntu:test会执行/bin/echo &#39;this is test&#39; CMD [&#39;/bin/echo&#39;,&#39;this is test&#39;] #docker run ubuntu:test会执行/bin/echo &#39;entrypoint test&#39;，会输出&#39;entrypoint test&#39; ENTRYPOINT [&#39;/bin/echo&#39;,&#39;entrypoint test&#39;] #docker run ubuntu:test init即执行/etc/init.d/mysql init，CMD中的默认参数会被覆盖 ENTRYPOINT [&#39;/etc/init.</description>
    </item>
    
    <item>
      <title>Docker之镜像与容器</title>
      <link>http://wyb0.com/posts/2017/docker-image-and-container/</link>
      <pubDate>Fri, 18 Aug 2017 14:36:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-image-and-container/</guid>
      <description>操作系统：Ubuntu14.04.1
Docker版本：Docker version 17.06.0-ce, build 02c1d87
0x00 镜像操作  下载镜像  #一般镜像、容器的id和name可以互换 $ docker search ubuntu #从公共registry搜索镜像 $ docker pull ubuntu #从公共registry下载镜像 $ docker pull ubuntu:14.04   查看当前系统镜像  $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 14.04 7e4b16ae8b23 11 days ago 188MB ubuntu latest 1d9c17228a9e 11 days ago 86.7MB   查看镜像层组成  $ docker history ubuntu:14.04 # ubuntu:14.04可以用7e4b16ae8b23替代，用id和images_name:tag效果一样   删除镜像(删除镜像前要先删除上面的容器)  $ docker rmi ubuntu:latest # 也可docker rmi 1d9c17228a9e  0x01 容器操作  运行容器(exit后容器就停止了)</description>
    </item>
    
    <item>
      <title>Docker初识</title>
      <link>http://wyb0.com/posts/2017/docker-basis/</link>
      <pubDate>Tue, 15 Aug 2017 22:16:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2017/docker-basis/</guid>
      <description>0x00 关于Docker  Docker中的镜像类似VM的快照，容器类似虚拟机，使用镜像创建容器类似于使用快照创建虚拟机。 Docker中运行应用的是容器，容器的创建和销毁在秒级就能完成。 Docker使用了AUFS，可以以递进的方式创建&amp;rdquo;VM&amp;rdquo;，一个&amp;rdquo;VM&amp;rdquo;叠在另一个&amp;rdquo;VM&amp;rdquo;上，就像使用git增量开发一样。 软件的运行环境（image）和软件本身（container）分离，和数据也分离。  学习Docker需要了解4个概念：镜像、容器、数据卷、链接
0x01 镜像image  Docker Images 只是一个只读模板，用来运行Docker容器，可以在Docker hub(官方镜像库)下载。 镜像拥有唯一ID(比如：72c989e2d109)以及一个供人阅读的名字和标签对(比如：ubuntu:latest)。 镜像必须完全可移植,Docker不允许例外。  0x02 容器container  可以在一个镜像的基础上创建多个容器，每个容器相互独立。 容器也拥有唯一ID以及一个供人阅读的名字。 容器被启动时会被分配一个随机的私有IP，其他容器可以通过这个IP与它进行通信。 Docker允许公开容器的特定端口。 一个容器一个进程，容器设计本意是用来运行一个应用的而非一台机器。 容器应该是短暂和一次性的。 Docker镜像层对于容器来说，是只读的，容器对于文件的写操作绝对不会作用在镜像中。  0x03 数据卷  数据卷表现为容器内的空间，但实际保存在容器外，你可以在不影响数据的情况下销毁、重建、修改、丢弃容器。 Docker允许你定义应用和数据部分，并提供工具让你可以将它们分开。  0x04 链接  Docker允许你在创建一个新容器时引用其它现存容器，在你刚创建的容器里被引用的容器将获得一个你指定的别名，我们就说这两个容器被链接在了一起。 若DB容器已经在运行，我们可以创建一个Web服务器容器，并在创建时引用这个DB容器，可以给它起个别名(比如dbapp)，在新创建的Web服务器容器中，可以在任何时候使用主机名dbapp与DB容器进行通信。  0x05 镜像与容器关系  Docker镜像是一个文件，属于静态的内容；Docker容器属于动态的内容，可以把容器理解为一个或多个运行进程。 Docker可以通过解析Docker镜像的json文件，获知应该在这个镜像之上运行什么样的进程，应该为进程配置怎么样的环境变量。 Docker守护进程手握Docker镜像的json文件，它为容器配置相应的环境并真正运行Docker镜像所指定的进程，从而完成Docker容器的真正创建。 当Docker容器运行起来之后，Docker镜像json文件就失去作用了。此时Docker镜像的绝大部分作用就是：为Docker容器提供一个文件系统的视角，供容器内部的进程访问文件资源。  0x06 Docker有三个组件和三个基本元素  三个组件
 Docker Daemon 运行于主机上，处理服务请求，是用于管理容器的后台进程，上面有一些api接口。 Docker Client 用于操作容器，它是Deamon的api接口(如docker start、docker rm等)的封装。 Docker Index 是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。  三个基本要素
 Docker Images 是一个只读模板，用来运行Docker容器。 Docker Containers 负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。 DockerFile 是文件指令集，用来说明如何自动创建Docker镜像。   0x07 Docker的运行原理  Docker使用以下操作系统的功能来提高容器技术效率</description>
    </item>
    
  </channel>
</rss>